class Input$AbortQueuedMigrationsInput {
  factory Input$AbortQueuedMigrationsInput({
    String? clientMutationId,
    required String ownerId,
  }) =>
      Input$AbortQueuedMigrationsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
      });

  Input$AbortQueuedMigrationsInput._(this._$data);

  factory Input$AbortQueuedMigrationsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    return Input$AbortQueuedMigrationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    return result$data;
  }

  CopyWith$Input$AbortQueuedMigrationsInput<Input$AbortQueuedMigrationsInput>
      get copyWith => CopyWith$Input$AbortQueuedMigrationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AbortQueuedMigrationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
    ]);
  }
}

abstract class CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  factory CopyWith$Input$AbortQueuedMigrationsInput(
    Input$AbortQueuedMigrationsInput instance,
    TRes Function(Input$AbortQueuedMigrationsInput) then,
  ) = _CopyWithImpl$Input$AbortQueuedMigrationsInput;

  factory CopyWith$Input$AbortQueuedMigrationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AbortQueuedMigrationsInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$AbortQueuedMigrationsInput<TRes>
    implements CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  _CopyWithImpl$Input$AbortQueuedMigrationsInput(
    this._instance,
    this._then,
  );

  final Input$AbortQueuedMigrationsInput _instance;

  final TRes Function(Input$AbortQueuedMigrationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$AbortQueuedMigrationsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
      }));
}

class _CopyWithStubImpl$Input$AbortQueuedMigrationsInput<TRes>
    implements CopyWith$Input$AbortQueuedMigrationsInput<TRes> {
  _CopyWithStubImpl$Input$AbortQueuedMigrationsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
  }) =>
      _res;
}

class Input$AcceptEnterpriseAdministratorInvitationInput {
  factory Input$AcceptEnterpriseAdministratorInvitationInput({
    String? clientMutationId,
    required String invitationId,
  }) =>
      Input$AcceptEnterpriseAdministratorInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'invitationId': invitationId,
      });

  Input$AcceptEnterpriseAdministratorInvitationInput._(this._$data);

  factory Input$AcceptEnterpriseAdministratorInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    return Input$AcceptEnterpriseAdministratorInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get invitationId => (_$data['invitationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    return result$data;
  }

  CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<
          Input$AcceptEnterpriseAdministratorInvitationInput>
      get copyWith =>
          CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AcceptEnterpriseAdministratorInvitationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$invitationId = invitationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$invitationId,
    ]);
  }
}

abstract class CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<
    TRes> {
  factory CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput(
    Input$AcceptEnterpriseAdministratorInvitationInput instance,
    TRes Function(Input$AcceptEnterpriseAdministratorInvitationInput) then,
  ) = _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput;

  factory CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput;

  TRes call({
    String? clientMutationId,
    String? invitationId,
  });
}

class _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput<TRes>
    implements
        CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<TRes> {
  _CopyWithImpl$Input$AcceptEnterpriseAdministratorInvitationInput(
    this._instance,
    this._then,
  );

  final Input$AcceptEnterpriseAdministratorInvitationInput _instance;

  final TRes Function(Input$AcceptEnterpriseAdministratorInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? invitationId = _undefined,
  }) =>
      _then(Input$AcceptEnterpriseAdministratorInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
      }));
}

class _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput<TRes>
    implements
        CopyWith$Input$AcceptEnterpriseAdministratorInvitationInput<TRes> {
  _CopyWithStubImpl$Input$AcceptEnterpriseAdministratorInvitationInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? invitationId,
  }) =>
      _res;
}

class Input$AcceptTopicSuggestionInput {
  factory Input$AcceptTopicSuggestionInput({
    String? clientMutationId,
    required String name,
    required String repositoryId,
  }) =>
      Input$AcceptTopicSuggestionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'repositoryId': repositoryId,
      });

  Input$AcceptTopicSuggestionInput._(this._$data);

  factory Input$AcceptTopicSuggestionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$AcceptTopicSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$AcceptTopicSuggestionInput<Input$AcceptTopicSuggestionInput>
      get copyWith => CopyWith$Input$AcceptTopicSuggestionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AcceptTopicSuggestionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  factory CopyWith$Input$AcceptTopicSuggestionInput(
    Input$AcceptTopicSuggestionInput instance,
    TRes Function(Input$AcceptTopicSuggestionInput) then,
  ) = _CopyWithImpl$Input$AcceptTopicSuggestionInput;

  factory CopyWith$Input$AcceptTopicSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AcceptTopicSuggestionInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$AcceptTopicSuggestionInput<TRes>
    implements CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  _CopyWithImpl$Input$AcceptTopicSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$AcceptTopicSuggestionInput _instance;

  final TRes Function(Input$AcceptTopicSuggestionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$AcceptTopicSuggestionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$AcceptTopicSuggestionInput<TRes>
    implements CopyWith$Input$AcceptTopicSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$AcceptTopicSuggestionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? repositoryId,
  }) =>
      _res;
}

class Input$AddAssigneesToAssignableInput {
  factory Input$AddAssigneesToAssignableInput({
    required String assignableId,
    required List<String> assigneeIds,
    String? clientMutationId,
  }) =>
      Input$AddAssigneesToAssignableInput._({
        r'assignableId': assignableId,
        r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$AddAssigneesToAssignableInput._(this._$data);

  factory Input$AddAssigneesToAssignableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$assignableId = data['assignableId'];
    result$data['assignableId'] = (l$assignableId as String);
    final l$assigneeIds = data['assigneeIds'];
    result$data['assigneeIds'] =
        (l$assigneeIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$AddAssigneesToAssignableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get assignableId => (_$data['assignableId'] as String);
  List<String> get assigneeIds => (_$data['assigneeIds'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$assignableId = assignableId;
    result$data['assignableId'] = l$assignableId;
    final l$assigneeIds = assigneeIds;
    result$data['assigneeIds'] = l$assigneeIds.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$AddAssigneesToAssignableInput<
          Input$AddAssigneesToAssignableInput>
      get copyWith => CopyWith$Input$AddAssigneesToAssignableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddAssigneesToAssignableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assignableId = assignableId;
    final lOther$assignableId = other.assignableId;
    if (l$assignableId != lOther$assignableId) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (l$assigneeIds.length != lOther$assigneeIds.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeIds.length; i++) {
      final l$assigneeIds$entry = l$assigneeIds[i];
      final lOther$assigneeIds$entry = lOther$assigneeIds[i];
      if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assignableId = assignableId;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$assignableId,
      Object.hashAll(l$assigneeIds.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  factory CopyWith$Input$AddAssigneesToAssignableInput(
    Input$AddAssigneesToAssignableInput instance,
    TRes Function(Input$AddAssigneesToAssignableInput) then,
  ) = _CopyWithImpl$Input$AddAssigneesToAssignableInput;

  factory CopyWith$Input$AddAssigneesToAssignableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddAssigneesToAssignableInput;

  TRes call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$AddAssigneesToAssignableInput<TRes>
    implements CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  _CopyWithImpl$Input$AddAssigneesToAssignableInput(
    this._instance,
    this._then,
  );

  final Input$AddAssigneesToAssignableInput _instance;

  final TRes Function(Input$AddAssigneesToAssignableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assignableId = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$AddAssigneesToAssignableInput._({
        ..._instance._$data,
        if (assignableId != _undefined && assignableId != null)
          'assignableId': (assignableId as String),
        if (assigneeIds != _undefined && assigneeIds != null)
          'assigneeIds': (assigneeIds as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddAssigneesToAssignableInput<TRes>
    implements CopyWith$Input$AddAssigneesToAssignableInput<TRes> {
  _CopyWithStubImpl$Input$AddAssigneesToAssignableInput(this._res);

  TRes _res;

  call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$AddCommentInput {
  factory Input$AddCommentInput({
    required String body,
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$AddCommentInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$AddCommentInput._(this._$data);

  factory Input$AddCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$AddCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get subjectId => (_$data['subjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$AddCommentInput<Input$AddCommentInput> get copyWith =>
      CopyWith$Input$AddCommentInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddCommentInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$AddCommentInput<TRes> {
  factory CopyWith$Input$AddCommentInput(
    Input$AddCommentInput instance,
    TRes Function(Input$AddCommentInput) then,
  ) = _CopyWithImpl$Input$AddCommentInput;

  factory CopyWith$Input$AddCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddCommentInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$AddCommentInput<TRes>
    implements CopyWith$Input$AddCommentInput<TRes> {
  _CopyWithImpl$Input$AddCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddCommentInput _instance;

  final TRes Function(Input$AddCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$AddCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$AddCommentInput<TRes>
    implements CopyWith$Input$AddCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$AddDiscussionCommentInput {
  factory Input$AddDiscussionCommentInput({
    required String body,
    String? clientMutationId,
    required String discussionId,
    String? replyToId,
  }) =>
      Input$AddDiscussionCommentInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
        if (replyToId != null) r'replyToId': replyToId,
      });

  Input$AddDiscussionCommentInput._(this._$data);

  factory Input$AddDiscussionCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('replyToId')) {
      final l$replyToId = data['replyToId'];
      result$data['replyToId'] = (l$replyToId as String?);
    }
    return Input$AddDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get discussionId => (_$data['discussionId'] as String);
  String? get replyToId => (_$data['replyToId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('replyToId')) {
      final l$replyToId = replyToId;
      result$data['replyToId'] = l$replyToId;
    }
    return result$data;
  }

  CopyWith$Input$AddDiscussionCommentInput<Input$AddDiscussionCommentInput>
      get copyWith => CopyWith$Input$AddDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$replyToId = replyToId;
    final lOther$replyToId = other.replyToId;
    if (_$data.containsKey('replyToId') !=
        other._$data.containsKey('replyToId')) {
      return false;
    }
    if (l$replyToId != lOther$replyToId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$replyToId = replyToId;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
      _$data.containsKey('replyToId') ? l$replyToId : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddDiscussionCommentInput<TRes> {
  factory CopyWith$Input$AddDiscussionCommentInput(
    Input$AddDiscussionCommentInput instance,
    TRes Function(Input$AddDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$AddDiscussionCommentInput;

  factory CopyWith$Input$AddDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddDiscussionCommentInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? discussionId,
    String? replyToId,
  });
}

class _CopyWithImpl$Input$AddDiscussionCommentInput<TRes>
    implements CopyWith$Input$AddDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$AddDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddDiscussionCommentInput _instance;

  final TRes Function(Input$AddDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? replyToId = _undefined,
  }) =>
      _then(Input$AddDiscussionCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (replyToId != _undefined) 'replyToId': (replyToId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddDiscussionCommentInput<TRes>
    implements CopyWith$Input$AddDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? discussionId,
    String? replyToId,
  }) =>
      _res;
}

class Input$AddDiscussionPollVoteInput {
  factory Input$AddDiscussionPollVoteInput({
    String? clientMutationId,
    required String pollOptionId,
  }) =>
      Input$AddDiscussionPollVoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pollOptionId': pollOptionId,
      });

  Input$AddDiscussionPollVoteInput._(this._$data);

  factory Input$AddDiscussionPollVoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pollOptionId = data['pollOptionId'];
    result$data['pollOptionId'] = (l$pollOptionId as String);
    return Input$AddDiscussionPollVoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pollOptionId => (_$data['pollOptionId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pollOptionId = pollOptionId;
    result$data['pollOptionId'] = l$pollOptionId;
    return result$data;
  }

  CopyWith$Input$AddDiscussionPollVoteInput<Input$AddDiscussionPollVoteInput>
      get copyWith => CopyWith$Input$AddDiscussionPollVoteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddDiscussionPollVoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pollOptionId = pollOptionId;
    final lOther$pollOptionId = other.pollOptionId;
    if (l$pollOptionId != lOther$pollOptionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pollOptionId = pollOptionId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pollOptionId,
    ]);
  }
}

abstract class CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  factory CopyWith$Input$AddDiscussionPollVoteInput(
    Input$AddDiscussionPollVoteInput instance,
    TRes Function(Input$AddDiscussionPollVoteInput) then,
  ) = _CopyWithImpl$Input$AddDiscussionPollVoteInput;

  factory CopyWith$Input$AddDiscussionPollVoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddDiscussionPollVoteInput;

  TRes call({
    String? clientMutationId,
    String? pollOptionId,
  });
}

class _CopyWithImpl$Input$AddDiscussionPollVoteInput<TRes>
    implements CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  _CopyWithImpl$Input$AddDiscussionPollVoteInput(
    this._instance,
    this._then,
  );

  final Input$AddDiscussionPollVoteInput _instance;

  final TRes Function(Input$AddDiscussionPollVoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pollOptionId = _undefined,
  }) =>
      _then(Input$AddDiscussionPollVoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pollOptionId != _undefined && pollOptionId != null)
          'pollOptionId': (pollOptionId as String),
      }));
}

class _CopyWithStubImpl$Input$AddDiscussionPollVoteInput<TRes>
    implements CopyWith$Input$AddDiscussionPollVoteInput<TRes> {
  _CopyWithStubImpl$Input$AddDiscussionPollVoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pollOptionId,
  }) =>
      _res;
}

class Input$AddEnterpriseOrganizationMemberInput {
  factory Input$AddEnterpriseOrganizationMemberInput({
    String? clientMutationId,
    required String enterpriseId,
    required String organizationId,
    Enum$OrganizationMemberRole? role,
    required List<String> userIds,
  }) =>
      Input$AddEnterpriseOrganizationMemberInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
        if (role != null) r'role': role,
        r'userIds': userIds,
      });

  Input$AddEnterpriseOrganizationMemberInput._(this._$data);

  factory Input$AddEnterpriseOrganizationMemberInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : fromJson$Enum$OrganizationMemberRole((l$role as String));
    }
    final l$userIds = data['userIds'];
    result$data['userIds'] =
        (l$userIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$AddEnterpriseOrganizationMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get organizationId => (_$data['organizationId'] as String);
  Enum$OrganizationMemberRole? get role =>
      (_$data['role'] as Enum$OrganizationMemberRole?);
  List<String> get userIds => (_$data['userIds'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] =
          l$role == null ? null : toJson$Enum$OrganizationMemberRole(l$role);
    }
    final l$userIds = userIds;
    result$data['userIds'] = l$userIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$AddEnterpriseOrganizationMemberInput<
          Input$AddEnterpriseOrganizationMemberInput>
      get copyWith => CopyWith$Input$AddEnterpriseOrganizationMemberInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddEnterpriseOrganizationMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    final l$userIds = userIds;
    final lOther$userIds = other.userIds;
    if (l$userIds.length != lOther$userIds.length) {
      return false;
    }
    for (int i = 0; i < l$userIds.length; i++) {
      final l$userIds$entry = l$userIds[i];
      final lOther$userIds$entry = lOther$userIds[i];
      if (l$userIds$entry != lOther$userIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    final l$role = role;
    final l$userIds = userIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$organizationId,
      _$data.containsKey('role') ? l$role : const {},
      Object.hashAll(l$userIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$AddEnterpriseOrganizationMemberInput<TRes> {
  factory CopyWith$Input$AddEnterpriseOrganizationMemberInput(
    Input$AddEnterpriseOrganizationMemberInput instance,
    TRes Function(Input$AddEnterpriseOrganizationMemberInput) then,
  ) = _CopyWithImpl$Input$AddEnterpriseOrganizationMemberInput;

  factory CopyWith$Input$AddEnterpriseOrganizationMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddEnterpriseOrganizationMemberInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    Enum$OrganizationMemberRole? role,
    List<String>? userIds,
  });
}

class _CopyWithImpl$Input$AddEnterpriseOrganizationMemberInput<TRes>
    implements CopyWith$Input$AddEnterpriseOrganizationMemberInput<TRes> {
  _CopyWithImpl$Input$AddEnterpriseOrganizationMemberInput(
    this._instance,
    this._then,
  );

  final Input$AddEnterpriseOrganizationMemberInput _instance;

  final TRes Function(Input$AddEnterpriseOrganizationMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
    Object? role = _undefined,
    Object? userIds = _undefined,
  }) =>
      _then(Input$AddEnterpriseOrganizationMemberInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (role != _undefined) 'role': (role as Enum$OrganizationMemberRole?),
        if (userIds != _undefined && userIds != null)
          'userIds': (userIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$AddEnterpriseOrganizationMemberInput<TRes>
    implements CopyWith$Input$AddEnterpriseOrganizationMemberInput<TRes> {
  _CopyWithStubImpl$Input$AddEnterpriseOrganizationMemberInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    Enum$OrganizationMemberRole? role,
    List<String>? userIds,
  }) =>
      _res;
}

class Input$AddEnterpriseSupportEntitlementInput {
  factory Input$AddEnterpriseSupportEntitlementInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$AddEnterpriseSupportEntitlementInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$AddEnterpriseSupportEntitlementInput._(this._$data);

  factory Input$AddEnterpriseSupportEntitlementInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$AddEnterpriseSupportEntitlementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$AddEnterpriseSupportEntitlementInput<
          Input$AddEnterpriseSupportEntitlementInput>
      get copyWith => CopyWith$Input$AddEnterpriseSupportEntitlementInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddEnterpriseSupportEntitlementInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  factory CopyWith$Input$AddEnterpriseSupportEntitlementInput(
    Input$AddEnterpriseSupportEntitlementInput instance,
    TRes Function(Input$AddEnterpriseSupportEntitlementInput) then,
  ) = _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput;

  factory CopyWith$Input$AddEnterpriseSupportEntitlementInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithImpl$Input$AddEnterpriseSupportEntitlementInput(
    this._instance,
    this._then,
  );

  final Input$AddEnterpriseSupportEntitlementInput _instance;

  final TRes Function(Input$AddEnterpriseSupportEntitlementInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$AddEnterpriseSupportEntitlementInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$AddEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithStubImpl$Input$AddEnterpriseSupportEntitlementInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$AddLabelsToLabelableInput {
  factory Input$AddLabelsToLabelableInput({
    String? clientMutationId,
    required List<String> labelIds,
    required String labelableId,
  }) =>
      Input$AddLabelsToLabelableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'labelIds': labelIds,
        r'labelableId': labelableId,
      });

  Input$AddLabelsToLabelableInput._(this._$data);

  factory Input$AddLabelsToLabelableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$labelIds = data['labelIds'];
    result$data['labelIds'] =
        (l$labelIds as List<dynamic>).map((e) => (e as String)).toList();
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    return Input$AddLabelsToLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get labelIds => (_$data['labelIds'] as List<String>);
  String get labelableId => (_$data['labelableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$labelIds = labelIds;
    result$data['labelIds'] = l$labelIds.map((e) => e).toList();
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    return result$data;
  }

  CopyWith$Input$AddLabelsToLabelableInput<Input$AddLabelsToLabelableInput>
      get copyWith => CopyWith$Input$AddLabelsToLabelableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddLabelsToLabelableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (l$labelIds.length != lOther$labelIds.length) {
      return false;
    }
    for (int i = 0; i < l$labelIds.length; i++) {
      final l$labelIds$entry = l$labelIds[i];
      final lOther$labelIds$entry = lOther$labelIds[i];
      if (l$labelIds$entry != lOther$labelIds$entry) {
        return false;
      }
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$labelIds = labelIds;
    final l$labelableId = labelableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$labelIds.map((v) => v)),
      l$labelableId,
    ]);
  }
}

abstract class CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  factory CopyWith$Input$AddLabelsToLabelableInput(
    Input$AddLabelsToLabelableInput instance,
    TRes Function(Input$AddLabelsToLabelableInput) then,
  ) = _CopyWithImpl$Input$AddLabelsToLabelableInput;

  factory CopyWith$Input$AddLabelsToLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddLabelsToLabelableInput;

  TRes call({
    String? clientMutationId,
    List<String>? labelIds,
    String? labelableId,
  });
}

class _CopyWithImpl$Input$AddLabelsToLabelableInput<TRes>
    implements CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  _CopyWithImpl$Input$AddLabelsToLabelableInput(
    this._instance,
    this._then,
  );

  final Input$AddLabelsToLabelableInput _instance;

  final TRes Function(Input$AddLabelsToLabelableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? labelIds = _undefined,
    Object? labelableId = _undefined,
  }) =>
      _then(Input$AddLabelsToLabelableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelIds != _undefined && labelIds != null)
          'labelIds': (labelIds as List<String>),
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
      }));
}

class _CopyWithStubImpl$Input$AddLabelsToLabelableInput<TRes>
    implements CopyWith$Input$AddLabelsToLabelableInput<TRes> {
  _CopyWithStubImpl$Input$AddLabelsToLabelableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<String>? labelIds,
    String? labelableId,
  }) =>
      _res;
}

class Input$AddProjectCardInput {
  factory Input$AddProjectCardInput({
    String? clientMutationId,
    String? contentId,
    String? note,
    required String projectColumnId,
  }) =>
      Input$AddProjectCardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (contentId != null) r'contentId': contentId,
        if (note != null) r'note': note,
        r'projectColumnId': projectColumnId,
      });

  Input$AddProjectCardInput._(this._$data);

  factory Input$AddProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('contentId')) {
      final l$contentId = data['contentId'];
      result$data['contentId'] = (l$contentId as String?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    final l$projectColumnId = data['projectColumnId'];
    result$data['projectColumnId'] = (l$projectColumnId as String);
    return Input$AddProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get contentId => (_$data['contentId'] as String?);
  String? get note => (_$data['note'] as String?);
  String get projectColumnId => (_$data['projectColumnId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('contentId')) {
      final l$contentId = contentId;
      result$data['contentId'] = l$contentId;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    final l$projectColumnId = projectColumnId;
    result$data['projectColumnId'] = l$projectColumnId;
    return result$data;
  }

  CopyWith$Input$AddProjectCardInput<Input$AddProjectCardInput> get copyWith =>
      CopyWith$Input$AddProjectCardInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (_$data.containsKey('contentId') !=
        other._$data.containsKey('contentId')) {
      return false;
    }
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$projectColumnId = projectColumnId;
    final lOther$projectColumnId = other.projectColumnId;
    if (l$projectColumnId != lOther$projectColumnId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$contentId = contentId;
    final l$note = note;
    final l$projectColumnId = projectColumnId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('contentId') ? l$contentId : const {},
      _$data.containsKey('note') ? l$note : const {},
      l$projectColumnId,
    ]);
  }
}

abstract class CopyWith$Input$AddProjectCardInput<TRes> {
  factory CopyWith$Input$AddProjectCardInput(
    Input$AddProjectCardInput instance,
    TRes Function(Input$AddProjectCardInput) then,
  ) = _CopyWithImpl$Input$AddProjectCardInput;

  factory CopyWith$Input$AddProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectCardInput;

  TRes call({
    String? clientMutationId,
    String? contentId,
    String? note,
    String? projectColumnId,
  });
}

class _CopyWithImpl$Input$AddProjectCardInput<TRes>
    implements CopyWith$Input$AddProjectCardInput<TRes> {
  _CopyWithImpl$Input$AddProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectCardInput _instance;

  final TRes Function(Input$AddProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? contentId = _undefined,
    Object? note = _undefined,
    Object? projectColumnId = _undefined,
  }) =>
      _then(Input$AddProjectCardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (contentId != _undefined) 'contentId': (contentId as String?),
        if (note != _undefined) 'note': (note as String?),
        if (projectColumnId != _undefined && projectColumnId != null)
          'projectColumnId': (projectColumnId as String),
      }));
}

class _CopyWithStubImpl$Input$AddProjectCardInput<TRes>
    implements CopyWith$Input$AddProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectCardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? contentId,
    String? note,
    String? projectColumnId,
  }) =>
      _res;
}

class Input$AddProjectColumnInput {
  factory Input$AddProjectColumnInput({
    String? clientMutationId,
    required String name,
    required String projectId,
  }) =>
      Input$AddProjectColumnInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'projectId': projectId,
      });

  Input$AddProjectColumnInput._(this._$data);

  factory Input$AddProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$AddProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$AddProjectColumnInput<Input$AddProjectColumnInput>
      get copyWith => CopyWith$Input$AddProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$AddProjectColumnInput<TRes> {
  factory CopyWith$Input$AddProjectColumnInput(
    Input$AddProjectColumnInput instance,
    TRes Function(Input$AddProjectColumnInput) then,
  ) = _CopyWithImpl$Input$AddProjectColumnInput;

  factory CopyWith$Input$AddProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectColumnInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? projectId,
  });
}

class _CopyWithImpl$Input$AddProjectColumnInput<TRes>
    implements CopyWith$Input$AddProjectColumnInput<TRes> {
  _CopyWithImpl$Input$AddProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectColumnInput _instance;

  final TRes Function(Input$AddProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$AddProjectColumnInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$AddProjectColumnInput<TRes>
    implements CopyWith$Input$AddProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectColumnInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? projectId,
  }) =>
      _res;
}

class Input$AddProjectV2DraftIssueInput {
  factory Input$AddProjectV2DraftIssueInput({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    required String projectId,
    required String title,
  }) =>
      Input$AddProjectV2DraftIssueInput._({
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'title': title,
      });

  Input$AddProjectV2DraftIssueInput._(this._$data);

  factory Input$AddProjectV2DraftIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$AddProjectV2DraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$AddProjectV2DraftIssueInput<Input$AddProjectV2DraftIssueInput>
      get copyWith => CopyWith$Input$AddProjectV2DraftIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectV2DraftIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assigneeIds = assigneeIds;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  factory CopyWith$Input$AddProjectV2DraftIssueInput(
    Input$AddProjectV2DraftIssueInput instance,
    TRes Function(Input$AddProjectV2DraftIssueInput) then,
  ) = _CopyWithImpl$Input$AddProjectV2DraftIssueInput;

  factory CopyWith$Input$AddProjectV2DraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput;

  TRes call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? projectId,
    String? title,
  });
}

class _CopyWithImpl$Input$AddProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  _CopyWithImpl$Input$AddProjectV2DraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectV2DraftIssueInput _instance;

  final TRes Function(Input$AddProjectV2DraftIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assigneeIds = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$AddProjectV2DraftIssueInput._({
        ..._instance._$data,
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$AddProjectV2DraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectV2DraftIssueInput(this._res);

  TRes _res;

  call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? projectId,
    String? title,
  }) =>
      _res;
}

class Input$AddProjectV2ItemByIdInput {
  factory Input$AddProjectV2ItemByIdInput({
    String? clientMutationId,
    required String contentId,
    required String projectId,
  }) =>
      Input$AddProjectV2ItemByIdInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'contentId': contentId,
        r'projectId': projectId,
      });

  Input$AddProjectV2ItemByIdInput._(this._$data);

  factory Input$AddProjectV2ItemByIdInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$contentId = data['contentId'];
    result$data['contentId'] = (l$contentId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$AddProjectV2ItemByIdInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get contentId => (_$data['contentId'] as String);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$contentId = contentId;
    result$data['contentId'] = l$contentId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$AddProjectV2ItemByIdInput<Input$AddProjectV2ItemByIdInput>
      get copyWith => CopyWith$Input$AddProjectV2ItemByIdInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddProjectV2ItemByIdInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$contentId = contentId;
    final lOther$contentId = other.contentId;
    if (l$contentId != lOther$contentId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$contentId = contentId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$contentId,
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  factory CopyWith$Input$AddProjectV2ItemByIdInput(
    Input$AddProjectV2ItemByIdInput instance,
    TRes Function(Input$AddProjectV2ItemByIdInput) then,
  ) = _CopyWithImpl$Input$AddProjectV2ItemByIdInput;

  factory CopyWith$Input$AddProjectV2ItemByIdInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput;

  TRes call({
    String? clientMutationId,
    String? contentId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$AddProjectV2ItemByIdInput<TRes>
    implements CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  _CopyWithImpl$Input$AddProjectV2ItemByIdInput(
    this._instance,
    this._then,
  );

  final Input$AddProjectV2ItemByIdInput _instance;

  final TRes Function(Input$AddProjectV2ItemByIdInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? contentId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$AddProjectV2ItemByIdInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (contentId != _undefined && contentId != null)
          'contentId': (contentId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput<TRes>
    implements CopyWith$Input$AddProjectV2ItemByIdInput<TRes> {
  _CopyWithStubImpl$Input$AddProjectV2ItemByIdInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? contentId,
    String? projectId,
  }) =>
      _res;
}

class Input$AddPullRequestReviewCommentInput {
  factory Input$AddPullRequestReviewCommentInput({
    required String body,
    String? clientMutationId,
    String? commitOID,
    String? inReplyTo,
    String? path,
    int? position,
    String? pullRequestId,
    String? pullRequestReviewId,
  }) =>
      Input$AddPullRequestReviewCommentInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (commitOID != null) r'commitOID': commitOID,
        if (inReplyTo != null) r'inReplyTo': inReplyTo,
        if (path != null) r'path': path,
        if (position != null) r'position': position,
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
      });

  Input$AddPullRequestReviewCommentInput._(this._$data);

  factory Input$AddPullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('commitOID')) {
      final l$commitOID = data['commitOID'];
      result$data['commitOID'] = (l$commitOID as String?);
    }
    if (data.containsKey('inReplyTo')) {
      final l$inReplyTo = data['inReplyTo'];
      result$data['inReplyTo'] = (l$inReplyTo as String?);
    }
    if (data.containsKey('path')) {
      final l$path = data['path'];
      result$data['path'] = (l$path as String?);
    }
    if (data.containsKey('position')) {
      final l$position = data['position'];
      result$data['position'] = (l$position as int?);
    }
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    return Input$AddPullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get commitOID => (_$data['commitOID'] as String?);
  String? get inReplyTo => (_$data['inReplyTo'] as String?);
  String? get path => (_$data['path'] as String?);
  int? get position => (_$data['position'] as int?);
  String? get pullRequestId => (_$data['pullRequestId'] as String?);
  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('commitOID')) {
      final l$commitOID = commitOID;
      result$data['commitOID'] = l$commitOID;
    }
    if (_$data.containsKey('inReplyTo')) {
      final l$inReplyTo = inReplyTo;
      result$data['inReplyTo'] = l$inReplyTo;
    }
    if (_$data.containsKey('path')) {
      final l$path = path;
      result$data['path'] = l$path;
    }
    if (_$data.containsKey('position')) {
      final l$position = position;
      result$data['position'] = l$position;
    }
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewCommentInput<
          Input$AddPullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddPullRequestReviewCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$commitOID = commitOID;
    final lOther$commitOID = other.commitOID;
    if (_$data.containsKey('commitOID') !=
        other._$data.containsKey('commitOID')) {
      return false;
    }
    if (l$commitOID != lOther$commitOID) {
      return false;
    }
    final l$inReplyTo = inReplyTo;
    final lOther$inReplyTo = other.inReplyTo;
    if (_$data.containsKey('inReplyTo') !=
        other._$data.containsKey('inReplyTo')) {
      return false;
    }
    if (l$inReplyTo != lOther$inReplyTo) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (_$data.containsKey('path') != other._$data.containsKey('path')) {
      return false;
    }
    if (l$path != lOther$path) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (_$data.containsKey('position') !=
        other._$data.containsKey('position')) {
      return false;
    }
    if (l$position != lOther$position) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$commitOID = commitOID;
    final l$inReplyTo = inReplyTo;
    final l$path = path;
    final l$position = position;
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('commitOID') ? l$commitOID : const {},
      _$data.containsKey('inReplyTo') ? l$inReplyTo : const {},
      _$data.containsKey('path') ? l$path : const {},
      _$data.containsKey('position') ? l$position : const {},
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewCommentInput(
    Input$AddPullRequestReviewCommentInput instance,
    TRes Function(Input$AddPullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewCommentInput;

  factory CopyWith$Input$AddPullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? commitOID,
    String? inReplyTo,
    String? path,
    int? position,
    String? pullRequestId,
    String? pullRequestReviewId,
  });
}

class _CopyWithImpl$Input$AddPullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewCommentInput _instance;

  final TRes Function(Input$AddPullRequestReviewCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? commitOID = _undefined,
    Object? inReplyTo = _undefined,
    Object? path = _undefined,
    Object? position = _undefined,
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (commitOID != _undefined) 'commitOID': (commitOID as String?),
        if (inReplyTo != _undefined) 'inReplyTo': (inReplyTo as String?),
        if (path != _undefined) 'path': (path as String?),
        if (position != _undefined) 'position': (position as int?),
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
      }));
}

class _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? commitOID,
    String? inReplyTo,
    String? path,
    int? position,
    String? pullRequestId,
    String? pullRequestReviewId,
  }) =>
      _res;
}

class Input$AddPullRequestReviewInput {
  factory Input$AddPullRequestReviewInput({
    String? body,
    String? clientMutationId,
    List<Input$DraftPullRequestReviewComment?>? comments,
    String? commitOID,
    Enum$PullRequestReviewEvent? event,
    required String pullRequestId,
    List<Input$DraftPullRequestReviewThread?>? threads,
  }) =>
      Input$AddPullRequestReviewInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (comments != null) r'comments': comments,
        if (commitOID != null) r'commitOID': commitOID,
        if (event != null) r'event': event,
        r'pullRequestId': pullRequestId,
        if (threads != null) r'threads': threads,
      });

  Input$AddPullRequestReviewInput._(this._$data);

  factory Input$AddPullRequestReviewInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('comments')) {
      final l$comments = data['comments'];
      result$data['comments'] = (l$comments as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$DraftPullRequestReviewComment.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('commitOID')) {
      final l$commitOID = data['commitOID'];
      result$data['commitOID'] = (l$commitOID as String?);
    }
    if (data.containsKey('event')) {
      final l$event = data['event'];
      result$data['event'] = l$event == null
          ? null
          : fromJson$Enum$PullRequestReviewEvent((l$event as String));
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('threads')) {
      final l$threads = data['threads'];
      result$data['threads'] = (l$threads as List<dynamic>?)
          ?.map((e) => e == null
              ? null
              : Input$DraftPullRequestReviewThread.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$AddPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<Input$DraftPullRequestReviewComment?>? get comments =>
      (_$data['comments'] as List<Input$DraftPullRequestReviewComment?>?);
  String? get commitOID => (_$data['commitOID'] as String?);
  Enum$PullRequestReviewEvent? get event =>
      (_$data['event'] as Enum$PullRequestReviewEvent?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  List<Input$DraftPullRequestReviewThread?>? get threads =>
      (_$data['threads'] as List<Input$DraftPullRequestReviewThread?>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('comments')) {
      final l$comments = comments;
      result$data['comments'] = l$comments?.map((e) => e?.toJson()).toList();
    }
    if (_$data.containsKey('commitOID')) {
      final l$commitOID = commitOID;
      result$data['commitOID'] = l$commitOID;
    }
    if (_$data.containsKey('event')) {
      final l$event = event;
      result$data['event'] =
          l$event == null ? null : toJson$Enum$PullRequestReviewEvent(l$event);
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('threads')) {
      final l$threads = threads;
      result$data['threads'] = l$threads?.map((e) => e?.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewInput<Input$AddPullRequestReviewInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddPullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$comments = comments;
    final lOther$comments = other.comments;
    if (_$data.containsKey('comments') !=
        other._$data.containsKey('comments')) {
      return false;
    }
    if (l$comments != null && lOther$comments != null) {
      if (l$comments.length != lOther$comments.length) {
        return false;
      }
      for (int i = 0; i < l$comments.length; i++) {
        final l$comments$entry = l$comments[i];
        final lOther$comments$entry = lOther$comments[i];
        if (l$comments$entry != lOther$comments$entry) {
          return false;
        }
      }
    } else if (l$comments != lOther$comments) {
      return false;
    }
    final l$commitOID = commitOID;
    final lOther$commitOID = other.commitOID;
    if (_$data.containsKey('commitOID') !=
        other._$data.containsKey('commitOID')) {
      return false;
    }
    if (l$commitOID != lOther$commitOID) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (_$data.containsKey('event') != other._$data.containsKey('event')) {
      return false;
    }
    if (l$event != lOther$event) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$threads = threads;
    final lOther$threads = other.threads;
    if (_$data.containsKey('threads') != other._$data.containsKey('threads')) {
      return false;
    }
    if (l$threads != null && lOther$threads != null) {
      if (l$threads.length != lOther$threads.length) {
        return false;
      }
      for (int i = 0; i < l$threads.length; i++) {
        final l$threads$entry = l$threads[i];
        final lOther$threads$entry = lOther$threads[i];
        if (l$threads$entry != lOther$threads$entry) {
          return false;
        }
      }
    } else if (l$threads != lOther$threads) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$comments = comments;
    final l$commitOID = commitOID;
    final l$event = event;
    final l$pullRequestId = pullRequestId;
    final l$threads = threads;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('comments')
          ? l$comments == null
              ? null
              : Object.hashAll(l$comments.map((v) => v))
          : const {},
      _$data.containsKey('commitOID') ? l$commitOID : const {},
      _$data.containsKey('event') ? l$event : const {},
      l$pullRequestId,
      _$data.containsKey('threads')
          ? l$threads == null
              ? null
              : Object.hashAll(l$threads.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewInput(
    Input$AddPullRequestReviewInput instance,
    TRes Function(Input$AddPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewInput;

  factory CopyWith$Input$AddPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewInput;

  TRes call({
    String? body,
    String? clientMutationId,
    List<Input$DraftPullRequestReviewComment?>? comments,
    String? commitOID,
    Enum$PullRequestReviewEvent? event,
    String? pullRequestId,
    List<Input$DraftPullRequestReviewThread?>? threads,
  });
  TRes comments(
      Iterable<Input$DraftPullRequestReviewComment?>? Function(
              Iterable<
                  CopyWith$Input$DraftPullRequestReviewComment<
                      Input$DraftPullRequestReviewComment>?>?)
          _fn);
  TRes threads(
      Iterable<Input$DraftPullRequestReviewThread?>? Function(
              Iterable<
                  CopyWith$Input$DraftPullRequestReviewThread<
                      Input$DraftPullRequestReviewThread>?>?)
          _fn);
}

class _CopyWithImpl$Input$AddPullRequestReviewInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewInput _instance;

  final TRes Function(Input$AddPullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? comments = _undefined,
    Object? commitOID = _undefined,
    Object? event = _undefined,
    Object? pullRequestId = _undefined,
    Object? threads = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (comments != _undefined)
          'comments': (comments as List<Input$DraftPullRequestReviewComment?>?),
        if (commitOID != _undefined) 'commitOID': (commitOID as String?),
        if (event != _undefined)
          'event': (event as Enum$PullRequestReviewEvent?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (threads != _undefined)
          'threads': (threads as List<Input$DraftPullRequestReviewThread?>?),
      }));
  TRes comments(
          Iterable<Input$DraftPullRequestReviewComment?>? Function(
                  Iterable<
                      CopyWith$Input$DraftPullRequestReviewComment<
                          Input$DraftPullRequestReviewComment>?>?)
              _fn) =>
      call(
          comments: _fn(_instance.comments?.map((e) => e == null
              ? null
              : CopyWith$Input$DraftPullRequestReviewComment(
                  e,
                  (i) => i,
                )))?.toList());
  TRes threads(
          Iterable<Input$DraftPullRequestReviewThread?>? Function(
                  Iterable<
                      CopyWith$Input$DraftPullRequestReviewThread<
                          Input$DraftPullRequestReviewThread>?>?)
              _fn) =>
      call(
          threads: _fn(_instance.threads?.map((e) => e == null
              ? null
              : CopyWith$Input$DraftPullRequestReviewThread(
                  e,
                  (i) => i,
                )))?.toList());
}

class _CopyWithStubImpl$Input$AddPullRequestReviewInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    List<Input$DraftPullRequestReviewComment?>? comments,
    String? commitOID,
    Enum$PullRequestReviewEvent? event,
    String? pullRequestId,
    List<Input$DraftPullRequestReviewThread?>? threads,
  }) =>
      _res;
  comments(_fn) => _res;
  threads(_fn) => _res;
}

class Input$AddPullRequestReviewThreadInput {
  factory Input$AddPullRequestReviewThreadInput({
    required String body,
    String? clientMutationId,
    required int line,
    required String path,
    String? pullRequestId,
    String? pullRequestReviewId,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
  }) =>
      Input$AddPullRequestReviewThreadInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'line': line,
        r'path': path,
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
        if (side != null) r'side': side,
        if (startLine != null) r'startLine': startLine,
        if (startSide != null) r'startSide': startSide,
      });

  Input$AddPullRequestReviewThreadInput._(this._$data);

  factory Input$AddPullRequestReviewThreadInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$line = data['line'];
    result$data['line'] = (l$line as int);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    if (data.containsKey('side')) {
      final l$side = data['side'];
      result$data['side'] =
          l$side == null ? null : fromJson$Enum$DiffSide((l$side as String));
    }
    if (data.containsKey('startLine')) {
      final l$startLine = data['startLine'];
      result$data['startLine'] = (l$startLine as int?);
    }
    if (data.containsKey('startSide')) {
      final l$startSide = data['startSide'];
      result$data['startSide'] = l$startSide == null
          ? null
          : fromJson$Enum$DiffSide((l$startSide as String));
    }
    return Input$AddPullRequestReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  int get line => (_$data['line'] as int);
  String get path => (_$data['path'] as String);
  String? get pullRequestId => (_$data['pullRequestId'] as String?);
  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);
  Enum$DiffSide? get side => (_$data['side'] as Enum$DiffSide?);
  int? get startLine => (_$data['startLine'] as int?);
  Enum$DiffSide? get startSide => (_$data['startSide'] as Enum$DiffSide?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$line = line;
    result$data['line'] = l$line;
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    if (_$data.containsKey('side')) {
      final l$side = side;
      result$data['side'] =
          l$side == null ? null : toJson$Enum$DiffSide(l$side);
    }
    if (_$data.containsKey('startLine')) {
      final l$startLine = startLine;
      result$data['startLine'] = l$startLine;
    }
    if (_$data.containsKey('startSide')) {
      final l$startSide = startSide;
      result$data['startSide'] =
          l$startSide == null ? null : toJson$Enum$DiffSide(l$startSide);
    }
    return result$data;
  }

  CopyWith$Input$AddPullRequestReviewThreadInput<
          Input$AddPullRequestReviewThreadInput>
      get copyWith => CopyWith$Input$AddPullRequestReviewThreadInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddPullRequestReviewThreadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$line = line;
    final lOther$line = other.line;
    if (l$line != lOther$line) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    final l$side = side;
    final lOther$side = other.side;
    if (_$data.containsKey('side') != other._$data.containsKey('side')) {
      return false;
    }
    if (l$side != lOther$side) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (_$data.containsKey('startLine') !=
        other._$data.containsKey('startLine')) {
      return false;
    }
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startSide = startSide;
    final lOther$startSide = other.startSide;
    if (_$data.containsKey('startSide') !=
        other._$data.containsKey('startSide')) {
      return false;
    }
    if (l$startSide != lOther$startSide) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$line = line;
    final l$path = path;
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    final l$side = side;
    final l$startLine = startLine;
    final l$startSide = startSide;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$line,
      l$path,
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
      _$data.containsKey('side') ? l$side : const {},
      _$data.containsKey('startLine') ? l$startLine : const {},
      _$data.containsKey('startSide') ? l$startSide : const {},
    ]);
  }
}

abstract class CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  factory CopyWith$Input$AddPullRequestReviewThreadInput(
    Input$AddPullRequestReviewThreadInput instance,
    TRes Function(Input$AddPullRequestReviewThreadInput) then,
  ) = _CopyWithImpl$Input$AddPullRequestReviewThreadInput;

  factory CopyWith$Input$AddPullRequestReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput;

  TRes call({
    String? body,
    String? clientMutationId,
    int? line,
    String? path,
    String? pullRequestId,
    String? pullRequestReviewId,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
  });
}

class _CopyWithImpl$Input$AddPullRequestReviewThreadInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  _CopyWithImpl$Input$AddPullRequestReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$AddPullRequestReviewThreadInput _instance;

  final TRes Function(Input$AddPullRequestReviewThreadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? line = _undefined,
    Object? path = _undefined,
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
    Object? side = _undefined,
    Object? startLine = _undefined,
    Object? startSide = _undefined,
  }) =>
      _then(Input$AddPullRequestReviewThreadInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (line != _undefined && line != null) 'line': (line as int),
        if (path != _undefined && path != null) 'path': (path as String),
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
        if (side != _undefined) 'side': (side as Enum$DiffSide?),
        if (startLine != _undefined) 'startLine': (startLine as int?),
        if (startSide != _undefined) 'startSide': (startSide as Enum$DiffSide?),
      }));
}

class _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput<TRes>
    implements CopyWith$Input$AddPullRequestReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$AddPullRequestReviewThreadInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    int? line,
    String? path,
    String? pullRequestId,
    String? pullRequestReviewId,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
  }) =>
      _res;
}

class Input$AddReactionInput {
  factory Input$AddReactionInput({
    String? clientMutationId,
    required Enum$ReactionContent content,
    required String subjectId,
  }) =>
      Input$AddReactionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'content': content,
        r'subjectId': subjectId,
      });

  Input$AddReactionInput._(this._$data);

  factory Input$AddReactionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$content = data['content'];
    result$data['content'] =
        fromJson$Enum$ReactionContent((l$content as String));
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$AddReactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$ReactionContent get content =>
      (_$data['content'] as Enum$ReactionContent);
  String get subjectId => (_$data['subjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$content = content;
    result$data['content'] = toJson$Enum$ReactionContent(l$content);
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$AddReactionInput<Input$AddReactionInput> get copyWith =>
      CopyWith$Input$AddReactionInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddReactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$content = content;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$content,
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$AddReactionInput<TRes> {
  factory CopyWith$Input$AddReactionInput(
    Input$AddReactionInput instance,
    TRes Function(Input$AddReactionInput) then,
  ) = _CopyWithImpl$Input$AddReactionInput;

  factory CopyWith$Input$AddReactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddReactionInput;

  TRes call({
    String? clientMutationId,
    Enum$ReactionContent? content,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$AddReactionInput<TRes>
    implements CopyWith$Input$AddReactionInput<TRes> {
  _CopyWithImpl$Input$AddReactionInput(
    this._instance,
    this._then,
  );

  final Input$AddReactionInput _instance;

  final TRes Function(Input$AddReactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? content = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$AddReactionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (content != _undefined && content != null)
          'content': (content as Enum$ReactionContent),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$AddReactionInput<TRes>
    implements CopyWith$Input$AddReactionInput<TRes> {
  _CopyWithStubImpl$Input$AddReactionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$ReactionContent? content,
    String? subjectId,
  }) =>
      _res;
}

class Input$AddStarInput {
  factory Input$AddStarInput({
    String? clientMutationId,
    required String starrableId,
  }) =>
      Input$AddStarInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'starrableId': starrableId,
      });

  Input$AddStarInput._(this._$data);

  factory Input$AddStarInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$starrableId = data['starrableId'];
    result$data['starrableId'] = (l$starrableId as String);
    return Input$AddStarInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get starrableId => (_$data['starrableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$starrableId = starrableId;
    result$data['starrableId'] = l$starrableId;
    return result$data;
  }

  CopyWith$Input$AddStarInput<Input$AddStarInput> get copyWith =>
      CopyWith$Input$AddStarInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddStarInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$starrableId = starrableId;
    final lOther$starrableId = other.starrableId;
    if (l$starrableId != lOther$starrableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$starrableId = starrableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$starrableId,
    ]);
  }
}

abstract class CopyWith$Input$AddStarInput<TRes> {
  factory CopyWith$Input$AddStarInput(
    Input$AddStarInput instance,
    TRes Function(Input$AddStarInput) then,
  ) = _CopyWithImpl$Input$AddStarInput;

  factory CopyWith$Input$AddStarInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddStarInput;

  TRes call({
    String? clientMutationId,
    String? starrableId,
  });
}

class _CopyWithImpl$Input$AddStarInput<TRes>
    implements CopyWith$Input$AddStarInput<TRes> {
  _CopyWithImpl$Input$AddStarInput(
    this._instance,
    this._then,
  );

  final Input$AddStarInput _instance;

  final TRes Function(Input$AddStarInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? starrableId = _undefined,
  }) =>
      _then(Input$AddStarInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (starrableId != _undefined && starrableId != null)
          'starrableId': (starrableId as String),
      }));
}

class _CopyWithStubImpl$Input$AddStarInput<TRes>
    implements CopyWith$Input$AddStarInput<TRes> {
  _CopyWithStubImpl$Input$AddStarInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? starrableId,
  }) =>
      _res;
}

class Input$AddUpvoteInput {
  factory Input$AddUpvoteInput({
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$AddUpvoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$AddUpvoteInput._(this._$data);

  factory Input$AddUpvoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$AddUpvoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get subjectId => (_$data['subjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$AddUpvoteInput<Input$AddUpvoteInput> get copyWith =>
      CopyWith$Input$AddUpvoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddUpvoteInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$AddUpvoteInput<TRes> {
  factory CopyWith$Input$AddUpvoteInput(
    Input$AddUpvoteInput instance,
    TRes Function(Input$AddUpvoteInput) then,
  ) = _CopyWithImpl$Input$AddUpvoteInput;

  factory CopyWith$Input$AddUpvoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddUpvoteInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$AddUpvoteInput<TRes>
    implements CopyWith$Input$AddUpvoteInput<TRes> {
  _CopyWithImpl$Input$AddUpvoteInput(
    this._instance,
    this._then,
  );

  final Input$AddUpvoteInput _instance;

  final TRes Function(Input$AddUpvoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$AddUpvoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$AddUpvoteInput<TRes>
    implements CopyWith$Input$AddUpvoteInput<TRes> {
  _CopyWithStubImpl$Input$AddUpvoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$AddVerifiableDomainInput {
  factory Input$AddVerifiableDomainInput({
    String? clientMutationId,
    required String domain,
    required String ownerId,
  }) =>
      Input$AddVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'domain': domain,
        r'ownerId': ownerId,
      });

  Input$AddVerifiableDomainInput._(this._$data);

  factory Input$AddVerifiableDomainInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$domain = data['domain'];
    result$data['domain'] = (l$domain as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    return Input$AddVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get domain => (_$data['domain'] as String);
  String get ownerId => (_$data['ownerId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$domain = domain;
    result$data['domain'] = l$domain;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    return result$data;
  }

  CopyWith$Input$AddVerifiableDomainInput<Input$AddVerifiableDomainInput>
      get copyWith => CopyWith$Input$AddVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AddVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$domain = domain;
    final lOther$domain = other.domain;
    if (l$domain != lOther$domain) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$domain = domain;
    final l$ownerId = ownerId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$domain,
      l$ownerId,
    ]);
  }
}

abstract class CopyWith$Input$AddVerifiableDomainInput<TRes> {
  factory CopyWith$Input$AddVerifiableDomainInput(
    Input$AddVerifiableDomainInput instance,
    TRes Function(Input$AddVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$AddVerifiableDomainInput;

  factory CopyWith$Input$AddVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$AddVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? domain,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$AddVerifiableDomainInput<TRes>
    implements CopyWith$Input$AddVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$AddVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$AddVerifiableDomainInput _instance;

  final TRes Function(Input$AddVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? domain = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$AddVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (domain != _undefined && domain != null)
          'domain': (domain as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
      }));
}

class _CopyWithStubImpl$Input$AddVerifiableDomainInput<TRes>
    implements CopyWith$Input$AddVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$AddVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? domain,
    String? ownerId,
  }) =>
      _res;
}

class Input$ApproveDeploymentsInput {
  factory Input$ApproveDeploymentsInput({
    String? clientMutationId,
    String? comment,
    required List<String> environmentIds,
    required String workflowRunId,
  }) =>
      Input$ApproveDeploymentsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (comment != null) r'comment': comment,
        r'environmentIds': environmentIds,
        r'workflowRunId': workflowRunId,
      });

  Input$ApproveDeploymentsInput._(this._$data);

  factory Input$ApproveDeploymentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    final l$environmentIds = data['environmentIds'];
    result$data['environmentIds'] =
        (l$environmentIds as List<dynamic>).map((e) => (e as String)).toList();
    final l$workflowRunId = data['workflowRunId'];
    result$data['workflowRunId'] = (l$workflowRunId as String);
    return Input$ApproveDeploymentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get comment => (_$data['comment'] as String?);
  List<String> get environmentIds => (_$data['environmentIds'] as List<String>);
  String get workflowRunId => (_$data['workflowRunId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    final l$environmentIds = environmentIds;
    result$data['environmentIds'] = l$environmentIds.map((e) => e).toList();
    final l$workflowRunId = workflowRunId;
    result$data['workflowRunId'] = l$workflowRunId;
    return result$data;
  }

  CopyWith$Input$ApproveDeploymentsInput<Input$ApproveDeploymentsInput>
      get copyWith => CopyWith$Input$ApproveDeploymentsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApproveDeploymentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$environmentIds = environmentIds;
    final lOther$environmentIds = other.environmentIds;
    if (l$environmentIds.length != lOther$environmentIds.length) {
      return false;
    }
    for (int i = 0; i < l$environmentIds.length; i++) {
      final l$environmentIds$entry = l$environmentIds[i];
      final lOther$environmentIds$entry = lOther$environmentIds[i];
      if (l$environmentIds$entry != lOther$environmentIds$entry) {
        return false;
      }
    }
    final l$workflowRunId = workflowRunId;
    final lOther$workflowRunId = other.workflowRunId;
    if (l$workflowRunId != lOther$workflowRunId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$comment = comment;
    final l$environmentIds = environmentIds;
    final l$workflowRunId = workflowRunId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      Object.hashAll(l$environmentIds.map((v) => v)),
      l$workflowRunId,
    ]);
  }
}

abstract class CopyWith$Input$ApproveDeploymentsInput<TRes> {
  factory CopyWith$Input$ApproveDeploymentsInput(
    Input$ApproveDeploymentsInput instance,
    TRes Function(Input$ApproveDeploymentsInput) then,
  ) = _CopyWithImpl$Input$ApproveDeploymentsInput;

  factory CopyWith$Input$ApproveDeploymentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApproveDeploymentsInput;

  TRes call({
    String? clientMutationId,
    String? comment,
    List<String>? environmentIds,
    String? workflowRunId,
  });
}

class _CopyWithImpl$Input$ApproveDeploymentsInput<TRes>
    implements CopyWith$Input$ApproveDeploymentsInput<TRes> {
  _CopyWithImpl$Input$ApproveDeploymentsInput(
    this._instance,
    this._then,
  );

  final Input$ApproveDeploymentsInput _instance;

  final TRes Function(Input$ApproveDeploymentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? comment = _undefined,
    Object? environmentIds = _undefined,
    Object? workflowRunId = _undefined,
  }) =>
      _then(Input$ApproveDeploymentsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (environmentIds != _undefined && environmentIds != null)
          'environmentIds': (environmentIds as List<String>),
        if (workflowRunId != _undefined && workflowRunId != null)
          'workflowRunId': (workflowRunId as String),
      }));
}

class _CopyWithStubImpl$Input$ApproveDeploymentsInput<TRes>
    implements CopyWith$Input$ApproveDeploymentsInput<TRes> {
  _CopyWithStubImpl$Input$ApproveDeploymentsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? comment,
    List<String>? environmentIds,
    String? workflowRunId,
  }) =>
      _res;
}

class Input$ApproveVerifiableDomainInput {
  factory Input$ApproveVerifiableDomainInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$ApproveVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$ApproveVerifiableDomainInput._(this._$data);

  factory Input$ApproveVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$ApproveVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$ApproveVerifiableDomainInput<
          Input$ApproveVerifiableDomainInput>
      get copyWith => CopyWith$Input$ApproveVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ApproveVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  factory CopyWith$Input$ApproveVerifiableDomainInput(
    Input$ApproveVerifiableDomainInput instance,
    TRes Function(Input$ApproveVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$ApproveVerifiableDomainInput;

  factory CopyWith$Input$ApproveVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ApproveVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$ApproveVerifiableDomainInput<TRes>
    implements CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$ApproveVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$ApproveVerifiableDomainInput _instance;

  final TRes Function(Input$ApproveVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$ApproveVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$ApproveVerifiableDomainInput<TRes>
    implements CopyWith$Input$ApproveVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$ApproveVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$ArchiveProjectV2ItemInput {
  factory Input$ArchiveProjectV2ItemInput({
    String? clientMutationId,
    required String itemId,
    required String projectId,
  }) =>
      Input$ArchiveProjectV2ItemInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'itemId': itemId,
        r'projectId': projectId,
      });

  Input$ArchiveProjectV2ItemInput._(this._$data);

  factory Input$ArchiveProjectV2ItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$ArchiveProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get itemId => (_$data['itemId'] as String);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$ArchiveProjectV2ItemInput<Input$ArchiveProjectV2ItemInput>
      get copyWith => CopyWith$Input$ArchiveProjectV2ItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ArchiveProjectV2ItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$itemId = itemId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$itemId,
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  factory CopyWith$Input$ArchiveProjectV2ItemInput(
    Input$ArchiveProjectV2ItemInput instance,
    TRes Function(Input$ArchiveProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$ArchiveProjectV2ItemInput;

  factory CopyWith$Input$ArchiveProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput;

  TRes call({
    String? clientMutationId,
    String? itemId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$ArchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$ArchiveProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$ArchiveProjectV2ItemInput _instance;

  final TRes Function(Input$ArchiveProjectV2ItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? itemId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$ArchiveProjectV2ItemInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$ArchiveProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$ArchiveProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? itemId,
    String? projectId,
  }) =>
      _res;
}

class Input$ArchiveRepositoryInput {
  factory Input$ArchiveRepositoryInput({
    String? clientMutationId,
    required String repositoryId,
  }) =>
      Input$ArchiveRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
      });

  Input$ArchiveRepositoryInput._(this._$data);

  factory Input$ArchiveRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$ArchiveRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$ArchiveRepositoryInput<Input$ArchiveRepositoryInput>
      get copyWith => CopyWith$Input$ArchiveRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ArchiveRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$ArchiveRepositoryInput<TRes> {
  factory CopyWith$Input$ArchiveRepositoryInput(
    Input$ArchiveRepositoryInput instance,
    TRes Function(Input$ArchiveRepositoryInput) then,
  ) = _CopyWithImpl$Input$ArchiveRepositoryInput;

  factory CopyWith$Input$ArchiveRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ArchiveRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$ArchiveRepositoryInput<TRes>
    implements CopyWith$Input$ArchiveRepositoryInput<TRes> {
  _CopyWithImpl$Input$ArchiveRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$ArchiveRepositoryInput _instance;

  final TRes Function(Input$ArchiveRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$ArchiveRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$ArchiveRepositoryInput<TRes>
    implements CopyWith$Input$ArchiveRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$ArchiveRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$AuditLogOrder {
  factory Input$AuditLogOrder({
    Enum$OrderDirection? direction,
    Enum$AuditLogOrderField? field,
  }) =>
      Input$AuditLogOrder._({
        if (direction != null) r'direction': direction,
        if (field != null) r'field': field,
      });

  Input$AuditLogOrder._(this._$data);

  factory Input$AuditLogOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$AuditLogOrderField((l$field as String));
    }
    return Input$AuditLogOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Enum$AuditLogOrderField? get field =>
      (_$data['field'] as Enum$AuditLogOrderField?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$AuditLogOrderField(l$field);
    }
    return result$data;
  }

  CopyWith$Input$AuditLogOrder<Input$AuditLogOrder> get copyWith =>
      CopyWith$Input$AuditLogOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$AuditLogOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      _$data.containsKey('direction') ? l$direction : const {},
      _$data.containsKey('field') ? l$field : const {},
    ]);
  }
}

abstract class CopyWith$Input$AuditLogOrder<TRes> {
  factory CopyWith$Input$AuditLogOrder(
    Input$AuditLogOrder instance,
    TRes Function(Input$AuditLogOrder) then,
  ) = _CopyWithImpl$Input$AuditLogOrder;

  factory CopyWith$Input$AuditLogOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$AuditLogOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$AuditLogOrderField? field,
  });
}

class _CopyWithImpl$Input$AuditLogOrder<TRes>
    implements CopyWith$Input$AuditLogOrder<TRes> {
  _CopyWithImpl$Input$AuditLogOrder(
    this._instance,
    this._then,
  );

  final Input$AuditLogOrder _instance;

  final TRes Function(Input$AuditLogOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$AuditLogOrder._({
        ..._instance._$data,
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
        if (field != _undefined) 'field': (field as Enum$AuditLogOrderField?),
      }));
}

class _CopyWithStubImpl$Input$AuditLogOrder<TRes>
    implements CopyWith$Input$AuditLogOrder<TRes> {
  _CopyWithStubImpl$Input$AuditLogOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$AuditLogOrderField? field,
  }) =>
      _res;
}

class Input$CancelEnterpriseAdminInvitationInput {
  factory Input$CancelEnterpriseAdminInvitationInput({
    String? clientMutationId,
    required String invitationId,
  }) =>
      Input$CancelEnterpriseAdminInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'invitationId': invitationId,
      });

  Input$CancelEnterpriseAdminInvitationInput._(this._$data);

  factory Input$CancelEnterpriseAdminInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$invitationId = data['invitationId'];
    result$data['invitationId'] = (l$invitationId as String);
    return Input$CancelEnterpriseAdminInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get invitationId => (_$data['invitationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$invitationId = invitationId;
    result$data['invitationId'] = l$invitationId;
    return result$data;
  }

  CopyWith$Input$CancelEnterpriseAdminInvitationInput<
          Input$CancelEnterpriseAdminInvitationInput>
      get copyWith => CopyWith$Input$CancelEnterpriseAdminInvitationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CancelEnterpriseAdminInvitationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$invitationId = invitationId;
    final lOther$invitationId = other.invitationId;
    if (l$invitationId != lOther$invitationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$invitationId = invitationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$invitationId,
    ]);
  }
}

abstract class CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  factory CopyWith$Input$CancelEnterpriseAdminInvitationInput(
    Input$CancelEnterpriseAdminInvitationInput instance,
    TRes Function(Input$CancelEnterpriseAdminInvitationInput) then,
  ) = _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput;

  factory CopyWith$Input$CancelEnterpriseAdminInvitationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput;

  TRes call({
    String? clientMutationId,
    String? invitationId,
  });
}

class _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  _CopyWithImpl$Input$CancelEnterpriseAdminInvitationInput(
    this._instance,
    this._then,
  );

  final Input$CancelEnterpriseAdminInvitationInput _instance;

  final TRes Function(Input$CancelEnterpriseAdminInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? invitationId = _undefined,
  }) =>
      _then(Input$CancelEnterpriseAdminInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (invitationId != _undefined && invitationId != null)
          'invitationId': (invitationId as String),
      }));
}

class _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput<TRes>
    implements CopyWith$Input$CancelEnterpriseAdminInvitationInput<TRes> {
  _CopyWithStubImpl$Input$CancelEnterpriseAdminInvitationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? invitationId,
  }) =>
      _res;
}

class Input$CancelSponsorshipInput {
  factory Input$CancelSponsorshipInput({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  }) =>
      Input$CancelSponsorshipInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
      });

  Input$CancelSponsorshipInput._(this._$data);

  factory Input$CancelSponsorshipInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    return Input$CancelSponsorshipInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get sponsorId => (_$data['sponsorId'] as String?);
  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);
  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    return result$data;
  }

  CopyWith$Input$CancelSponsorshipInput<Input$CancelSponsorshipInput>
      get copyWith => CopyWith$Input$CancelSponsorshipInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CancelSponsorshipInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
    ]);
  }
}

abstract class CopyWith$Input$CancelSponsorshipInput<TRes> {
  factory CopyWith$Input$CancelSponsorshipInput(
    Input$CancelSponsorshipInput instance,
    TRes Function(Input$CancelSponsorshipInput) then,
  ) = _CopyWithImpl$Input$CancelSponsorshipInput;

  factory CopyWith$Input$CancelSponsorshipInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CancelSponsorshipInput;

  TRes call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  });
}

class _CopyWithImpl$Input$CancelSponsorshipInput<TRes>
    implements CopyWith$Input$CancelSponsorshipInput<TRes> {
  _CopyWithImpl$Input$CancelSponsorshipInput(
    this._instance,
    this._then,
  );

  final Input$CancelSponsorshipInput _instance;

  final TRes Function(Input$CancelSponsorshipInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
  }) =>
      _then(Input$CancelSponsorshipInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
      }));
}

class _CopyWithStubImpl$Input$CancelSponsorshipInput<TRes>
    implements CopyWith$Input$CancelSponsorshipInput<TRes> {
  _CopyWithStubImpl$Input$CancelSponsorshipInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  }) =>
      _res;
}

class Input$ChangeUserStatusInput {
  factory Input$ChangeUserStatusInput({
    String? clientMutationId,
    String? emoji,
    DateTime? expiresAt,
    bool? limitedAvailability,
    String? message,
    String? organizationId,
  }) =>
      Input$ChangeUserStatusInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (emoji != null) r'emoji': emoji,
        if (expiresAt != null) r'expiresAt': expiresAt,
        if (limitedAvailability != null)
          r'limitedAvailability': limitedAvailability,
        if (message != null) r'message': message,
        if (organizationId != null) r'organizationId': organizationId,
      });

  Input$ChangeUserStatusInput._(this._$data);

  factory Input$ChangeUserStatusInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('emoji')) {
      final l$emoji = data['emoji'];
      result$data['emoji'] = (l$emoji as String?);
    }
    if (data.containsKey('expiresAt')) {
      final l$expiresAt = data['expiresAt'];
      result$data['expiresAt'] =
          l$expiresAt == null ? null : DateTime.parse((l$expiresAt as String));
    }
    if (data.containsKey('limitedAvailability')) {
      final l$limitedAvailability = data['limitedAvailability'];
      result$data['limitedAvailability'] = (l$limitedAvailability as bool?);
    }
    if (data.containsKey('message')) {
      final l$message = data['message'];
      result$data['message'] = (l$message as String?);
    }
    if (data.containsKey('organizationId')) {
      final l$organizationId = data['organizationId'];
      result$data['organizationId'] = (l$organizationId as String?);
    }
    return Input$ChangeUserStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get emoji => (_$data['emoji'] as String?);
  DateTime? get expiresAt => (_$data['expiresAt'] as DateTime?);
  bool? get limitedAvailability => (_$data['limitedAvailability'] as bool?);
  String? get message => (_$data['message'] as String?);
  String? get organizationId => (_$data['organizationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('emoji')) {
      final l$emoji = emoji;
      result$data['emoji'] = l$emoji;
    }
    if (_$data.containsKey('expiresAt')) {
      final l$expiresAt = expiresAt;
      result$data['expiresAt'] = l$expiresAt?.toIso8601String();
    }
    if (_$data.containsKey('limitedAvailability')) {
      final l$limitedAvailability = limitedAvailability;
      result$data['limitedAvailability'] = l$limitedAvailability;
    }
    if (_$data.containsKey('message')) {
      final l$message = message;
      result$data['message'] = l$message;
    }
    if (_$data.containsKey('organizationId')) {
      final l$organizationId = organizationId;
      result$data['organizationId'] = l$organizationId;
    }
    return result$data;
  }

  CopyWith$Input$ChangeUserStatusInput<Input$ChangeUserStatusInput>
      get copyWith => CopyWith$Input$ChangeUserStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ChangeUserStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$emoji = emoji;
    final lOther$emoji = other.emoji;
    if (_$data.containsKey('emoji') != other._$data.containsKey('emoji')) {
      return false;
    }
    if (l$emoji != lOther$emoji) {
      return false;
    }
    final l$expiresAt = expiresAt;
    final lOther$expiresAt = other.expiresAt;
    if (_$data.containsKey('expiresAt') !=
        other._$data.containsKey('expiresAt')) {
      return false;
    }
    if (l$expiresAt != lOther$expiresAt) {
      return false;
    }
    final l$limitedAvailability = limitedAvailability;
    final lOther$limitedAvailability = other.limitedAvailability;
    if (_$data.containsKey('limitedAvailability') !=
        other._$data.containsKey('limitedAvailability')) {
      return false;
    }
    if (l$limitedAvailability != lOther$limitedAvailability) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (_$data.containsKey('message') != other._$data.containsKey('message')) {
      return false;
    }
    if (l$message != lOther$message) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (_$data.containsKey('organizationId') !=
        other._$data.containsKey('organizationId')) {
      return false;
    }
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$emoji = emoji;
    final l$expiresAt = expiresAt;
    final l$limitedAvailability = limitedAvailability;
    final l$message = message;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('emoji') ? l$emoji : const {},
      _$data.containsKey('expiresAt') ? l$expiresAt : const {},
      _$data.containsKey('limitedAvailability')
          ? l$limitedAvailability
          : const {},
      _$data.containsKey('message') ? l$message : const {},
      _$data.containsKey('organizationId') ? l$organizationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$ChangeUserStatusInput<TRes> {
  factory CopyWith$Input$ChangeUserStatusInput(
    Input$ChangeUserStatusInput instance,
    TRes Function(Input$ChangeUserStatusInput) then,
  ) = _CopyWithImpl$Input$ChangeUserStatusInput;

  factory CopyWith$Input$ChangeUserStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ChangeUserStatusInput;

  TRes call({
    String? clientMutationId,
    String? emoji,
    DateTime? expiresAt,
    bool? limitedAvailability,
    String? message,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$ChangeUserStatusInput<TRes>
    implements CopyWith$Input$ChangeUserStatusInput<TRes> {
  _CopyWithImpl$Input$ChangeUserStatusInput(
    this._instance,
    this._then,
  );

  final Input$ChangeUserStatusInput _instance;

  final TRes Function(Input$ChangeUserStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? emoji = _undefined,
    Object? expiresAt = _undefined,
    Object? limitedAvailability = _undefined,
    Object? message = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$ChangeUserStatusInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (emoji != _undefined) 'emoji': (emoji as String?),
        if (expiresAt != _undefined) 'expiresAt': (expiresAt as DateTime?),
        if (limitedAvailability != _undefined)
          'limitedAvailability': (limitedAvailability as bool?),
        if (message != _undefined) 'message': (message as String?),
        if (organizationId != _undefined)
          'organizationId': (organizationId as String?),
      }));
}

class _CopyWithStubImpl$Input$ChangeUserStatusInput<TRes>
    implements CopyWith$Input$ChangeUserStatusInput<TRes> {
  _CopyWithStubImpl$Input$ChangeUserStatusInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? emoji,
    DateTime? expiresAt,
    bool? limitedAvailability,
    String? message,
    String? organizationId,
  }) =>
      _res;
}

class Input$CheckAnnotationData {
  factory Input$CheckAnnotationData({
    required Enum$CheckAnnotationLevel annotationLevel,
    required Input$CheckAnnotationRange location,
    required String message,
    required String path,
    String? rawDetails,
    String? title,
  }) =>
      Input$CheckAnnotationData._({
        r'annotationLevel': annotationLevel,
        r'location': location,
        r'message': message,
        r'path': path,
        if (rawDetails != null) r'rawDetails': rawDetails,
        if (title != null) r'title': title,
      });

  Input$CheckAnnotationData._(this._$data);

  factory Input$CheckAnnotationData.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$annotationLevel = data['annotationLevel'];
    result$data['annotationLevel'] =
        fromJson$Enum$CheckAnnotationLevel((l$annotationLevel as String));
    final l$location = data['location'];
    result$data['location'] = Input$CheckAnnotationRange.fromJson(
        (l$location as Map<String, dynamic>));
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('rawDetails')) {
      final l$rawDetails = data['rawDetails'];
      result$data['rawDetails'] = (l$rawDetails as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$CheckAnnotationData._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$CheckAnnotationLevel get annotationLevel =>
      (_$data['annotationLevel'] as Enum$CheckAnnotationLevel);
  Input$CheckAnnotationRange get location =>
      (_$data['location'] as Input$CheckAnnotationRange);
  String get message => (_$data['message'] as String);
  String get path => (_$data['path'] as String);
  String? get rawDetails => (_$data['rawDetails'] as String?);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$annotationLevel = annotationLevel;
    result$data['annotationLevel'] =
        toJson$Enum$CheckAnnotationLevel(l$annotationLevel);
    final l$location = location;
    result$data['location'] = l$location.toJson();
    final l$message = message;
    result$data['message'] = l$message;
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('rawDetails')) {
      final l$rawDetails = rawDetails;
      result$data['rawDetails'] = l$rawDetails;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$CheckAnnotationData<Input$CheckAnnotationData> get copyWith =>
      CopyWith$Input$CheckAnnotationData(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckAnnotationData) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$annotationLevel = annotationLevel;
    final lOther$annotationLevel = other.annotationLevel;
    if (l$annotationLevel != lOther$annotationLevel) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (l$location != lOther$location) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$rawDetails = rawDetails;
    final lOther$rawDetails = other.rawDetails;
    if (_$data.containsKey('rawDetails') !=
        other._$data.containsKey('rawDetails')) {
      return false;
    }
    if (l$rawDetails != lOther$rawDetails) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$annotationLevel = annotationLevel;
    final l$location = location;
    final l$message = message;
    final l$path = path;
    final l$rawDetails = rawDetails;
    final l$title = title;
    return Object.hashAll([
      l$annotationLevel,
      l$location,
      l$message,
      l$path,
      _$data.containsKey('rawDetails') ? l$rawDetails : const {},
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckAnnotationData<TRes> {
  factory CopyWith$Input$CheckAnnotationData(
    Input$CheckAnnotationData instance,
    TRes Function(Input$CheckAnnotationData) then,
  ) = _CopyWithImpl$Input$CheckAnnotationData;

  factory CopyWith$Input$CheckAnnotationData.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckAnnotationData;

  TRes call({
    Enum$CheckAnnotationLevel? annotationLevel,
    Input$CheckAnnotationRange? location,
    String? message,
    String? path,
    String? rawDetails,
    String? title,
  });
  CopyWith$Input$CheckAnnotationRange<TRes> get location;
}

class _CopyWithImpl$Input$CheckAnnotationData<TRes>
    implements CopyWith$Input$CheckAnnotationData<TRes> {
  _CopyWithImpl$Input$CheckAnnotationData(
    this._instance,
    this._then,
  );

  final Input$CheckAnnotationData _instance;

  final TRes Function(Input$CheckAnnotationData) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? annotationLevel = _undefined,
    Object? location = _undefined,
    Object? message = _undefined,
    Object? path = _undefined,
    Object? rawDetails = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CheckAnnotationData._({
        ..._instance._$data,
        if (annotationLevel != _undefined && annotationLevel != null)
          'annotationLevel': (annotationLevel as Enum$CheckAnnotationLevel),
        if (location != _undefined && location != null)
          'location': (location as Input$CheckAnnotationRange),
        if (message != _undefined && message != null)
          'message': (message as String),
        if (path != _undefined && path != null) 'path': (path as String),
        if (rawDetails != _undefined) 'rawDetails': (rawDetails as String?),
        if (title != _undefined) 'title': (title as String?),
      }));
  CopyWith$Input$CheckAnnotationRange<TRes> get location {
    final local$location = _instance.location;
    return CopyWith$Input$CheckAnnotationRange(
        local$location, (e) => call(location: e));
  }
}

class _CopyWithStubImpl$Input$CheckAnnotationData<TRes>
    implements CopyWith$Input$CheckAnnotationData<TRes> {
  _CopyWithStubImpl$Input$CheckAnnotationData(this._res);

  TRes _res;

  call({
    Enum$CheckAnnotationLevel? annotationLevel,
    Input$CheckAnnotationRange? location,
    String? message,
    String? path,
    String? rawDetails,
    String? title,
  }) =>
      _res;
  CopyWith$Input$CheckAnnotationRange<TRes> get location =>
      CopyWith$Input$CheckAnnotationRange.stub(_res);
}

class Input$CheckAnnotationRange {
  factory Input$CheckAnnotationRange({
    int? endColumn,
    required int endLine,
    int? startColumn,
    required int startLine,
  }) =>
      Input$CheckAnnotationRange._({
        if (endColumn != null) r'endColumn': endColumn,
        r'endLine': endLine,
        if (startColumn != null) r'startColumn': startColumn,
        r'startLine': startLine,
      });

  Input$CheckAnnotationRange._(this._$data);

  factory Input$CheckAnnotationRange.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('endColumn')) {
      final l$endColumn = data['endColumn'];
      result$data['endColumn'] = (l$endColumn as int?);
    }
    final l$endLine = data['endLine'];
    result$data['endLine'] = (l$endLine as int);
    if (data.containsKey('startColumn')) {
      final l$startColumn = data['startColumn'];
      result$data['startColumn'] = (l$startColumn as int?);
    }
    final l$startLine = data['startLine'];
    result$data['startLine'] = (l$startLine as int);
    return Input$CheckAnnotationRange._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get endColumn => (_$data['endColumn'] as int?);
  int get endLine => (_$data['endLine'] as int);
  int? get startColumn => (_$data['startColumn'] as int?);
  int get startLine => (_$data['startLine'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('endColumn')) {
      final l$endColumn = endColumn;
      result$data['endColumn'] = l$endColumn;
    }
    final l$endLine = endLine;
    result$data['endLine'] = l$endLine;
    if (_$data.containsKey('startColumn')) {
      final l$startColumn = startColumn;
      result$data['startColumn'] = l$startColumn;
    }
    final l$startLine = startLine;
    result$data['startLine'] = l$startLine;
    return result$data;
  }

  CopyWith$Input$CheckAnnotationRange<Input$CheckAnnotationRange>
      get copyWith => CopyWith$Input$CheckAnnotationRange(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckAnnotationRange) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$endColumn = endColumn;
    final lOther$endColumn = other.endColumn;
    if (_$data.containsKey('endColumn') !=
        other._$data.containsKey('endColumn')) {
      return false;
    }
    if (l$endColumn != lOther$endColumn) {
      return false;
    }
    final l$endLine = endLine;
    final lOther$endLine = other.endLine;
    if (l$endLine != lOther$endLine) {
      return false;
    }
    final l$startColumn = startColumn;
    final lOther$startColumn = other.startColumn;
    if (_$data.containsKey('startColumn') !=
        other._$data.containsKey('startColumn')) {
      return false;
    }
    if (l$startColumn != lOther$startColumn) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (l$startLine != lOther$startLine) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$endColumn = endColumn;
    final l$endLine = endLine;
    final l$startColumn = startColumn;
    final l$startLine = startLine;
    return Object.hashAll([
      _$data.containsKey('endColumn') ? l$endColumn : const {},
      l$endLine,
      _$data.containsKey('startColumn') ? l$startColumn : const {},
      l$startLine,
    ]);
  }
}

abstract class CopyWith$Input$CheckAnnotationRange<TRes> {
  factory CopyWith$Input$CheckAnnotationRange(
    Input$CheckAnnotationRange instance,
    TRes Function(Input$CheckAnnotationRange) then,
  ) = _CopyWithImpl$Input$CheckAnnotationRange;

  factory CopyWith$Input$CheckAnnotationRange.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckAnnotationRange;

  TRes call({
    int? endColumn,
    int? endLine,
    int? startColumn,
    int? startLine,
  });
}

class _CopyWithImpl$Input$CheckAnnotationRange<TRes>
    implements CopyWith$Input$CheckAnnotationRange<TRes> {
  _CopyWithImpl$Input$CheckAnnotationRange(
    this._instance,
    this._then,
  );

  final Input$CheckAnnotationRange _instance;

  final TRes Function(Input$CheckAnnotationRange) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? endColumn = _undefined,
    Object? endLine = _undefined,
    Object? startColumn = _undefined,
    Object? startLine = _undefined,
  }) =>
      _then(Input$CheckAnnotationRange._({
        ..._instance._$data,
        if (endColumn != _undefined) 'endColumn': (endColumn as int?),
        if (endLine != _undefined && endLine != null)
          'endLine': (endLine as int),
        if (startColumn != _undefined) 'startColumn': (startColumn as int?),
        if (startLine != _undefined && startLine != null)
          'startLine': (startLine as int),
      }));
}

class _CopyWithStubImpl$Input$CheckAnnotationRange<TRes>
    implements CopyWith$Input$CheckAnnotationRange<TRes> {
  _CopyWithStubImpl$Input$CheckAnnotationRange(this._res);

  TRes _res;

  call({
    int? endColumn,
    int? endLine,
    int? startColumn,
    int? startLine,
  }) =>
      _res;
}

class Input$CheckRunAction {
  factory Input$CheckRunAction({
    required String description,
    required String identifier,
    required String label,
  }) =>
      Input$CheckRunAction._({
        r'description': description,
        r'identifier': identifier,
        r'label': label,
      });

  Input$CheckRunAction._(this._$data);

  factory Input$CheckRunAction.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$identifier = data['identifier'];
    result$data['identifier'] = (l$identifier as String);
    final l$label = data['label'];
    result$data['label'] = (l$label as String);
    return Input$CheckRunAction._(result$data);
  }

  Map<String, dynamic> _$data;

  String get description => (_$data['description'] as String);
  String get identifier => (_$data['identifier'] as String);
  String get label => (_$data['label'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$description = description;
    result$data['description'] = l$description;
    final l$identifier = identifier;
    result$data['identifier'] = l$identifier;
    final l$label = label;
    result$data['label'] = l$label;
    return result$data;
  }

  CopyWith$Input$CheckRunAction<Input$CheckRunAction> get copyWith =>
      CopyWith$Input$CheckRunAction(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunAction) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$identifier = identifier;
    final lOther$identifier = other.identifier;
    if (l$identifier != lOther$identifier) {
      return false;
    }
    final l$label = label;
    final lOther$label = other.label;
    if (l$label != lOther$label) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$description = description;
    final l$identifier = identifier;
    final l$label = label;
    return Object.hashAll([
      l$description,
      l$identifier,
      l$label,
    ]);
  }
}

abstract class CopyWith$Input$CheckRunAction<TRes> {
  factory CopyWith$Input$CheckRunAction(
    Input$CheckRunAction instance,
    TRes Function(Input$CheckRunAction) then,
  ) = _CopyWithImpl$Input$CheckRunAction;

  factory CopyWith$Input$CheckRunAction.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunAction;

  TRes call({
    String? description,
    String? identifier,
    String? label,
  });
}

class _CopyWithImpl$Input$CheckRunAction<TRes>
    implements CopyWith$Input$CheckRunAction<TRes> {
  _CopyWithImpl$Input$CheckRunAction(
    this._instance,
    this._then,
  );

  final Input$CheckRunAction _instance;

  final TRes Function(Input$CheckRunAction) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? description = _undefined,
    Object? identifier = _undefined,
    Object? label = _undefined,
  }) =>
      _then(Input$CheckRunAction._({
        ..._instance._$data,
        if (description != _undefined && description != null)
          'description': (description as String),
        if (identifier != _undefined && identifier != null)
          'identifier': (identifier as String),
        if (label != _undefined && label != null) 'label': (label as String),
      }));
}

class _CopyWithStubImpl$Input$CheckRunAction<TRes>
    implements CopyWith$Input$CheckRunAction<TRes> {
  _CopyWithStubImpl$Input$CheckRunAction(this._res);

  TRes _res;

  call({
    String? description,
    String? identifier,
    String? label,
  }) =>
      _res;
}

class Input$CheckRunFilter {
  factory Input$CheckRunFilter({
    int? appId,
    String? checkName,
    Enum$CheckRunType? checkType,
    List<Enum$CheckConclusionState>? conclusions,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
  }) =>
      Input$CheckRunFilter._({
        if (appId != null) r'appId': appId,
        if (checkName != null) r'checkName': checkName,
        if (checkType != null) r'checkType': checkType,
        if (conclusions != null) r'conclusions': conclusions,
        if (status != null) r'status': status,
        if (statuses != null) r'statuses': statuses,
      });

  Input$CheckRunFilter._(this._$data);

  factory Input$CheckRunFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as int?);
    }
    if (data.containsKey('checkName')) {
      final l$checkName = data['checkName'];
      result$data['checkName'] = (l$checkName as String?);
    }
    if (data.containsKey('checkType')) {
      final l$checkType = data['checkType'];
      result$data['checkType'] = l$checkType == null
          ? null
          : fromJson$Enum$CheckRunType((l$checkType as String));
    }
    if (data.containsKey('conclusions')) {
      final l$conclusions = data['conclusions'];
      result$data['conclusions'] = (l$conclusions as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckConclusionState((e as String)))
          .toList();
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$CheckStatusState((l$status as String));
    }
    if (data.containsKey('statuses')) {
      final l$statuses = data['statuses'];
      result$data['statuses'] = (l$statuses as List<dynamic>?)
          ?.map((e) => fromJson$Enum$CheckStatusState((e as String)))
          .toList();
    }
    return Input$CheckRunFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get appId => (_$data['appId'] as int?);
  String? get checkName => (_$data['checkName'] as String?);
  Enum$CheckRunType? get checkType =>
      (_$data['checkType'] as Enum$CheckRunType?);
  List<Enum$CheckConclusionState>? get conclusions =>
      (_$data['conclusions'] as List<Enum$CheckConclusionState>?);
  Enum$CheckStatusState? get status =>
      (_$data['status'] as Enum$CheckStatusState?);
  List<Enum$CheckStatusState>? get statuses =>
      (_$data['statuses'] as List<Enum$CheckStatusState>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    if (_$data.containsKey('checkName')) {
      final l$checkName = checkName;
      result$data['checkName'] = l$checkName;
    }
    if (_$data.containsKey('checkType')) {
      final l$checkType = checkType;
      result$data['checkType'] =
          l$checkType == null ? null : toJson$Enum$CheckRunType(l$checkType);
    }
    if (_$data.containsKey('conclusions')) {
      final l$conclusions = conclusions;
      result$data['conclusions'] = l$conclusions
          ?.map((e) => toJson$Enum$CheckConclusionState(e))
          .toList();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] =
          l$status == null ? null : toJson$Enum$CheckStatusState(l$status);
    }
    if (_$data.containsKey('statuses')) {
      final l$statuses = statuses;
      result$data['statuses'] =
          l$statuses?.map((e) => toJson$Enum$CheckStatusState(e)).toList();
    }
    return result$data;
  }

  CopyWith$Input$CheckRunFilter<Input$CheckRunFilter> get copyWith =>
      CopyWith$Input$CheckRunFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$checkName = checkName;
    final lOther$checkName = other.checkName;
    if (_$data.containsKey('checkName') !=
        other._$data.containsKey('checkName')) {
      return false;
    }
    if (l$checkName != lOther$checkName) {
      return false;
    }
    final l$checkType = checkType;
    final lOther$checkType = other.checkType;
    if (_$data.containsKey('checkType') !=
        other._$data.containsKey('checkType')) {
      return false;
    }
    if (l$checkType != lOther$checkType) {
      return false;
    }
    final l$conclusions = conclusions;
    final lOther$conclusions = other.conclusions;
    if (_$data.containsKey('conclusions') !=
        other._$data.containsKey('conclusions')) {
      return false;
    }
    if (l$conclusions != null && lOther$conclusions != null) {
      if (l$conclusions.length != lOther$conclusions.length) {
        return false;
      }
      for (int i = 0; i < l$conclusions.length; i++) {
        final l$conclusions$entry = l$conclusions[i];
        final lOther$conclusions$entry = lOther$conclusions[i];
        if (l$conclusions$entry != lOther$conclusions$entry) {
          return false;
        }
      }
    } else if (l$conclusions != lOther$conclusions) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$statuses = statuses;
    final lOther$statuses = other.statuses;
    if (_$data.containsKey('statuses') !=
        other._$data.containsKey('statuses')) {
      return false;
    }
    if (l$statuses != null && lOther$statuses != null) {
      if (l$statuses.length != lOther$statuses.length) {
        return false;
      }
      for (int i = 0; i < l$statuses.length; i++) {
        final l$statuses$entry = l$statuses[i];
        final lOther$statuses$entry = lOther$statuses[i];
        if (l$statuses$entry != lOther$statuses$entry) {
          return false;
        }
      }
    } else if (l$statuses != lOther$statuses) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$checkName = checkName;
    final l$checkType = checkType;
    final l$conclusions = conclusions;
    final l$status = status;
    final l$statuses = statuses;
    return Object.hashAll([
      _$data.containsKey('appId') ? l$appId : const {},
      _$data.containsKey('checkName') ? l$checkName : const {},
      _$data.containsKey('checkType') ? l$checkType : const {},
      _$data.containsKey('conclusions')
          ? l$conclusions == null
              ? null
              : Object.hashAll(l$conclusions.map((v) => v))
          : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('statuses')
          ? l$statuses == null
              ? null
              : Object.hashAll(l$statuses.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckRunFilter<TRes> {
  factory CopyWith$Input$CheckRunFilter(
    Input$CheckRunFilter instance,
    TRes Function(Input$CheckRunFilter) then,
  ) = _CopyWithImpl$Input$CheckRunFilter;

  factory CopyWith$Input$CheckRunFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunFilter;

  TRes call({
    int? appId,
    String? checkName,
    Enum$CheckRunType? checkType,
    List<Enum$CheckConclusionState>? conclusions,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
  });
}

class _CopyWithImpl$Input$CheckRunFilter<TRes>
    implements CopyWith$Input$CheckRunFilter<TRes> {
  _CopyWithImpl$Input$CheckRunFilter(
    this._instance,
    this._then,
  );

  final Input$CheckRunFilter _instance;

  final TRes Function(Input$CheckRunFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? appId = _undefined,
    Object? checkName = _undefined,
    Object? checkType = _undefined,
    Object? conclusions = _undefined,
    Object? status = _undefined,
    Object? statuses = _undefined,
  }) =>
      _then(Input$CheckRunFilter._({
        ..._instance._$data,
        if (appId != _undefined) 'appId': (appId as int?),
        if (checkName != _undefined) 'checkName': (checkName as String?),
        if (checkType != _undefined)
          'checkType': (checkType as Enum$CheckRunType?),
        if (conclusions != _undefined)
          'conclusions': (conclusions as List<Enum$CheckConclusionState>?),
        if (status != _undefined) 'status': (status as Enum$CheckStatusState?),
        if (statuses != _undefined)
          'statuses': (statuses as List<Enum$CheckStatusState>?),
      }));
}

class _CopyWithStubImpl$Input$CheckRunFilter<TRes>
    implements CopyWith$Input$CheckRunFilter<TRes> {
  _CopyWithStubImpl$Input$CheckRunFilter(this._res);

  TRes _res;

  call({
    int? appId,
    String? checkName,
    Enum$CheckRunType? checkType,
    List<Enum$CheckConclusionState>? conclusions,
    Enum$CheckStatusState? status,
    List<Enum$CheckStatusState>? statuses,
  }) =>
      _res;
}

class Input$CheckRunOutput {
  factory Input$CheckRunOutput({
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
    required String summary,
    String? text,
    required String title,
  }) =>
      Input$CheckRunOutput._({
        if (annotations != null) r'annotations': annotations,
        if (images != null) r'images': images,
        r'summary': summary,
        if (text != null) r'text': text,
        r'title': title,
      });

  Input$CheckRunOutput._(this._$data);

  factory Input$CheckRunOutput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('annotations')) {
      final l$annotations = data['annotations'];
      result$data['annotations'] = (l$annotations as List<dynamic>?)
          ?.map((e) =>
              Input$CheckAnnotationData.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('images')) {
      final l$images = data['images'];
      result$data['images'] = (l$images as List<dynamic>?)
          ?.map((e) =>
              Input$CheckRunOutputImage.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    final l$summary = data['summary'];
    result$data['summary'] = (l$summary as String);
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = (l$text as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$CheckRunOutput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CheckAnnotationData>? get annotations =>
      (_$data['annotations'] as List<Input$CheckAnnotationData>?);
  List<Input$CheckRunOutputImage>? get images =>
      (_$data['images'] as List<Input$CheckRunOutputImage>?);
  String get summary => (_$data['summary'] as String);
  String? get text => (_$data['text'] as String?);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('annotations')) {
      final l$annotations = annotations;
      result$data['annotations'] =
          l$annotations?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('images')) {
      final l$images = images;
      result$data['images'] = l$images?.map((e) => e.toJson()).toList();
    }
    final l$summary = summary;
    result$data['summary'] = l$summary;
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text;
    }
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$CheckRunOutput<Input$CheckRunOutput> get copyWith =>
      CopyWith$Input$CheckRunOutput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunOutput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$annotations = annotations;
    final lOther$annotations = other.annotations;
    if (_$data.containsKey('annotations') !=
        other._$data.containsKey('annotations')) {
      return false;
    }
    if (l$annotations != null && lOther$annotations != null) {
      if (l$annotations.length != lOther$annotations.length) {
        return false;
      }
      for (int i = 0; i < l$annotations.length; i++) {
        final l$annotations$entry = l$annotations[i];
        final lOther$annotations$entry = lOther$annotations[i];
        if (l$annotations$entry != lOther$annotations$entry) {
          return false;
        }
      }
    } else if (l$annotations != lOther$annotations) {
      return false;
    }
    final l$images = images;
    final lOther$images = other.images;
    if (_$data.containsKey('images') != other._$data.containsKey('images')) {
      return false;
    }
    if (l$images != null && lOther$images != null) {
      if (l$images.length != lOther$images.length) {
        return false;
      }
      for (int i = 0; i < l$images.length; i++) {
        final l$images$entry = l$images[i];
        final lOther$images$entry = lOther$images[i];
        if (l$images$entry != lOther$images$entry) {
          return false;
        }
      }
    } else if (l$images != lOther$images) {
      return false;
    }
    final l$summary = summary;
    final lOther$summary = other.summary;
    if (l$summary != lOther$summary) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$annotations = annotations;
    final l$images = images;
    final l$summary = summary;
    final l$text = text;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('annotations')
          ? l$annotations == null
              ? null
              : Object.hashAll(l$annotations.map((v) => v))
          : const {},
      _$data.containsKey('images')
          ? l$images == null
              ? null
              : Object.hashAll(l$images.map((v) => v))
          : const {},
      l$summary,
      _$data.containsKey('text') ? l$text : const {},
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$CheckRunOutput<TRes> {
  factory CopyWith$Input$CheckRunOutput(
    Input$CheckRunOutput instance,
    TRes Function(Input$CheckRunOutput) then,
  ) = _CopyWithImpl$Input$CheckRunOutput;

  factory CopyWith$Input$CheckRunOutput.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunOutput;

  TRes call({
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
    String? summary,
    String? text,
    String? title,
  });
  TRes annotations(
      Iterable<Input$CheckAnnotationData>? Function(
              Iterable<
                  CopyWith$Input$CheckAnnotationData<
                      Input$CheckAnnotationData>>?)
          _fn);
  TRes images(
      Iterable<Input$CheckRunOutputImage>? Function(
              Iterable<
                  CopyWith$Input$CheckRunOutputImage<
                      Input$CheckRunOutputImage>>?)
          _fn);
}

class _CopyWithImpl$Input$CheckRunOutput<TRes>
    implements CopyWith$Input$CheckRunOutput<TRes> {
  _CopyWithImpl$Input$CheckRunOutput(
    this._instance,
    this._then,
  );

  final Input$CheckRunOutput _instance;

  final TRes Function(Input$CheckRunOutput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? annotations = _undefined,
    Object? images = _undefined,
    Object? summary = _undefined,
    Object? text = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CheckRunOutput._({
        ..._instance._$data,
        if (annotations != _undefined)
          'annotations': (annotations as List<Input$CheckAnnotationData>?),
        if (images != _undefined)
          'images': (images as List<Input$CheckRunOutputImage>?),
        if (summary != _undefined && summary != null)
          'summary': (summary as String),
        if (text != _undefined) 'text': (text as String?),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
  TRes annotations(
          Iterable<Input$CheckAnnotationData>? Function(
                  Iterable<
                      CopyWith$Input$CheckAnnotationData<
                          Input$CheckAnnotationData>>?)
              _fn) =>
      call(
          annotations: _fn(_instance.annotations
              ?.map((e) => CopyWith$Input$CheckAnnotationData(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes images(
          Iterable<Input$CheckRunOutputImage>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunOutputImage<
                          Input$CheckRunOutputImage>>?)
              _fn) =>
      call(
          images: _fn(
              _instance.images?.map((e) => CopyWith$Input$CheckRunOutputImage(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CheckRunOutput<TRes>
    implements CopyWith$Input$CheckRunOutput<TRes> {
  _CopyWithStubImpl$Input$CheckRunOutput(this._res);

  TRes _res;

  call({
    List<Input$CheckAnnotationData>? annotations,
    List<Input$CheckRunOutputImage>? images,
    String? summary,
    String? text,
    String? title,
  }) =>
      _res;
  annotations(_fn) => _res;
  images(_fn) => _res;
}

class Input$CheckRunOutputImage {
  factory Input$CheckRunOutputImage({
    required String alt,
    String? caption,
    required String imageUrl,
  }) =>
      Input$CheckRunOutputImage._({
        r'alt': alt,
        if (caption != null) r'caption': caption,
        r'imageUrl': imageUrl,
      });

  Input$CheckRunOutputImage._(this._$data);

  factory Input$CheckRunOutputImage.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$alt = data['alt'];
    result$data['alt'] = (l$alt as String);
    if (data.containsKey('caption')) {
      final l$caption = data['caption'];
      result$data['caption'] = (l$caption as String?);
    }
    final l$imageUrl = data['imageUrl'];
    result$data['imageUrl'] = (l$imageUrl as String);
    return Input$CheckRunOutputImage._(result$data);
  }

  Map<String, dynamic> _$data;

  String get alt => (_$data['alt'] as String);
  String? get caption => (_$data['caption'] as String?);
  String get imageUrl => (_$data['imageUrl'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$alt = alt;
    result$data['alt'] = l$alt;
    if (_$data.containsKey('caption')) {
      final l$caption = caption;
      result$data['caption'] = l$caption;
    }
    final l$imageUrl = imageUrl;
    result$data['imageUrl'] = l$imageUrl;
    return result$data;
  }

  CopyWith$Input$CheckRunOutputImage<Input$CheckRunOutputImage> get copyWith =>
      CopyWith$Input$CheckRunOutputImage(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckRunOutputImage) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$alt = alt;
    final lOther$alt = other.alt;
    if (l$alt != lOther$alt) {
      return false;
    }
    final l$caption = caption;
    final lOther$caption = other.caption;
    if (_$data.containsKey('caption') != other._$data.containsKey('caption')) {
      return false;
    }
    if (l$caption != lOther$caption) {
      return false;
    }
    final l$imageUrl = imageUrl;
    final lOther$imageUrl = other.imageUrl;
    if (l$imageUrl != lOther$imageUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$alt = alt;
    final l$caption = caption;
    final l$imageUrl = imageUrl;
    return Object.hashAll([
      l$alt,
      _$data.containsKey('caption') ? l$caption : const {},
      l$imageUrl,
    ]);
  }
}

abstract class CopyWith$Input$CheckRunOutputImage<TRes> {
  factory CopyWith$Input$CheckRunOutputImage(
    Input$CheckRunOutputImage instance,
    TRes Function(Input$CheckRunOutputImage) then,
  ) = _CopyWithImpl$Input$CheckRunOutputImage;

  factory CopyWith$Input$CheckRunOutputImage.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckRunOutputImage;

  TRes call({
    String? alt,
    String? caption,
    String? imageUrl,
  });
}

class _CopyWithImpl$Input$CheckRunOutputImage<TRes>
    implements CopyWith$Input$CheckRunOutputImage<TRes> {
  _CopyWithImpl$Input$CheckRunOutputImage(
    this._instance,
    this._then,
  );

  final Input$CheckRunOutputImage _instance;

  final TRes Function(Input$CheckRunOutputImage) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? alt = _undefined,
    Object? caption = _undefined,
    Object? imageUrl = _undefined,
  }) =>
      _then(Input$CheckRunOutputImage._({
        ..._instance._$data,
        if (alt != _undefined && alt != null) 'alt': (alt as String),
        if (caption != _undefined) 'caption': (caption as String?),
        if (imageUrl != _undefined && imageUrl != null)
          'imageUrl': (imageUrl as String),
      }));
}

class _CopyWithStubImpl$Input$CheckRunOutputImage<TRes>
    implements CopyWith$Input$CheckRunOutputImage<TRes> {
  _CopyWithStubImpl$Input$CheckRunOutputImage(this._res);

  TRes _res;

  call({
    String? alt,
    String? caption,
    String? imageUrl,
  }) =>
      _res;
}

class Input$CheckSuiteAutoTriggerPreference {
  factory Input$CheckSuiteAutoTriggerPreference({
    required String appId,
    required bool setting,
  }) =>
      Input$CheckSuiteAutoTriggerPreference._({
        r'appId': appId,
        r'setting': setting,
      });

  Input$CheckSuiteAutoTriggerPreference._(this._$data);

  factory Input$CheckSuiteAutoTriggerPreference.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$appId = data['appId'];
    result$data['appId'] = (l$appId as String);
    final l$setting = data['setting'];
    result$data['setting'] = (l$setting as bool);
    return Input$CheckSuiteAutoTriggerPreference._(result$data);
  }

  Map<String, dynamic> _$data;

  String get appId => (_$data['appId'] as String);
  bool get setting => (_$data['setting'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$appId = appId;
    result$data['appId'] = l$appId;
    final l$setting = setting;
    result$data['setting'] = l$setting;
    return result$data;
  }

  CopyWith$Input$CheckSuiteAutoTriggerPreference<
          Input$CheckSuiteAutoTriggerPreference>
      get copyWith => CopyWith$Input$CheckSuiteAutoTriggerPreference(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckSuiteAutoTriggerPreference) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$setting = setting;
    final lOther$setting = other.setting;
    if (l$setting != lOther$setting) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$setting = setting;
    return Object.hashAll([
      l$appId,
      l$setting,
    ]);
  }
}

abstract class CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  factory CopyWith$Input$CheckSuiteAutoTriggerPreference(
    Input$CheckSuiteAutoTriggerPreference instance,
    TRes Function(Input$CheckSuiteAutoTriggerPreference) then,
  ) = _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference;

  factory CopyWith$Input$CheckSuiteAutoTriggerPreference.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference;

  TRes call({
    String? appId,
    bool? setting,
  });
}

class _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference<TRes>
    implements CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  _CopyWithImpl$Input$CheckSuiteAutoTriggerPreference(
    this._instance,
    this._then,
  );

  final Input$CheckSuiteAutoTriggerPreference _instance;

  final TRes Function(Input$CheckSuiteAutoTriggerPreference) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? appId = _undefined,
    Object? setting = _undefined,
  }) =>
      _then(Input$CheckSuiteAutoTriggerPreference._({
        ..._instance._$data,
        if (appId != _undefined && appId != null) 'appId': (appId as String),
        if (setting != _undefined && setting != null)
          'setting': (setting as bool),
      }));
}

class _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference<TRes>
    implements CopyWith$Input$CheckSuiteAutoTriggerPreference<TRes> {
  _CopyWithStubImpl$Input$CheckSuiteAutoTriggerPreference(this._res);

  TRes _res;

  call({
    String? appId,
    bool? setting,
  }) =>
      _res;
}

class Input$CheckSuiteFilter {
  factory Input$CheckSuiteFilter({
    int? appId,
    String? checkName,
  }) =>
      Input$CheckSuiteFilter._({
        if (appId != null) r'appId': appId,
        if (checkName != null) r'checkName': checkName,
      });

  Input$CheckSuiteFilter._(this._$data);

  factory Input$CheckSuiteFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as int?);
    }
    if (data.containsKey('checkName')) {
      final l$checkName = data['checkName'];
      result$data['checkName'] = (l$checkName as String?);
    }
    return Input$CheckSuiteFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get appId => (_$data['appId'] as int?);
  String? get checkName => (_$data['checkName'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    if (_$data.containsKey('checkName')) {
      final l$checkName = checkName;
      result$data['checkName'] = l$checkName;
    }
    return result$data;
  }

  CopyWith$Input$CheckSuiteFilter<Input$CheckSuiteFilter> get copyWith =>
      CopyWith$Input$CheckSuiteFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CheckSuiteFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$checkName = checkName;
    final lOther$checkName = other.checkName;
    if (_$data.containsKey('checkName') !=
        other._$data.containsKey('checkName')) {
      return false;
    }
    if (l$checkName != lOther$checkName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$checkName = checkName;
    return Object.hashAll([
      _$data.containsKey('appId') ? l$appId : const {},
      _$data.containsKey('checkName') ? l$checkName : const {},
    ]);
  }
}

abstract class CopyWith$Input$CheckSuiteFilter<TRes> {
  factory CopyWith$Input$CheckSuiteFilter(
    Input$CheckSuiteFilter instance,
    TRes Function(Input$CheckSuiteFilter) then,
  ) = _CopyWithImpl$Input$CheckSuiteFilter;

  factory CopyWith$Input$CheckSuiteFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CheckSuiteFilter;

  TRes call({
    int? appId,
    String? checkName,
  });
}

class _CopyWithImpl$Input$CheckSuiteFilter<TRes>
    implements CopyWith$Input$CheckSuiteFilter<TRes> {
  _CopyWithImpl$Input$CheckSuiteFilter(
    this._instance,
    this._then,
  );

  final Input$CheckSuiteFilter _instance;

  final TRes Function(Input$CheckSuiteFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? appId = _undefined,
    Object? checkName = _undefined,
  }) =>
      _then(Input$CheckSuiteFilter._({
        ..._instance._$data,
        if (appId != _undefined) 'appId': (appId as int?),
        if (checkName != _undefined) 'checkName': (checkName as String?),
      }));
}

class _CopyWithStubImpl$Input$CheckSuiteFilter<TRes>
    implements CopyWith$Input$CheckSuiteFilter<TRes> {
  _CopyWithStubImpl$Input$CheckSuiteFilter(this._res);

  TRes _res;

  call({
    int? appId,
    String? checkName,
  }) =>
      _res;
}

class Input$ClearLabelsFromLabelableInput {
  factory Input$ClearLabelsFromLabelableInput({
    String? clientMutationId,
    required String labelableId,
  }) =>
      Input$ClearLabelsFromLabelableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'labelableId': labelableId,
      });

  Input$ClearLabelsFromLabelableInput._(this._$data);

  factory Input$ClearLabelsFromLabelableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    return Input$ClearLabelsFromLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get labelableId => (_$data['labelableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    return result$data;
  }

  CopyWith$Input$ClearLabelsFromLabelableInput<
          Input$ClearLabelsFromLabelableInput>
      get copyWith => CopyWith$Input$ClearLabelsFromLabelableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClearLabelsFromLabelableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$labelableId = labelableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$labelableId,
    ]);
  }
}

abstract class CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  factory CopyWith$Input$ClearLabelsFromLabelableInput(
    Input$ClearLabelsFromLabelableInput instance,
    TRes Function(Input$ClearLabelsFromLabelableInput) then,
  ) = _CopyWithImpl$Input$ClearLabelsFromLabelableInput;

  factory CopyWith$Input$ClearLabelsFromLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput;

  TRes call({
    String? clientMutationId,
    String? labelableId,
  });
}

class _CopyWithImpl$Input$ClearLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  _CopyWithImpl$Input$ClearLabelsFromLabelableInput(
    this._instance,
    this._then,
  );

  final Input$ClearLabelsFromLabelableInput _instance;

  final TRes Function(Input$ClearLabelsFromLabelableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? labelableId = _undefined,
  }) =>
      _then(Input$ClearLabelsFromLabelableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
      }));
}

class _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$ClearLabelsFromLabelableInput<TRes> {
  _CopyWithStubImpl$Input$ClearLabelsFromLabelableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? labelableId,
  }) =>
      _res;
}

class Input$ClearProjectV2ItemFieldValueInput {
  factory Input$ClearProjectV2ItemFieldValueInput({
    String? clientMutationId,
    required String fieldId,
    required String itemId,
    required String projectId,
  }) =>
      Input$ClearProjectV2ItemFieldValueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fieldId': fieldId,
        r'itemId': itemId,
        r'projectId': projectId,
      });

  Input$ClearProjectV2ItemFieldValueInput._(this._$data);

  factory Input$ClearProjectV2ItemFieldValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$ClearProjectV2ItemFieldValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fieldId => (_$data['fieldId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$ClearProjectV2ItemFieldValueInput<
          Input$ClearProjectV2ItemFieldValueInput>
      get copyWith => CopyWith$Input$ClearProjectV2ItemFieldValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClearProjectV2ItemFieldValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fieldId = fieldId;
    final l$itemId = itemId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fieldId,
      l$itemId,
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  factory CopyWith$Input$ClearProjectV2ItemFieldValueInput(
    Input$ClearProjectV2ItemFieldValueInput instance,
    TRes Function(Input$ClearProjectV2ItemFieldValueInput) then,
  ) = _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput;

  factory CopyWith$Input$ClearProjectV2ItemFieldValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput;

  TRes call({
    String? clientMutationId,
    String? fieldId,
    String? itemId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  _CopyWithImpl$Input$ClearProjectV2ItemFieldValueInput(
    this._instance,
    this._then,
  );

  final Input$ClearProjectV2ItemFieldValueInput _instance;

  final TRes Function(Input$ClearProjectV2ItemFieldValueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fieldId = _undefined,
    Object? itemId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$ClearProjectV2ItemFieldValueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$ClearProjectV2ItemFieldValueInput<TRes> {
  _CopyWithStubImpl$Input$ClearProjectV2ItemFieldValueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fieldId,
    String? itemId,
    String? projectId,
  }) =>
      _res;
}

class Input$CloneProjectInput {
  factory Input$CloneProjectInput({
    String? body,
    String? clientMutationId,
    required bool includeWorkflows,
    required String name,
    bool? public,
    required String sourceId,
    required String targetOwnerId,
  }) =>
      Input$CloneProjectInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'includeWorkflows': includeWorkflows,
        r'name': name,
        if (public != null) r'public': public,
        r'sourceId': sourceId,
        r'targetOwnerId': targetOwnerId,
      });

  Input$CloneProjectInput._(this._$data);

  factory Input$CloneProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$includeWorkflows = data['includeWorkflows'];
    result$data['includeWorkflows'] = (l$includeWorkflows as bool);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$targetOwnerId = data['targetOwnerId'];
    result$data['targetOwnerId'] = (l$targetOwnerId as String);
    return Input$CloneProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get includeWorkflows => (_$data['includeWorkflows'] as bool);
  String get name => (_$data['name'] as String);
  bool? get public => (_$data['public'] as bool?);
  String get sourceId => (_$data['sourceId'] as String);
  String get targetOwnerId => (_$data['targetOwnerId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$includeWorkflows = includeWorkflows;
    result$data['includeWorkflows'] = l$includeWorkflows;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$targetOwnerId = targetOwnerId;
    result$data['targetOwnerId'] = l$targetOwnerId;
    return result$data;
  }

  CopyWith$Input$CloneProjectInput<Input$CloneProjectInput> get copyWith =>
      CopyWith$Input$CloneProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CloneProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$includeWorkflows = includeWorkflows;
    final lOther$includeWorkflows = other.includeWorkflows;
    if (l$includeWorkflows != lOther$includeWorkflows) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$targetOwnerId = targetOwnerId;
    final lOther$targetOwnerId = other.targetOwnerId;
    if (l$targetOwnerId != lOther$targetOwnerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$includeWorkflows = includeWorkflows;
    final l$name = name;
    final l$public = public;
    final l$sourceId = sourceId;
    final l$targetOwnerId = targetOwnerId;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$includeWorkflows,
      l$name,
      _$data.containsKey('public') ? l$public : const {},
      l$sourceId,
      l$targetOwnerId,
    ]);
  }
}

abstract class CopyWith$Input$CloneProjectInput<TRes> {
  factory CopyWith$Input$CloneProjectInput(
    Input$CloneProjectInput instance,
    TRes Function(Input$CloneProjectInput) then,
  ) = _CopyWithImpl$Input$CloneProjectInput;

  factory CopyWith$Input$CloneProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloneProjectInput;

  TRes call({
    String? body,
    String? clientMutationId,
    bool? includeWorkflows,
    String? name,
    bool? public,
    String? sourceId,
    String? targetOwnerId,
  });
}

class _CopyWithImpl$Input$CloneProjectInput<TRes>
    implements CopyWith$Input$CloneProjectInput<TRes> {
  _CopyWithImpl$Input$CloneProjectInput(
    this._instance,
    this._then,
  );

  final Input$CloneProjectInput _instance;

  final TRes Function(Input$CloneProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? includeWorkflows = _undefined,
    Object? name = _undefined,
    Object? public = _undefined,
    Object? sourceId = _undefined,
    Object? targetOwnerId = _undefined,
  }) =>
      _then(Input$CloneProjectInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (includeWorkflows != _undefined && includeWorkflows != null)
          'includeWorkflows': (includeWorkflows as bool),
        if (name != _undefined && name != null) 'name': (name as String),
        if (public != _undefined) 'public': (public as bool?),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (targetOwnerId != _undefined && targetOwnerId != null)
          'targetOwnerId': (targetOwnerId as String),
      }));
}

class _CopyWithStubImpl$Input$CloneProjectInput<TRes>
    implements CopyWith$Input$CloneProjectInput<TRes> {
  _CopyWithStubImpl$Input$CloneProjectInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    bool? includeWorkflows,
    String? name,
    bool? public,
    String? sourceId,
    String? targetOwnerId,
  }) =>
      _res;
}

class Input$CloneTemplateRepositoryInput {
  factory Input$CloneTemplateRepositoryInput({
    String? clientMutationId,
    String? description,
    bool? includeAllBranches,
    required String name,
    required String ownerId,
    required String repositoryId,
    required Enum$RepositoryVisibility visibility,
  }) =>
      Input$CloneTemplateRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (description != null) r'description': description,
        if (includeAllBranches != null)
          r'includeAllBranches': includeAllBranches,
        r'name': name,
        r'ownerId': ownerId,
        r'repositoryId': repositoryId,
        r'visibility': visibility,
      });

  Input$CloneTemplateRepositoryInput._(this._$data);

  factory Input$CloneTemplateRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('includeAllBranches')) {
      final l$includeAllBranches = data['includeAllBranches'];
      result$data['includeAllBranches'] = (l$includeAllBranches as bool?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$visibility = data['visibility'];
    result$data['visibility'] =
        fromJson$Enum$RepositoryVisibility((l$visibility as String));
    return Input$CloneTemplateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get description => (_$data['description'] as String?);
  bool? get includeAllBranches => (_$data['includeAllBranches'] as bool?);
  String get name => (_$data['name'] as String);
  String get ownerId => (_$data['ownerId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Enum$RepositoryVisibility get visibility =>
      (_$data['visibility'] as Enum$RepositoryVisibility);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('includeAllBranches')) {
      final l$includeAllBranches = includeAllBranches;
      result$data['includeAllBranches'] = l$includeAllBranches;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$visibility = visibility;
    result$data['visibility'] = toJson$Enum$RepositoryVisibility(l$visibility);
    return result$data;
  }

  CopyWith$Input$CloneTemplateRepositoryInput<
          Input$CloneTemplateRepositoryInput>
      get copyWith => CopyWith$Input$CloneTemplateRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CloneTemplateRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$includeAllBranches = includeAllBranches;
    final lOther$includeAllBranches = other.includeAllBranches;
    if (_$data.containsKey('includeAllBranches') !=
        other._$data.containsKey('includeAllBranches')) {
      return false;
    }
    if (l$includeAllBranches != lOther$includeAllBranches) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$visibility = visibility;
    final lOther$visibility = other.visibility;
    if (l$visibility != lOther$visibility) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$includeAllBranches = includeAllBranches;
    final l$name = name;
    final l$ownerId = ownerId;
    final l$repositoryId = repositoryId;
    final l$visibility = visibility;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('includeAllBranches')
          ? l$includeAllBranches
          : const {},
      l$name,
      l$ownerId,
      l$repositoryId,
      l$visibility,
    ]);
  }
}

abstract class CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  factory CopyWith$Input$CloneTemplateRepositoryInput(
    Input$CloneTemplateRepositoryInput instance,
    TRes Function(Input$CloneTemplateRepositoryInput) then,
  ) = _CopyWithImpl$Input$CloneTemplateRepositoryInput;

  factory CopyWith$Input$CloneTemplateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloneTemplateRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? description,
    bool? includeAllBranches,
    String? name,
    String? ownerId,
    String? repositoryId,
    Enum$RepositoryVisibility? visibility,
  });
}

class _CopyWithImpl$Input$CloneTemplateRepositoryInput<TRes>
    implements CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  _CopyWithImpl$Input$CloneTemplateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$CloneTemplateRepositoryInput _instance;

  final TRes Function(Input$CloneTemplateRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? includeAllBranches = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? repositoryId = _undefined,
    Object? visibility = _undefined,
  }) =>
      _then(Input$CloneTemplateRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (includeAllBranches != _undefined)
          'includeAllBranches': (includeAllBranches as bool?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (visibility != _undefined && visibility != null)
          'visibility': (visibility as Enum$RepositoryVisibility),
      }));
}

class _CopyWithStubImpl$Input$CloneTemplateRepositoryInput<TRes>
    implements CopyWith$Input$CloneTemplateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$CloneTemplateRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? description,
    bool? includeAllBranches,
    String? name,
    String? ownerId,
    String? repositoryId,
    Enum$RepositoryVisibility? visibility,
  }) =>
      _res;
}

class Input$CloseDiscussionInput {
  factory Input$CloseDiscussionInput({
    String? clientMutationId,
    required String discussionId,
    Enum$DiscussionCloseReason? reason,
  }) =>
      Input$CloseDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
        if (reason != null) r'reason': reason,
      });

  Input$CloseDiscussionInput._(this._$data);

  factory Input$CloseDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('reason')) {
      final l$reason = data['reason'];
      result$data['reason'] = l$reason == null
          ? null
          : fromJson$Enum$DiscussionCloseReason((l$reason as String));
    }
    return Input$CloseDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get discussionId => (_$data['discussionId'] as String);
  Enum$DiscussionCloseReason? get reason =>
      (_$data['reason'] as Enum$DiscussionCloseReason?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('reason')) {
      final l$reason = reason;
      result$data['reason'] =
          l$reason == null ? null : toJson$Enum$DiscussionCloseReason(l$reason);
    }
    return result$data;
  }

  CopyWith$Input$CloseDiscussionInput<Input$CloseDiscussionInput>
      get copyWith => CopyWith$Input$CloseDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CloseDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (_$data.containsKey('reason') != other._$data.containsKey('reason')) {
      return false;
    }
    if (l$reason != lOther$reason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$reason = reason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
      _$data.containsKey('reason') ? l$reason : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloseDiscussionInput<TRes> {
  factory CopyWith$Input$CloseDiscussionInput(
    Input$CloseDiscussionInput instance,
    TRes Function(Input$CloseDiscussionInput) then,
  ) = _CopyWithImpl$Input$CloseDiscussionInput;

  factory CopyWith$Input$CloseDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloseDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? discussionId,
    Enum$DiscussionCloseReason? reason,
  });
}

class _CopyWithImpl$Input$CloseDiscussionInput<TRes>
    implements CopyWith$Input$CloseDiscussionInput<TRes> {
  _CopyWithImpl$Input$CloseDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CloseDiscussionInput _instance;

  final TRes Function(Input$CloseDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? reason = _undefined,
  }) =>
      _then(Input$CloseDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (reason != _undefined)
          'reason': (reason as Enum$DiscussionCloseReason?),
      }));
}

class _CopyWithStubImpl$Input$CloseDiscussionInput<TRes>
    implements CopyWith$Input$CloseDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CloseDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? discussionId,
    Enum$DiscussionCloseReason? reason,
  }) =>
      _res;
}

class Input$CloseIssueInput {
  factory Input$CloseIssueInput({
    String? clientMutationId,
    required String issueId,
    Enum$IssueClosedStateReason? stateReason,
  }) =>
      Input$CloseIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        if (stateReason != null) r'stateReason': stateReason,
      });

  Input$CloseIssueInput._(this._$data);

  factory Input$CloseIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('stateReason')) {
      final l$stateReason = data['stateReason'];
      result$data['stateReason'] = l$stateReason == null
          ? null
          : fromJson$Enum$IssueClosedStateReason((l$stateReason as String));
    }
    return Input$CloseIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get issueId => (_$data['issueId'] as String);
  Enum$IssueClosedStateReason? get stateReason =>
      (_$data['stateReason'] as Enum$IssueClosedStateReason?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('stateReason')) {
      final l$stateReason = stateReason;
      result$data['stateReason'] = l$stateReason == null
          ? null
          : toJson$Enum$IssueClosedStateReason(l$stateReason);
    }
    return result$data;
  }

  CopyWith$Input$CloseIssueInput<Input$CloseIssueInput> get copyWith =>
      CopyWith$Input$CloseIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CloseIssueInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$stateReason = stateReason;
    final lOther$stateReason = other.stateReason;
    if (_$data.containsKey('stateReason') !=
        other._$data.containsKey('stateReason')) {
      return false;
    }
    if (l$stateReason != lOther$stateReason) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$stateReason = stateReason;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      _$data.containsKey('stateReason') ? l$stateReason : const {},
    ]);
  }
}

abstract class CopyWith$Input$CloseIssueInput<TRes> {
  factory CopyWith$Input$CloseIssueInput(
    Input$CloseIssueInput instance,
    TRes Function(Input$CloseIssueInput) then,
  ) = _CopyWithImpl$Input$CloseIssueInput;

  factory CopyWith$Input$CloseIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CloseIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    Enum$IssueClosedStateReason? stateReason,
  });
}

class _CopyWithImpl$Input$CloseIssueInput<TRes>
    implements CopyWith$Input$CloseIssueInput<TRes> {
  _CopyWithImpl$Input$CloseIssueInput(
    this._instance,
    this._then,
  );

  final Input$CloseIssueInput _instance;

  final TRes Function(Input$CloseIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? stateReason = _undefined,
  }) =>
      _then(Input$CloseIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (stateReason != _undefined)
          'stateReason': (stateReason as Enum$IssueClosedStateReason?),
      }));
}

class _CopyWithStubImpl$Input$CloseIssueInput<TRes>
    implements CopyWith$Input$CloseIssueInput<TRes> {
  _CopyWithStubImpl$Input$CloseIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    Enum$IssueClosedStateReason? stateReason,
  }) =>
      _res;
}

class Input$ClosePullRequestInput {
  factory Input$ClosePullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$ClosePullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$ClosePullRequestInput._(this._$data);

  factory Input$ClosePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$ClosePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$ClosePullRequestInput<Input$ClosePullRequestInput>
      get copyWith => CopyWith$Input$ClosePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ClosePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$ClosePullRequestInput<TRes> {
  factory CopyWith$Input$ClosePullRequestInput(
    Input$ClosePullRequestInput instance,
    TRes Function(Input$ClosePullRequestInput) then,
  ) = _CopyWithImpl$Input$ClosePullRequestInput;

  factory CopyWith$Input$ClosePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ClosePullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$ClosePullRequestInput<TRes>
    implements CopyWith$Input$ClosePullRequestInput<TRes> {
  _CopyWithImpl$Input$ClosePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$ClosePullRequestInput _instance;

  final TRes Function(Input$ClosePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$ClosePullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$ClosePullRequestInput<TRes>
    implements CopyWith$Input$ClosePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$ClosePullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$CommitAuthor {
  factory Input$CommitAuthor({
    List<String>? emails,
    String? id,
  }) =>
      Input$CommitAuthor._({
        if (emails != null) r'emails': emails,
        if (id != null) r'id': id,
      });

  Input$CommitAuthor._(this._$data);

  factory Input$CommitAuthor.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('emails')) {
      final l$emails = data['emails'];
      result$data['emails'] =
          (l$emails as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    return Input$CommitAuthor._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get emails => (_$data['emails'] as List<String>?);
  String? get id => (_$data['id'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('emails')) {
      final l$emails = emails;
      result$data['emails'] = l$emails?.map((e) => e).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$CommitAuthor<Input$CommitAuthor> get copyWith =>
      CopyWith$Input$CommitAuthor(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitAuthor) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$emails = emails;
    final lOther$emails = other.emails;
    if (_$data.containsKey('emails') != other._$data.containsKey('emails')) {
      return false;
    }
    if (l$emails != null && lOther$emails != null) {
      if (l$emails.length != lOther$emails.length) {
        return false;
      }
      for (int i = 0; i < l$emails.length; i++) {
        final l$emails$entry = l$emails[i];
        final lOther$emails$entry = lOther$emails[i];
        if (l$emails$entry != lOther$emails$entry) {
          return false;
        }
      }
    } else if (l$emails != lOther$emails) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$emails = emails;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('emails')
          ? l$emails == null
              ? null
              : Object.hashAll(l$emails.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommitAuthor<TRes> {
  factory CopyWith$Input$CommitAuthor(
    Input$CommitAuthor instance,
    TRes Function(Input$CommitAuthor) then,
  ) = _CopyWithImpl$Input$CommitAuthor;

  factory CopyWith$Input$CommitAuthor.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitAuthor;

  TRes call({
    List<String>? emails,
    String? id,
  });
}

class _CopyWithImpl$Input$CommitAuthor<TRes>
    implements CopyWith$Input$CommitAuthor<TRes> {
  _CopyWithImpl$Input$CommitAuthor(
    this._instance,
    this._then,
  );

  final Input$CommitAuthor _instance;

  final TRes Function(Input$CommitAuthor) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? emails = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$CommitAuthor._({
        ..._instance._$data,
        if (emails != _undefined) 'emails': (emails as List<String>?),
        if (id != _undefined) 'id': (id as String?),
      }));
}

class _CopyWithStubImpl$Input$CommitAuthor<TRes>
    implements CopyWith$Input$CommitAuthor<TRes> {
  _CopyWithStubImpl$Input$CommitAuthor(this._res);

  TRes _res;

  call({
    List<String>? emails,
    String? id,
  }) =>
      _res;
}

class Input$CommitContributionOrder {
  factory Input$CommitContributionOrder({
    required Enum$OrderDirection direction,
    required Enum$CommitContributionOrderField field,
  }) =>
      Input$CommitContributionOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$CommitContributionOrder._(this._$data);

  factory Input$CommitContributionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$CommitContributionOrderField((l$field as String));
    return Input$CommitContributionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$CommitContributionOrderField get field =>
      (_$data['field'] as Enum$CommitContributionOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$CommitContributionOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$CommitContributionOrder<Input$CommitContributionOrder>
      get copyWith => CopyWith$Input$CommitContributionOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitContributionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$CommitContributionOrder<TRes> {
  factory CopyWith$Input$CommitContributionOrder(
    Input$CommitContributionOrder instance,
    TRes Function(Input$CommitContributionOrder) then,
  ) = _CopyWithImpl$Input$CommitContributionOrder;

  factory CopyWith$Input$CommitContributionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitContributionOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$CommitContributionOrderField? field,
  });
}

class _CopyWithImpl$Input$CommitContributionOrder<TRes>
    implements CopyWith$Input$CommitContributionOrder<TRes> {
  _CopyWithImpl$Input$CommitContributionOrder(
    this._instance,
    this._then,
  );

  final Input$CommitContributionOrder _instance;

  final TRes Function(Input$CommitContributionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$CommitContributionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$CommitContributionOrderField),
      }));
}

class _CopyWithStubImpl$Input$CommitContributionOrder<TRes>
    implements CopyWith$Input$CommitContributionOrder<TRes> {
  _CopyWithStubImpl$Input$CommitContributionOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$CommitContributionOrderField? field,
  }) =>
      _res;
}

class Input$CommitMessage {
  factory Input$CommitMessage({
    String? body,
    required String headline,
  }) =>
      Input$CommitMessage._({
        if (body != null) r'body': body,
        r'headline': headline,
      });

  Input$CommitMessage._(this._$data);

  factory Input$CommitMessage.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    final l$headline = data['headline'];
    result$data['headline'] = (l$headline as String);
    return Input$CommitMessage._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String get headline => (_$data['headline'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    final l$headline = headline;
    result$data['headline'] = l$headline;
    return result$data;
  }

  CopyWith$Input$CommitMessage<Input$CommitMessage> get copyWith =>
      CopyWith$Input$CommitMessage(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommitMessage) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$headline = headline;
    final lOther$headline = other.headline;
    if (l$headline != lOther$headline) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$headline = headline;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      l$headline,
    ]);
  }
}

abstract class CopyWith$Input$CommitMessage<TRes> {
  factory CopyWith$Input$CommitMessage(
    Input$CommitMessage instance,
    TRes Function(Input$CommitMessage) then,
  ) = _CopyWithImpl$Input$CommitMessage;

  factory CopyWith$Input$CommitMessage.stub(TRes res) =
      _CopyWithStubImpl$Input$CommitMessage;

  TRes call({
    String? body,
    String? headline,
  });
}

class _CopyWithImpl$Input$CommitMessage<TRes>
    implements CopyWith$Input$CommitMessage<TRes> {
  _CopyWithImpl$Input$CommitMessage(
    this._instance,
    this._then,
  );

  final Input$CommitMessage _instance;

  final TRes Function(Input$CommitMessage) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? headline = _undefined,
  }) =>
      _then(Input$CommitMessage._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (headline != _undefined && headline != null)
          'headline': (headline as String),
      }));
}

class _CopyWithStubImpl$Input$CommitMessage<TRes>
    implements CopyWith$Input$CommitMessage<TRes> {
  _CopyWithStubImpl$Input$CommitMessage(this._res);

  TRes _res;

  call({
    String? body,
    String? headline,
  }) =>
      _res;
}

class Input$CommittableBranch {
  factory Input$CommittableBranch({
    String? branchName,
    String? id,
    String? repositoryNameWithOwner,
  }) =>
      Input$CommittableBranch._({
        if (branchName != null) r'branchName': branchName,
        if (id != null) r'id': id,
        if (repositoryNameWithOwner != null)
          r'repositoryNameWithOwner': repositoryNameWithOwner,
      });

  Input$CommittableBranch._(this._$data);

  factory Input$CommittableBranch.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('branchName')) {
      final l$branchName = data['branchName'];
      result$data['branchName'] = (l$branchName as String?);
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as String?);
    }
    if (data.containsKey('repositoryNameWithOwner')) {
      final l$repositoryNameWithOwner = data['repositoryNameWithOwner'];
      result$data['repositoryNameWithOwner'] =
          (l$repositoryNameWithOwner as String?);
    }
    return Input$CommittableBranch._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get branchName => (_$data['branchName'] as String?);
  String? get id => (_$data['id'] as String?);
  String? get repositoryNameWithOwner =>
      (_$data['repositoryNameWithOwner'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('branchName')) {
      final l$branchName = branchName;
      result$data['branchName'] = l$branchName;
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    if (_$data.containsKey('repositoryNameWithOwner')) {
      final l$repositoryNameWithOwner = repositoryNameWithOwner;
      result$data['repositoryNameWithOwner'] = l$repositoryNameWithOwner;
    }
    return result$data;
  }

  CopyWith$Input$CommittableBranch<Input$CommittableBranch> get copyWith =>
      CopyWith$Input$CommittableBranch(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CommittableBranch) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$branchName = branchName;
    final lOther$branchName = other.branchName;
    if (_$data.containsKey('branchName') !=
        other._$data.containsKey('branchName')) {
      return false;
    }
    if (l$branchName != lOther$branchName) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$repositoryNameWithOwner = repositoryNameWithOwner;
    final lOther$repositoryNameWithOwner = other.repositoryNameWithOwner;
    if (_$data.containsKey('repositoryNameWithOwner') !=
        other._$data.containsKey('repositoryNameWithOwner')) {
      return false;
    }
    if (l$repositoryNameWithOwner != lOther$repositoryNameWithOwner) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$branchName = branchName;
    final l$id = id;
    final l$repositoryNameWithOwner = repositoryNameWithOwner;
    return Object.hashAll([
      _$data.containsKey('branchName') ? l$branchName : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('repositoryNameWithOwner')
          ? l$repositoryNameWithOwner
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CommittableBranch<TRes> {
  factory CopyWith$Input$CommittableBranch(
    Input$CommittableBranch instance,
    TRes Function(Input$CommittableBranch) then,
  ) = _CopyWithImpl$Input$CommittableBranch;

  factory CopyWith$Input$CommittableBranch.stub(TRes res) =
      _CopyWithStubImpl$Input$CommittableBranch;

  TRes call({
    String? branchName,
    String? id,
    String? repositoryNameWithOwner,
  });
}

class _CopyWithImpl$Input$CommittableBranch<TRes>
    implements CopyWith$Input$CommittableBranch<TRes> {
  _CopyWithImpl$Input$CommittableBranch(
    this._instance,
    this._then,
  );

  final Input$CommittableBranch _instance;

  final TRes Function(Input$CommittableBranch) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? branchName = _undefined,
    Object? id = _undefined,
    Object? repositoryNameWithOwner = _undefined,
  }) =>
      _then(Input$CommittableBranch._({
        ..._instance._$data,
        if (branchName != _undefined) 'branchName': (branchName as String?),
        if (id != _undefined) 'id': (id as String?),
        if (repositoryNameWithOwner != _undefined)
          'repositoryNameWithOwner': (repositoryNameWithOwner as String?),
      }));
}

class _CopyWithStubImpl$Input$CommittableBranch<TRes>
    implements CopyWith$Input$CommittableBranch<TRes> {
  _CopyWithStubImpl$Input$CommittableBranch(this._res);

  TRes _res;

  call({
    String? branchName,
    String? id,
    String? repositoryNameWithOwner,
  }) =>
      _res;
}

class Input$ContributionOrder {
  factory Input$ContributionOrder({required Enum$OrderDirection direction}) =>
      Input$ContributionOrder._({
        r'direction': direction,
      });

  Input$ContributionOrder._(this._$data);

  factory Input$ContributionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    return Input$ContributionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    return result$data;
  }

  CopyWith$Input$ContributionOrder<Input$ContributionOrder> get copyWith =>
      CopyWith$Input$ContributionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ContributionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    return Object.hashAll([l$direction]);
  }
}

abstract class CopyWith$Input$ContributionOrder<TRes> {
  factory CopyWith$Input$ContributionOrder(
    Input$ContributionOrder instance,
    TRes Function(Input$ContributionOrder) then,
  ) = _CopyWithImpl$Input$ContributionOrder;

  factory CopyWith$Input$ContributionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ContributionOrder;

  TRes call({Enum$OrderDirection? direction});
}

class _CopyWithImpl$Input$ContributionOrder<TRes>
    implements CopyWith$Input$ContributionOrder<TRes> {
  _CopyWithImpl$Input$ContributionOrder(
    this._instance,
    this._then,
  );

  final Input$ContributionOrder _instance;

  final TRes Function(Input$ContributionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? direction = _undefined}) =>
      _then(Input$ContributionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
      }));
}

class _CopyWithStubImpl$Input$ContributionOrder<TRes>
    implements CopyWith$Input$ContributionOrder<TRes> {
  _CopyWithStubImpl$Input$ContributionOrder(this._res);

  TRes _res;

  call({Enum$OrderDirection? direction}) => _res;
}

class Input$ConvertProjectCardNoteToIssueInput {
  factory Input$ConvertProjectCardNoteToIssueInput({
    String? body,
    String? clientMutationId,
    required String projectCardId,
    required String repositoryId,
    String? title,
  }) =>
      Input$ConvertProjectCardNoteToIssueInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectCardId': projectCardId,
        r'repositoryId': repositoryId,
        if (title != null) r'title': title,
      });

  Input$ConvertProjectCardNoteToIssueInput._(this._$data);

  factory Input$ConvertProjectCardNoteToIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectCardId = data['projectCardId'];
    result$data['projectCardId'] = (l$projectCardId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$ConvertProjectCardNoteToIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectCardId => (_$data['projectCardId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectCardId = projectCardId;
    result$data['projectCardId'] = l$projectCardId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$ConvertProjectCardNoteToIssueInput<
          Input$ConvertProjectCardNoteToIssueInput>
      get copyWith => CopyWith$Input$ConvertProjectCardNoteToIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConvertProjectCardNoteToIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectCardId = projectCardId;
    final lOther$projectCardId = other.projectCardId;
    if (l$projectCardId != lOther$projectCardId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$projectCardId = projectCardId;
    final l$repositoryId = repositoryId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectCardId,
      l$repositoryId,
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  factory CopyWith$Input$ConvertProjectCardNoteToIssueInput(
    Input$ConvertProjectCardNoteToIssueInput instance,
    TRes Function(Input$ConvertProjectCardNoteToIssueInput) then,
  ) = _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput;

  factory CopyWith$Input$ConvertProjectCardNoteToIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? projectCardId,
    String? repositoryId,
    String? title,
  });
}

class _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  _CopyWithImpl$Input$ConvertProjectCardNoteToIssueInput(
    this._instance,
    this._then,
  );

  final Input$ConvertProjectCardNoteToIssueInput _instance;

  final TRes Function(Input$ConvertProjectCardNoteToIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? projectCardId = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$ConvertProjectCardNoteToIssueInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectCardId != _undefined && projectCardId != null)
          'projectCardId': (projectCardId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput<TRes>
    implements CopyWith$Input$ConvertProjectCardNoteToIssueInput<TRes> {
  _CopyWithStubImpl$Input$ConvertProjectCardNoteToIssueInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? projectCardId,
    String? repositoryId,
    String? title,
  }) =>
      _res;
}

class Input$ConvertPullRequestToDraftInput {
  factory Input$ConvertPullRequestToDraftInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$ConvertPullRequestToDraftInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$ConvertPullRequestToDraftInput._(this._$data);

  factory Input$ConvertPullRequestToDraftInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$ConvertPullRequestToDraftInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$ConvertPullRequestToDraftInput<
          Input$ConvertPullRequestToDraftInput>
      get copyWith => CopyWith$Input$ConvertPullRequestToDraftInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ConvertPullRequestToDraftInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  factory CopyWith$Input$ConvertPullRequestToDraftInput(
    Input$ConvertPullRequestToDraftInput instance,
    TRes Function(Input$ConvertPullRequestToDraftInput) then,
  ) = _CopyWithImpl$Input$ConvertPullRequestToDraftInput;

  factory CopyWith$Input$ConvertPullRequestToDraftInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$ConvertPullRequestToDraftInput<TRes>
    implements CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  _CopyWithImpl$Input$ConvertPullRequestToDraftInput(
    this._instance,
    this._then,
  );

  final Input$ConvertPullRequestToDraftInput _instance;

  final TRes Function(Input$ConvertPullRequestToDraftInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$ConvertPullRequestToDraftInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput<TRes>
    implements CopyWith$Input$ConvertPullRequestToDraftInput<TRes> {
  _CopyWithStubImpl$Input$ConvertPullRequestToDraftInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$CopyProjectV2Input {
  factory Input$CopyProjectV2Input({
    String? clientMutationId,
    bool? includeDraftIssues,
    required String ownerId,
    required String projectId,
    required String title,
  }) =>
      Input$CopyProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (includeDraftIssues != null)
          r'includeDraftIssues': includeDraftIssues,
        r'ownerId': ownerId,
        r'projectId': projectId,
        r'title': title,
      });

  Input$CopyProjectV2Input._(this._$data);

  factory Input$CopyProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('includeDraftIssues')) {
      final l$includeDraftIssues = data['includeDraftIssues'];
      result$data['includeDraftIssues'] = (l$includeDraftIssues as bool?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$CopyProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get includeDraftIssues => (_$data['includeDraftIssues'] as bool?);
  String get ownerId => (_$data['ownerId'] as String);
  String get projectId => (_$data['projectId'] as String);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('includeDraftIssues')) {
      final l$includeDraftIssues = includeDraftIssues;
      result$data['includeDraftIssues'] = l$includeDraftIssues;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$CopyProjectV2Input<Input$CopyProjectV2Input> get copyWith =>
      CopyWith$Input$CopyProjectV2Input(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CopyProjectV2Input) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$includeDraftIssues = includeDraftIssues;
    final lOther$includeDraftIssues = other.includeDraftIssues;
    if (_$data.containsKey('includeDraftIssues') !=
        other._$data.containsKey('includeDraftIssues')) {
      return false;
    }
    if (l$includeDraftIssues != lOther$includeDraftIssues) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$includeDraftIssues = includeDraftIssues;
    final l$ownerId = ownerId;
    final l$projectId = projectId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('includeDraftIssues')
          ? l$includeDraftIssues
          : const {},
      l$ownerId,
      l$projectId,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$CopyProjectV2Input<TRes> {
  factory CopyWith$Input$CopyProjectV2Input(
    Input$CopyProjectV2Input instance,
    TRes Function(Input$CopyProjectV2Input) then,
  ) = _CopyWithImpl$Input$CopyProjectV2Input;

  factory CopyWith$Input$CopyProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$CopyProjectV2Input;

  TRes call({
    String? clientMutationId,
    bool? includeDraftIssues,
    String? ownerId,
    String? projectId,
    String? title,
  });
}

class _CopyWithImpl$Input$CopyProjectV2Input<TRes>
    implements CopyWith$Input$CopyProjectV2Input<TRes> {
  _CopyWithImpl$Input$CopyProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$CopyProjectV2Input _instance;

  final TRes Function(Input$CopyProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? includeDraftIssues = _undefined,
    Object? ownerId = _undefined,
    Object? projectId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CopyProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (includeDraftIssues != _undefined)
          'includeDraftIssues': (includeDraftIssues as bool?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$CopyProjectV2Input<TRes>
    implements CopyWith$Input$CopyProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$CopyProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? includeDraftIssues,
    String? ownerId,
    String? projectId,
    String? title,
  }) =>
      _res;
}

class Input$CreateAttributionInvitationInput {
  factory Input$CreateAttributionInvitationInput({
    String? clientMutationId,
    required String ownerId,
    required String sourceId,
    required String targetId,
  }) =>
      Input$CreateAttributionInvitationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'sourceId': sourceId,
        r'targetId': targetId,
      });

  Input$CreateAttributionInvitationInput._(this._$data);

  factory Input$CreateAttributionInvitationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    final l$targetId = data['targetId'];
    result$data['targetId'] = (l$targetId as String);
    return Input$CreateAttributionInvitationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  String get sourceId => (_$data['sourceId'] as String);
  String get targetId => (_$data['targetId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    final l$targetId = targetId;
    result$data['targetId'] = l$targetId;
    return result$data;
  }

  CopyWith$Input$CreateAttributionInvitationInput<
          Input$CreateAttributionInvitationInput>
      get copyWith => CopyWith$Input$CreateAttributionInvitationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateAttributionInvitationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$targetId = targetId;
    final lOther$targetId = other.targetId;
    if (l$targetId != lOther$targetId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$sourceId = sourceId;
    final l$targetId = targetId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$sourceId,
      l$targetId,
    ]);
  }
}

abstract class CopyWith$Input$CreateAttributionInvitationInput<TRes> {
  factory CopyWith$Input$CreateAttributionInvitationInput(
    Input$CreateAttributionInvitationInput instance,
    TRes Function(Input$CreateAttributionInvitationInput) then,
  ) = _CopyWithImpl$Input$CreateAttributionInvitationInput;

  factory CopyWith$Input$CreateAttributionInvitationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateAttributionInvitationInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    String? sourceId,
    String? targetId,
  });
}

class _CopyWithImpl$Input$CreateAttributionInvitationInput<TRes>
    implements CopyWith$Input$CreateAttributionInvitationInput<TRes> {
  _CopyWithImpl$Input$CreateAttributionInvitationInput(
    this._instance,
    this._then,
  );

  final Input$CreateAttributionInvitationInput _instance;

  final TRes Function(Input$CreateAttributionInvitationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? sourceId = _undefined,
    Object? targetId = _undefined,
  }) =>
      _then(Input$CreateAttributionInvitationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (targetId != _undefined && targetId != null)
          'targetId': (targetId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateAttributionInvitationInput<TRes>
    implements CopyWith$Input$CreateAttributionInvitationInput<TRes> {
  _CopyWithStubImpl$Input$CreateAttributionInvitationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    String? sourceId,
    String? targetId,
  }) =>
      _res;
}

class Input$CreateBranchProtectionRuleInput {
  factory Input$CreateBranchProtectionRuleInput({
    bool? allowsDeletions,
    bool? allowsForcePushes,
    bool? blocksCreations,
    List<String>? bypassForcePushActorIds,
    List<String>? bypassPullRequestActorIds,
    String? clientMutationId,
    bool? dismissesStaleReviews,
    bool? isAdminEnforced,
    bool? lockAllowsFetchAndMerge,
    bool? lockBranch,
    required String pattern,
    List<String>? pushActorIds,
    required String repositoryId,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    List<String>? requiredDeploymentEnvironments,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresApprovingReviews,
    bool? requiresCodeOwnerReviews,
    bool? requiresCommitSignatures,
    bool? requiresConversationResolution,
    bool? requiresDeployments,
    bool? requiresLinearHistory,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? restrictsPushes,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
  }) =>
      Input$CreateBranchProtectionRuleInput._({
        if (allowsDeletions != null) r'allowsDeletions': allowsDeletions,
        if (allowsForcePushes != null) r'allowsForcePushes': allowsForcePushes,
        if (blocksCreations != null) r'blocksCreations': blocksCreations,
        if (bypassForcePushActorIds != null)
          r'bypassForcePushActorIds': bypassForcePushActorIds,
        if (bypassPullRequestActorIds != null)
          r'bypassPullRequestActorIds': bypassPullRequestActorIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (dismissesStaleReviews != null)
          r'dismissesStaleReviews': dismissesStaleReviews,
        if (isAdminEnforced != null) r'isAdminEnforced': isAdminEnforced,
        if (lockAllowsFetchAndMerge != null)
          r'lockAllowsFetchAndMerge': lockAllowsFetchAndMerge,
        if (lockBranch != null) r'lockBranch': lockBranch,
        r'pattern': pattern,
        if (pushActorIds != null) r'pushActorIds': pushActorIds,
        r'repositoryId': repositoryId,
        if (requireLastPushApproval != null)
          r'requireLastPushApproval': requireLastPushApproval,
        if (requiredApprovingReviewCount != null)
          r'requiredApprovingReviewCount': requiredApprovingReviewCount,
        if (requiredDeploymentEnvironments != null)
          r'requiredDeploymentEnvironments': requiredDeploymentEnvironments,
        if (requiredStatusCheckContexts != null)
          r'requiredStatusCheckContexts': requiredStatusCheckContexts,
        if (requiredStatusChecks != null)
          r'requiredStatusChecks': requiredStatusChecks,
        if (requiresApprovingReviews != null)
          r'requiresApprovingReviews': requiresApprovingReviews,
        if (requiresCodeOwnerReviews != null)
          r'requiresCodeOwnerReviews': requiresCodeOwnerReviews,
        if (requiresCommitSignatures != null)
          r'requiresCommitSignatures': requiresCommitSignatures,
        if (requiresConversationResolution != null)
          r'requiresConversationResolution': requiresConversationResolution,
        if (requiresDeployments != null)
          r'requiresDeployments': requiresDeployments,
        if (requiresLinearHistory != null)
          r'requiresLinearHistory': requiresLinearHistory,
        if (requiresStatusChecks != null)
          r'requiresStatusChecks': requiresStatusChecks,
        if (requiresStrictStatusChecks != null)
          r'requiresStrictStatusChecks': requiresStrictStatusChecks,
        if (restrictsPushes != null) r'restrictsPushes': restrictsPushes,
        if (restrictsReviewDismissals != null)
          r'restrictsReviewDismissals': restrictsReviewDismissals,
        if (reviewDismissalActorIds != null)
          r'reviewDismissalActorIds': reviewDismissalActorIds,
      });

  Input$CreateBranchProtectionRuleInput._(this._$data);

  factory Input$CreateBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = data['allowsDeletions'];
      result$data['allowsDeletions'] = (l$allowsDeletions as bool?);
    }
    if (data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = data['allowsForcePushes'];
      result$data['allowsForcePushes'] = (l$allowsForcePushes as bool?);
    }
    if (data.containsKey('blocksCreations')) {
      final l$blocksCreations = data['blocksCreations'];
      result$data['blocksCreations'] = (l$blocksCreations as bool?);
    }
    if (data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = data['bypassForcePushActorIds'];
      result$data['bypassForcePushActorIds'] =
          (l$bypassForcePushActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = data['bypassPullRequestActorIds'];
      result$data['bypassPullRequestActorIds'] =
          (l$bypassPullRequestActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = data['dismissesStaleReviews'];
      result$data['dismissesStaleReviews'] = (l$dismissesStaleReviews as bool?);
    }
    if (data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = data['isAdminEnforced'];
      result$data['isAdminEnforced'] = (l$isAdminEnforced as bool?);
    }
    if (data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = data['lockAllowsFetchAndMerge'];
      result$data['lockAllowsFetchAndMerge'] =
          (l$lockAllowsFetchAndMerge as bool?);
    }
    if (data.containsKey('lockBranch')) {
      final l$lockBranch = data['lockBranch'];
      result$data['lockBranch'] = (l$lockBranch as bool?);
    }
    final l$pattern = data['pattern'];
    result$data['pattern'] = (l$pattern as String);
    if (data.containsKey('pushActorIds')) {
      final l$pushActorIds = data['pushActorIds'];
      result$data['pushActorIds'] = (l$pushActorIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = data['requireLastPushApproval'];
      result$data['requireLastPushApproval'] =
          (l$requireLastPushApproval as bool?);
    }
    if (data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount =
          data['requiredApprovingReviewCount'];
      result$data['requiredApprovingReviewCount'] =
          (l$requiredApprovingReviewCount as int?);
    }
    if (data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments =
          data['requiredDeploymentEnvironments'];
      result$data['requiredDeploymentEnvironments'] =
          (l$requiredDeploymentEnvironments as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = data['requiredStatusCheckContexts'];
      result$data['requiredStatusCheckContexts'] =
          (l$requiredStatusCheckContexts as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = data['requiredStatusChecks'];
      result$data['requiredStatusChecks'] =
          (l$requiredStatusChecks as List<dynamic>?)
              ?.map((e) => Input$RequiredStatusCheckInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = data['requiresApprovingReviews'];
      result$data['requiresApprovingReviews'] =
          (l$requiresApprovingReviews as bool?);
    }
    if (data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = data['requiresCodeOwnerReviews'];
      result$data['requiresCodeOwnerReviews'] =
          (l$requiresCodeOwnerReviews as bool?);
    }
    if (data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = data['requiresCommitSignatures'];
      result$data['requiresCommitSignatures'] =
          (l$requiresCommitSignatures as bool?);
    }
    if (data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution =
          data['requiresConversationResolution'];
      result$data['requiresConversationResolution'] =
          (l$requiresConversationResolution as bool?);
    }
    if (data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = data['requiresDeployments'];
      result$data['requiresDeployments'] = (l$requiresDeployments as bool?);
    }
    if (data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = data['requiresLinearHistory'];
      result$data['requiresLinearHistory'] = (l$requiresLinearHistory as bool?);
    }
    if (data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = data['requiresStatusChecks'];
      result$data['requiresStatusChecks'] = (l$requiresStatusChecks as bool?);
    }
    if (data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = data['requiresStrictStatusChecks'];
      result$data['requiresStrictStatusChecks'] =
          (l$requiresStrictStatusChecks as bool?);
    }
    if (data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = data['restrictsPushes'];
      result$data['restrictsPushes'] = (l$restrictsPushes as bool?);
    }
    if (data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = data['restrictsReviewDismissals'];
      result$data['restrictsReviewDismissals'] =
          (l$restrictsReviewDismissals as bool?);
    }
    if (data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = data['reviewDismissalActorIds'];
      result$data['reviewDismissalActorIds'] =
          (l$reviewDismissalActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    return Input$CreateBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get allowsDeletions => (_$data['allowsDeletions'] as bool?);
  bool? get allowsForcePushes => (_$data['allowsForcePushes'] as bool?);
  bool? get blocksCreations => (_$data['blocksCreations'] as bool?);
  List<String>? get bypassForcePushActorIds =>
      (_$data['bypassForcePushActorIds'] as List<String>?);
  List<String>? get bypassPullRequestActorIds =>
      (_$data['bypassPullRequestActorIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get dismissesStaleReviews => (_$data['dismissesStaleReviews'] as bool?);
  bool? get isAdminEnforced => (_$data['isAdminEnforced'] as bool?);
  bool? get lockAllowsFetchAndMerge =>
      (_$data['lockAllowsFetchAndMerge'] as bool?);
  bool? get lockBranch => (_$data['lockBranch'] as bool?);
  String get pattern => (_$data['pattern'] as String);
  List<String>? get pushActorIds => (_$data['pushActorIds'] as List<String>?);
  String get repositoryId => (_$data['repositoryId'] as String);
  bool? get requireLastPushApproval =>
      (_$data['requireLastPushApproval'] as bool?);
  int? get requiredApprovingReviewCount =>
      (_$data['requiredApprovingReviewCount'] as int?);
  List<String>? get requiredDeploymentEnvironments =>
      (_$data['requiredDeploymentEnvironments'] as List<String>?);
  List<String>? get requiredStatusCheckContexts =>
      (_$data['requiredStatusCheckContexts'] as List<String>?);
  List<Input$RequiredStatusCheckInput>? get requiredStatusChecks =>
      (_$data['requiredStatusChecks'] as List<Input$RequiredStatusCheckInput>?);
  bool? get requiresApprovingReviews =>
      (_$data['requiresApprovingReviews'] as bool?);
  bool? get requiresCodeOwnerReviews =>
      (_$data['requiresCodeOwnerReviews'] as bool?);
  bool? get requiresCommitSignatures =>
      (_$data['requiresCommitSignatures'] as bool?);
  bool? get requiresConversationResolution =>
      (_$data['requiresConversationResolution'] as bool?);
  bool? get requiresDeployments => (_$data['requiresDeployments'] as bool?);
  bool? get requiresLinearHistory => (_$data['requiresLinearHistory'] as bool?);
  bool? get requiresStatusChecks => (_$data['requiresStatusChecks'] as bool?);
  bool? get requiresStrictStatusChecks =>
      (_$data['requiresStrictStatusChecks'] as bool?);
  bool? get restrictsPushes => (_$data['restrictsPushes'] as bool?);
  bool? get restrictsReviewDismissals =>
      (_$data['restrictsReviewDismissals'] as bool?);
  List<String>? get reviewDismissalActorIds =>
      (_$data['reviewDismissalActorIds'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = allowsDeletions;
      result$data['allowsDeletions'] = l$allowsDeletions;
    }
    if (_$data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = allowsForcePushes;
      result$data['allowsForcePushes'] = l$allowsForcePushes;
    }
    if (_$data.containsKey('blocksCreations')) {
      final l$blocksCreations = blocksCreations;
      result$data['blocksCreations'] = l$blocksCreations;
    }
    if (_$data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = bypassForcePushActorIds;
      result$data['bypassForcePushActorIds'] =
          l$bypassForcePushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
      result$data['bypassPullRequestActorIds'] =
          l$bypassPullRequestActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = dismissesStaleReviews;
      result$data['dismissesStaleReviews'] = l$dismissesStaleReviews;
    }
    if (_$data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = isAdminEnforced;
      result$data['isAdminEnforced'] = l$isAdminEnforced;
    }
    if (_$data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
      result$data['lockAllowsFetchAndMerge'] = l$lockAllowsFetchAndMerge;
    }
    if (_$data.containsKey('lockBranch')) {
      final l$lockBranch = lockBranch;
      result$data['lockBranch'] = l$lockBranch;
    }
    final l$pattern = pattern;
    result$data['pattern'] = l$pattern;
    if (_$data.containsKey('pushActorIds')) {
      final l$pushActorIds = pushActorIds;
      result$data['pushActorIds'] = l$pushActorIds?.map((e) => e).toList();
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = requireLastPushApproval;
      result$data['requireLastPushApproval'] = l$requireLastPushApproval;
    }
    if (_$data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
      result$data['requiredApprovingReviewCount'] =
          l$requiredApprovingReviewCount;
    }
    if (_$data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
      result$data['requiredDeploymentEnvironments'] =
          l$requiredDeploymentEnvironments?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
      result$data['requiredStatusCheckContexts'] =
          l$requiredStatusCheckContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = requiredStatusChecks;
      result$data['requiredStatusChecks'] =
          l$requiredStatusChecks?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = requiresApprovingReviews;
      result$data['requiresApprovingReviews'] = l$requiresApprovingReviews;
    }
    if (_$data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
      result$data['requiresCodeOwnerReviews'] = l$requiresCodeOwnerReviews;
    }
    if (_$data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = requiresCommitSignatures;
      result$data['requiresCommitSignatures'] = l$requiresCommitSignatures;
    }
    if (_$data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution = requiresConversationResolution;
      result$data['requiresConversationResolution'] =
          l$requiresConversationResolution;
    }
    if (_$data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = requiresDeployments;
      result$data['requiresDeployments'] = l$requiresDeployments;
    }
    if (_$data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = requiresLinearHistory;
      result$data['requiresLinearHistory'] = l$requiresLinearHistory;
    }
    if (_$data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = requiresStatusChecks;
      result$data['requiresStatusChecks'] = l$requiresStatusChecks;
    }
    if (_$data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
      result$data['requiresStrictStatusChecks'] = l$requiresStrictStatusChecks;
    }
    if (_$data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = restrictsPushes;
      result$data['restrictsPushes'] = l$restrictsPushes;
    }
    if (_$data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = restrictsReviewDismissals;
      result$data['restrictsReviewDismissals'] = l$restrictsReviewDismissals;
    }
    if (_$data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = reviewDismissalActorIds;
      result$data['reviewDismissalActorIds'] =
          l$reviewDismissalActorIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateBranchProtectionRuleInput<
          Input$CreateBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$CreateBranchProtectionRuleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateBranchProtectionRuleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$allowsDeletions = allowsDeletions;
    final lOther$allowsDeletions = other.allowsDeletions;
    if (_$data.containsKey('allowsDeletions') !=
        other._$data.containsKey('allowsDeletions')) {
      return false;
    }
    if (l$allowsDeletions != lOther$allowsDeletions) {
      return false;
    }
    final l$allowsForcePushes = allowsForcePushes;
    final lOther$allowsForcePushes = other.allowsForcePushes;
    if (_$data.containsKey('allowsForcePushes') !=
        other._$data.containsKey('allowsForcePushes')) {
      return false;
    }
    if (l$allowsForcePushes != lOther$allowsForcePushes) {
      return false;
    }
    final l$blocksCreations = blocksCreations;
    final lOther$blocksCreations = other.blocksCreations;
    if (_$data.containsKey('blocksCreations') !=
        other._$data.containsKey('blocksCreations')) {
      return false;
    }
    if (l$blocksCreations != lOther$blocksCreations) {
      return false;
    }
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final lOther$bypassForcePushActorIds = other.bypassForcePushActorIds;
    if (_$data.containsKey('bypassForcePushActorIds') !=
        other._$data.containsKey('bypassForcePushActorIds')) {
      return false;
    }
    if (l$bypassForcePushActorIds != null &&
        lOther$bypassForcePushActorIds != null) {
      if (l$bypassForcePushActorIds.length !=
          lOther$bypassForcePushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassForcePushActorIds.length; i++) {
        final l$bypassForcePushActorIds$entry = l$bypassForcePushActorIds[i];
        final lOther$bypassForcePushActorIds$entry =
            lOther$bypassForcePushActorIds[i];
        if (l$bypassForcePushActorIds$entry !=
            lOther$bypassForcePushActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassForcePushActorIds != lOther$bypassForcePushActorIds) {
      return false;
    }
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final lOther$bypassPullRequestActorIds = other.bypassPullRequestActorIds;
    if (_$data.containsKey('bypassPullRequestActorIds') !=
        other._$data.containsKey('bypassPullRequestActorIds')) {
      return false;
    }
    if (l$bypassPullRequestActorIds != null &&
        lOther$bypassPullRequestActorIds != null) {
      if (l$bypassPullRequestActorIds.length !=
          lOther$bypassPullRequestActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassPullRequestActorIds.length; i++) {
        final l$bypassPullRequestActorIds$entry =
            l$bypassPullRequestActorIds[i];
        final lOther$bypassPullRequestActorIds$entry =
            lOther$bypassPullRequestActorIds[i];
        if (l$bypassPullRequestActorIds$entry !=
            lOther$bypassPullRequestActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassPullRequestActorIds !=
        lOther$bypassPullRequestActorIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final lOther$dismissesStaleReviews = other.dismissesStaleReviews;
    if (_$data.containsKey('dismissesStaleReviews') !=
        other._$data.containsKey('dismissesStaleReviews')) {
      return false;
    }
    if (l$dismissesStaleReviews != lOther$dismissesStaleReviews) {
      return false;
    }
    final l$isAdminEnforced = isAdminEnforced;
    final lOther$isAdminEnforced = other.isAdminEnforced;
    if (_$data.containsKey('isAdminEnforced') !=
        other._$data.containsKey('isAdminEnforced')) {
      return false;
    }
    if (l$isAdminEnforced != lOther$isAdminEnforced) {
      return false;
    }
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final lOther$lockAllowsFetchAndMerge = other.lockAllowsFetchAndMerge;
    if (_$data.containsKey('lockAllowsFetchAndMerge') !=
        other._$data.containsKey('lockAllowsFetchAndMerge')) {
      return false;
    }
    if (l$lockAllowsFetchAndMerge != lOther$lockAllowsFetchAndMerge) {
      return false;
    }
    final l$lockBranch = lockBranch;
    final lOther$lockBranch = other.lockBranch;
    if (_$data.containsKey('lockBranch') !=
        other._$data.containsKey('lockBranch')) {
      return false;
    }
    if (l$lockBranch != lOther$lockBranch) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (l$pattern != lOther$pattern) {
      return false;
    }
    final l$pushActorIds = pushActorIds;
    final lOther$pushActorIds = other.pushActorIds;
    if (_$data.containsKey('pushActorIds') !=
        other._$data.containsKey('pushActorIds')) {
      return false;
    }
    if (l$pushActorIds != null && lOther$pushActorIds != null) {
      if (l$pushActorIds.length != lOther$pushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$pushActorIds.length; i++) {
        final l$pushActorIds$entry = l$pushActorIds[i];
        final lOther$pushActorIds$entry = lOther$pushActorIds[i];
        if (l$pushActorIds$entry != lOther$pushActorIds$entry) {
          return false;
        }
      }
    } else if (l$pushActorIds != lOther$pushActorIds) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$requireLastPushApproval = requireLastPushApproval;
    final lOther$requireLastPushApproval = other.requireLastPushApproval;
    if (_$data.containsKey('requireLastPushApproval') !=
        other._$data.containsKey('requireLastPushApproval')) {
      return false;
    }
    if (l$requireLastPushApproval != lOther$requireLastPushApproval) {
      return false;
    }
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final lOther$requiredApprovingReviewCount =
        other.requiredApprovingReviewCount;
    if (_$data.containsKey('requiredApprovingReviewCount') !=
        other._$data.containsKey('requiredApprovingReviewCount')) {
      return false;
    }
    if (l$requiredApprovingReviewCount != lOther$requiredApprovingReviewCount) {
      return false;
    }
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final lOther$requiredDeploymentEnvironments =
        other.requiredDeploymentEnvironments;
    if (_$data.containsKey('requiredDeploymentEnvironments') !=
        other._$data.containsKey('requiredDeploymentEnvironments')) {
      return false;
    }
    if (l$requiredDeploymentEnvironments != null &&
        lOther$requiredDeploymentEnvironments != null) {
      if (l$requiredDeploymentEnvironments.length !=
          lOther$requiredDeploymentEnvironments.length) {
        return false;
      }
      for (int i = 0; i < l$requiredDeploymentEnvironments.length; i++) {
        final l$requiredDeploymentEnvironments$entry =
            l$requiredDeploymentEnvironments[i];
        final lOther$requiredDeploymentEnvironments$entry =
            lOther$requiredDeploymentEnvironments[i];
        if (l$requiredDeploymentEnvironments$entry !=
            lOther$requiredDeploymentEnvironments$entry) {
          return false;
        }
      }
    } else if (l$requiredDeploymentEnvironments !=
        lOther$requiredDeploymentEnvironments) {
      return false;
    }
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final lOther$requiredStatusCheckContexts =
        other.requiredStatusCheckContexts;
    if (_$data.containsKey('requiredStatusCheckContexts') !=
        other._$data.containsKey('requiredStatusCheckContexts')) {
      return false;
    }
    if (l$requiredStatusCheckContexts != null &&
        lOther$requiredStatusCheckContexts != null) {
      if (l$requiredStatusCheckContexts.length !=
          lOther$requiredStatusCheckContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusCheckContexts.length; i++) {
        final l$requiredStatusCheckContexts$entry =
            l$requiredStatusCheckContexts[i];
        final lOther$requiredStatusCheckContexts$entry =
            lOther$requiredStatusCheckContexts[i];
        if (l$requiredStatusCheckContexts$entry !=
            lOther$requiredStatusCheckContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusCheckContexts !=
        lOther$requiredStatusCheckContexts) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (_$data.containsKey('requiredStatusChecks') !=
        other._$data.containsKey('requiredStatusChecks')) {
      return false;
    }
    if (l$requiredStatusChecks != null && lOther$requiredStatusChecks != null) {
      if (l$requiredStatusChecks.length != lOther$requiredStatusChecks.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusChecks.length; i++) {
        final l$requiredStatusChecks$entry = l$requiredStatusChecks[i];
        final lOther$requiredStatusChecks$entry =
            lOther$requiredStatusChecks[i];
        if (l$requiredStatusChecks$entry != lOther$requiredStatusChecks$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusChecks != lOther$requiredStatusChecks) {
      return false;
    }
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final lOther$requiresApprovingReviews = other.requiresApprovingReviews;
    if (_$data.containsKey('requiresApprovingReviews') !=
        other._$data.containsKey('requiresApprovingReviews')) {
      return false;
    }
    if (l$requiresApprovingReviews != lOther$requiresApprovingReviews) {
      return false;
    }
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final lOther$requiresCodeOwnerReviews = other.requiresCodeOwnerReviews;
    if (_$data.containsKey('requiresCodeOwnerReviews') !=
        other._$data.containsKey('requiresCodeOwnerReviews')) {
      return false;
    }
    if (l$requiresCodeOwnerReviews != lOther$requiresCodeOwnerReviews) {
      return false;
    }
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final lOther$requiresCommitSignatures = other.requiresCommitSignatures;
    if (_$data.containsKey('requiresCommitSignatures') !=
        other._$data.containsKey('requiresCommitSignatures')) {
      return false;
    }
    if (l$requiresCommitSignatures != lOther$requiresCommitSignatures) {
      return false;
    }
    final l$requiresConversationResolution = requiresConversationResolution;
    final lOther$requiresConversationResolution =
        other.requiresConversationResolution;
    if (_$data.containsKey('requiresConversationResolution') !=
        other._$data.containsKey('requiresConversationResolution')) {
      return false;
    }
    if (l$requiresConversationResolution !=
        lOther$requiresConversationResolution) {
      return false;
    }
    final l$requiresDeployments = requiresDeployments;
    final lOther$requiresDeployments = other.requiresDeployments;
    if (_$data.containsKey('requiresDeployments') !=
        other._$data.containsKey('requiresDeployments')) {
      return false;
    }
    if (l$requiresDeployments != lOther$requiresDeployments) {
      return false;
    }
    final l$requiresLinearHistory = requiresLinearHistory;
    final lOther$requiresLinearHistory = other.requiresLinearHistory;
    if (_$data.containsKey('requiresLinearHistory') !=
        other._$data.containsKey('requiresLinearHistory')) {
      return false;
    }
    if (l$requiresLinearHistory != lOther$requiresLinearHistory) {
      return false;
    }
    final l$requiresStatusChecks = requiresStatusChecks;
    final lOther$requiresStatusChecks = other.requiresStatusChecks;
    if (_$data.containsKey('requiresStatusChecks') !=
        other._$data.containsKey('requiresStatusChecks')) {
      return false;
    }
    if (l$requiresStatusChecks != lOther$requiresStatusChecks) {
      return false;
    }
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final lOther$requiresStrictStatusChecks = other.requiresStrictStatusChecks;
    if (_$data.containsKey('requiresStrictStatusChecks') !=
        other._$data.containsKey('requiresStrictStatusChecks')) {
      return false;
    }
    if (l$requiresStrictStatusChecks != lOther$requiresStrictStatusChecks) {
      return false;
    }
    final l$restrictsPushes = restrictsPushes;
    final lOther$restrictsPushes = other.restrictsPushes;
    if (_$data.containsKey('restrictsPushes') !=
        other._$data.containsKey('restrictsPushes')) {
      return false;
    }
    if (l$restrictsPushes != lOther$restrictsPushes) {
      return false;
    }
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final lOther$restrictsReviewDismissals = other.restrictsReviewDismissals;
    if (_$data.containsKey('restrictsReviewDismissals') !=
        other._$data.containsKey('restrictsReviewDismissals')) {
      return false;
    }
    if (l$restrictsReviewDismissals != lOther$restrictsReviewDismissals) {
      return false;
    }
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final lOther$reviewDismissalActorIds = other.reviewDismissalActorIds;
    if (_$data.containsKey('reviewDismissalActorIds') !=
        other._$data.containsKey('reviewDismissalActorIds')) {
      return false;
    }
    if (l$reviewDismissalActorIds != null &&
        lOther$reviewDismissalActorIds != null) {
      if (l$reviewDismissalActorIds.length !=
          lOther$reviewDismissalActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$reviewDismissalActorIds.length; i++) {
        final l$reviewDismissalActorIds$entry = l$reviewDismissalActorIds[i];
        final lOther$reviewDismissalActorIds$entry =
            lOther$reviewDismissalActorIds[i];
        if (l$reviewDismissalActorIds$entry !=
            lOther$reviewDismissalActorIds$entry) {
          return false;
        }
      }
    } else if (l$reviewDismissalActorIds != lOther$reviewDismissalActorIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$allowsDeletions = allowsDeletions;
    final l$allowsForcePushes = allowsForcePushes;
    final l$blocksCreations = blocksCreations;
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final l$clientMutationId = clientMutationId;
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final l$isAdminEnforced = isAdminEnforced;
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final l$lockBranch = lockBranch;
    final l$pattern = pattern;
    final l$pushActorIds = pushActorIds;
    final l$repositoryId = repositoryId;
    final l$requireLastPushApproval = requireLastPushApproval;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final l$requiresConversationResolution = requiresConversationResolution;
    final l$requiresDeployments = requiresDeployments;
    final l$requiresLinearHistory = requiresLinearHistory;
    final l$requiresStatusChecks = requiresStatusChecks;
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final l$restrictsPushes = restrictsPushes;
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    return Object.hashAll([
      _$data.containsKey('allowsDeletions') ? l$allowsDeletions : const {},
      _$data.containsKey('allowsForcePushes') ? l$allowsForcePushes : const {},
      _$data.containsKey('blocksCreations') ? l$blocksCreations : const {},
      _$data.containsKey('bypassForcePushActorIds')
          ? l$bypassForcePushActorIds == null
              ? null
              : Object.hashAll(l$bypassForcePushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassPullRequestActorIds')
          ? l$bypassPullRequestActorIds == null
              ? null
              : Object.hashAll(l$bypassPullRequestActorIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('dismissesStaleReviews')
          ? l$dismissesStaleReviews
          : const {},
      _$data.containsKey('isAdminEnforced') ? l$isAdminEnforced : const {},
      _$data.containsKey('lockAllowsFetchAndMerge')
          ? l$lockAllowsFetchAndMerge
          : const {},
      _$data.containsKey('lockBranch') ? l$lockBranch : const {},
      l$pattern,
      _$data.containsKey('pushActorIds')
          ? l$pushActorIds == null
              ? null
              : Object.hashAll(l$pushActorIds.map((v) => v))
          : const {},
      l$repositoryId,
      _$data.containsKey('requireLastPushApproval')
          ? l$requireLastPushApproval
          : const {},
      _$data.containsKey('requiredApprovingReviewCount')
          ? l$requiredApprovingReviewCount
          : const {},
      _$data.containsKey('requiredDeploymentEnvironments')
          ? l$requiredDeploymentEnvironments == null
              ? null
              : Object.hashAll(l$requiredDeploymentEnvironments.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusCheckContexts')
          ? l$requiredStatusCheckContexts == null
              ? null
              : Object.hashAll(l$requiredStatusCheckContexts.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusChecks')
          ? l$requiredStatusChecks == null
              ? null
              : Object.hashAll(l$requiredStatusChecks.map((v) => v))
          : const {},
      _$data.containsKey('requiresApprovingReviews')
          ? l$requiresApprovingReviews
          : const {},
      _$data.containsKey('requiresCodeOwnerReviews')
          ? l$requiresCodeOwnerReviews
          : const {},
      _$data.containsKey('requiresCommitSignatures')
          ? l$requiresCommitSignatures
          : const {},
      _$data.containsKey('requiresConversationResolution')
          ? l$requiresConversationResolution
          : const {},
      _$data.containsKey('requiresDeployments')
          ? l$requiresDeployments
          : const {},
      _$data.containsKey('requiresLinearHistory')
          ? l$requiresLinearHistory
          : const {},
      _$data.containsKey('requiresStatusChecks')
          ? l$requiresStatusChecks
          : const {},
      _$data.containsKey('requiresStrictStatusChecks')
          ? l$requiresStrictStatusChecks
          : const {},
      _$data.containsKey('restrictsPushes') ? l$restrictsPushes : const {},
      _$data.containsKey('restrictsReviewDismissals')
          ? l$restrictsReviewDismissals
          : const {},
      _$data.containsKey('reviewDismissalActorIds')
          ? l$reviewDismissalActorIds == null
              ? null
              : Object.hashAll(l$reviewDismissalActorIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$CreateBranchProtectionRuleInput(
    Input$CreateBranchProtectionRuleInput instance,
    TRes Function(Input$CreateBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$CreateBranchProtectionRuleInput;

  factory CopyWith$Input$CreateBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput;

  TRes call({
    bool? allowsDeletions,
    bool? allowsForcePushes,
    bool? blocksCreations,
    List<String>? bypassForcePushActorIds,
    List<String>? bypassPullRequestActorIds,
    String? clientMutationId,
    bool? dismissesStaleReviews,
    bool? isAdminEnforced,
    bool? lockAllowsFetchAndMerge,
    bool? lockBranch,
    String? pattern,
    List<String>? pushActorIds,
    String? repositoryId,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    List<String>? requiredDeploymentEnvironments,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresApprovingReviews,
    bool? requiresCodeOwnerReviews,
    bool? requiresCommitSignatures,
    bool? requiresConversationResolution,
    bool? requiresDeployments,
    bool? requiresLinearHistory,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? restrictsPushes,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
  });
  TRes requiredStatusChecks(
      Iterable<Input$RequiredStatusCheckInput>? Function(
              Iterable<
                  CopyWith$Input$RequiredStatusCheckInput<
                      Input$RequiredStatusCheckInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$CreateBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$CreateBranchProtectionRuleInput _instance;

  final TRes Function(Input$CreateBranchProtectionRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? allowsDeletions = _undefined,
    Object? allowsForcePushes = _undefined,
    Object? blocksCreations = _undefined,
    Object? bypassForcePushActorIds = _undefined,
    Object? bypassPullRequestActorIds = _undefined,
    Object? clientMutationId = _undefined,
    Object? dismissesStaleReviews = _undefined,
    Object? isAdminEnforced = _undefined,
    Object? lockAllowsFetchAndMerge = _undefined,
    Object? lockBranch = _undefined,
    Object? pattern = _undefined,
    Object? pushActorIds = _undefined,
    Object? repositoryId = _undefined,
    Object? requireLastPushApproval = _undefined,
    Object? requiredApprovingReviewCount = _undefined,
    Object? requiredDeploymentEnvironments = _undefined,
    Object? requiredStatusCheckContexts = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? requiresApprovingReviews = _undefined,
    Object? requiresCodeOwnerReviews = _undefined,
    Object? requiresCommitSignatures = _undefined,
    Object? requiresConversationResolution = _undefined,
    Object? requiresDeployments = _undefined,
    Object? requiresLinearHistory = _undefined,
    Object? requiresStatusChecks = _undefined,
    Object? requiresStrictStatusChecks = _undefined,
    Object? restrictsPushes = _undefined,
    Object? restrictsReviewDismissals = _undefined,
    Object? reviewDismissalActorIds = _undefined,
  }) =>
      _then(Input$CreateBranchProtectionRuleInput._({
        ..._instance._$data,
        if (allowsDeletions != _undefined)
          'allowsDeletions': (allowsDeletions as bool?),
        if (allowsForcePushes != _undefined)
          'allowsForcePushes': (allowsForcePushes as bool?),
        if (blocksCreations != _undefined)
          'blocksCreations': (blocksCreations as bool?),
        if (bypassForcePushActorIds != _undefined)
          'bypassForcePushActorIds': (bypassForcePushActorIds as List<String>?),
        if (bypassPullRequestActorIds != _undefined)
          'bypassPullRequestActorIds':
              (bypassPullRequestActorIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (dismissesStaleReviews != _undefined)
          'dismissesStaleReviews': (dismissesStaleReviews as bool?),
        if (isAdminEnforced != _undefined)
          'isAdminEnforced': (isAdminEnforced as bool?),
        if (lockAllowsFetchAndMerge != _undefined)
          'lockAllowsFetchAndMerge': (lockAllowsFetchAndMerge as bool?),
        if (lockBranch != _undefined) 'lockBranch': (lockBranch as bool?),
        if (pattern != _undefined && pattern != null)
          'pattern': (pattern as String),
        if (pushActorIds != _undefined)
          'pushActorIds': (pushActorIds as List<String>?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (requireLastPushApproval != _undefined)
          'requireLastPushApproval': (requireLastPushApproval as bool?),
        if (requiredApprovingReviewCount != _undefined)
          'requiredApprovingReviewCount':
              (requiredApprovingReviewCount as int?),
        if (requiredDeploymentEnvironments != _undefined)
          'requiredDeploymentEnvironments':
              (requiredDeploymentEnvironments as List<String>?),
        if (requiredStatusCheckContexts != _undefined)
          'requiredStatusCheckContexts':
              (requiredStatusCheckContexts as List<String>?),
        if (requiredStatusChecks != _undefined)
          'requiredStatusChecks':
              (requiredStatusChecks as List<Input$RequiredStatusCheckInput>?),
        if (requiresApprovingReviews != _undefined)
          'requiresApprovingReviews': (requiresApprovingReviews as bool?),
        if (requiresCodeOwnerReviews != _undefined)
          'requiresCodeOwnerReviews': (requiresCodeOwnerReviews as bool?),
        if (requiresCommitSignatures != _undefined)
          'requiresCommitSignatures': (requiresCommitSignatures as bool?),
        if (requiresConversationResolution != _undefined)
          'requiresConversationResolution':
              (requiresConversationResolution as bool?),
        if (requiresDeployments != _undefined)
          'requiresDeployments': (requiresDeployments as bool?),
        if (requiresLinearHistory != _undefined)
          'requiresLinearHistory': (requiresLinearHistory as bool?),
        if (requiresStatusChecks != _undefined)
          'requiresStatusChecks': (requiresStatusChecks as bool?),
        if (requiresStrictStatusChecks != _undefined)
          'requiresStrictStatusChecks': (requiresStrictStatusChecks as bool?),
        if (restrictsPushes != _undefined)
          'restrictsPushes': (restrictsPushes as bool?),
        if (restrictsReviewDismissals != _undefined)
          'restrictsReviewDismissals': (restrictsReviewDismissals as bool?),
        if (reviewDismissalActorIds != _undefined)
          'reviewDismissalActorIds': (reviewDismissalActorIds as List<String>?),
      }));
  TRes requiredStatusChecks(
          Iterable<Input$RequiredStatusCheckInput>? Function(
                  Iterable<
                      CopyWith$Input$RequiredStatusCheckInput<
                          Input$RequiredStatusCheckInput>>?)
              _fn) =>
      call(
          requiredStatusChecks: _fn(_instance.requiredStatusChecks
              ?.map((e) => CopyWith$Input$RequiredStatusCheckInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$CreateBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$CreateBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    bool? allowsDeletions,
    bool? allowsForcePushes,
    bool? blocksCreations,
    List<String>? bypassForcePushActorIds,
    List<String>? bypassPullRequestActorIds,
    String? clientMutationId,
    bool? dismissesStaleReviews,
    bool? isAdminEnforced,
    bool? lockAllowsFetchAndMerge,
    bool? lockBranch,
    String? pattern,
    List<String>? pushActorIds,
    String? repositoryId,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    List<String>? requiredDeploymentEnvironments,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresApprovingReviews,
    bool? requiresCodeOwnerReviews,
    bool? requiresCommitSignatures,
    bool? requiresConversationResolution,
    bool? requiresDeployments,
    bool? requiresLinearHistory,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? restrictsPushes,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
  }) =>
      _res;
  requiredStatusChecks(_fn) => _res;
}

class Input$CreateCheckRunInput {
  factory Input$CreateCheckRunInput({
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
    DateTime? completedAt,
    Enum$CheckConclusionState? conclusion,
    String? detailsUrl,
    String? externalId,
    required String headSha,
    required String name,
    Input$CheckRunOutput? output,
    required String repositoryId,
    DateTime? startedAt,
    Enum$RequestableCheckStatusState? status,
  }) =>
      Input$CreateCheckRunInput._({
        if (actions != null) r'actions': actions,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (completedAt != null) r'completedAt': completedAt,
        if (conclusion != null) r'conclusion': conclusion,
        if (detailsUrl != null) r'detailsUrl': detailsUrl,
        if (externalId != null) r'externalId': externalId,
        r'headSha': headSha,
        r'name': name,
        if (output != null) r'output': output,
        r'repositoryId': repositoryId,
        if (startedAt != null) r'startedAt': startedAt,
        if (status != null) r'status': status,
      });

  Input$CreateCheckRunInput._(this._$data);

  factory Input$CreateCheckRunInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('actions')) {
      final l$actions = data['actions'];
      result$data['actions'] = (l$actions as List<dynamic>?)
          ?.map(
              (e) => Input$CheckRunAction.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    if (data.containsKey('conclusion')) {
      final l$conclusion = data['conclusion'];
      result$data['conclusion'] = l$conclusion == null
          ? null
          : fromJson$Enum$CheckConclusionState((l$conclusion as String));
    }
    if (data.containsKey('detailsUrl')) {
      final l$detailsUrl = data['detailsUrl'];
      result$data['detailsUrl'] = (l$detailsUrl as String?);
    }
    if (data.containsKey('externalId')) {
      final l$externalId = data['externalId'];
      result$data['externalId'] = (l$externalId as String?);
    }
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('output')) {
      final l$output = data['output'];
      result$data['output'] = l$output == null
          ? null
          : Input$CheckRunOutput.fromJson((l$output as Map<String, dynamic>));
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$RequestableCheckStatusState((l$status as String));
    }
    return Input$CreateCheckRunInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CheckRunAction>? get actions =>
      (_$data['actions'] as List<Input$CheckRunAction>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);
  Enum$CheckConclusionState? get conclusion =>
      (_$data['conclusion'] as Enum$CheckConclusionState?);
  String? get detailsUrl => (_$data['detailsUrl'] as String?);
  String? get externalId => (_$data['externalId'] as String?);
  String get headSha => (_$data['headSha'] as String);
  String get name => (_$data['name'] as String);
  Input$CheckRunOutput? get output =>
      (_$data['output'] as Input$CheckRunOutput?);
  String get repositoryId => (_$data['repositoryId'] as String);
  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);
  Enum$RequestableCheckStatusState? get status =>
      (_$data['status'] as Enum$RequestableCheckStatusState?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('actions')) {
      final l$actions = actions;
      result$data['actions'] = l$actions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    if (_$data.containsKey('conclusion')) {
      final l$conclusion = conclusion;
      result$data['conclusion'] = l$conclusion == null
          ? null
          : toJson$Enum$CheckConclusionState(l$conclusion);
    }
    if (_$data.containsKey('detailsUrl')) {
      final l$detailsUrl = detailsUrl;
      result$data['detailsUrl'] = l$detailsUrl;
    }
    if (_$data.containsKey('externalId')) {
      final l$externalId = externalId;
      result$data['externalId'] = l$externalId;
    }
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('output')) {
      final l$output = output;
      result$data['output'] = l$output?.toJson();
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$RequestableCheckStatusState(l$status);
    }
    return result$data;
  }

  CopyWith$Input$CreateCheckRunInput<Input$CreateCheckRunInput> get copyWith =>
      CopyWith$Input$CreateCheckRunInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCheckRunInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$actions = actions;
    final lOther$actions = other.actions;
    if (_$data.containsKey('actions') != other._$data.containsKey('actions')) {
      return false;
    }
    if (l$actions != null && lOther$actions != null) {
      if (l$actions.length != lOther$actions.length) {
        return false;
      }
      for (int i = 0; i < l$actions.length; i++) {
        final l$actions$entry = l$actions[i];
        final lOther$actions$entry = lOther$actions[i];
        if (l$actions$entry != lOther$actions$entry) {
          return false;
        }
      }
    } else if (l$actions != lOther$actions) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$conclusion = conclusion;
    final lOther$conclusion = other.conclusion;
    if (_$data.containsKey('conclusion') !=
        other._$data.containsKey('conclusion')) {
      return false;
    }
    if (l$conclusion != lOther$conclusion) {
      return false;
    }
    final l$detailsUrl = detailsUrl;
    final lOther$detailsUrl = other.detailsUrl;
    if (_$data.containsKey('detailsUrl') !=
        other._$data.containsKey('detailsUrl')) {
      return false;
    }
    if (l$detailsUrl != lOther$detailsUrl) {
      return false;
    }
    final l$externalId = externalId;
    final lOther$externalId = other.externalId;
    if (_$data.containsKey('externalId') !=
        other._$data.containsKey('externalId')) {
      return false;
    }
    if (l$externalId != lOther$externalId) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$output = output;
    final lOther$output = other.output;
    if (_$data.containsKey('output') != other._$data.containsKey('output')) {
      return false;
    }
    if (l$output != lOther$output) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$actions = actions;
    final l$clientMutationId = clientMutationId;
    final l$completedAt = completedAt;
    final l$conclusion = conclusion;
    final l$detailsUrl = detailsUrl;
    final l$externalId = externalId;
    final l$headSha = headSha;
    final l$name = name;
    final l$output = output;
    final l$repositoryId = repositoryId;
    final l$startedAt = startedAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('actions')
          ? l$actions == null
              ? null
              : Object.hashAll(l$actions.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('conclusion') ? l$conclusion : const {},
      _$data.containsKey('detailsUrl') ? l$detailsUrl : const {},
      _$data.containsKey('externalId') ? l$externalId : const {},
      l$headSha,
      l$name,
      _$data.containsKey('output') ? l$output : const {},
      l$repositoryId,
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateCheckRunInput<TRes> {
  factory CopyWith$Input$CreateCheckRunInput(
    Input$CreateCheckRunInput instance,
    TRes Function(Input$CreateCheckRunInput) then,
  ) = _CopyWithImpl$Input$CreateCheckRunInput;

  factory CopyWith$Input$CreateCheckRunInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCheckRunInput;

  TRes call({
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
    DateTime? completedAt,
    Enum$CheckConclusionState? conclusion,
    String? detailsUrl,
    String? externalId,
    String? headSha,
    String? name,
    Input$CheckRunOutput? output,
    String? repositoryId,
    DateTime? startedAt,
    Enum$RequestableCheckStatusState? status,
  });
  TRes actions(
      Iterable<Input$CheckRunAction>? Function(
              Iterable<CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
          _fn);
  CopyWith$Input$CheckRunOutput<TRes> get output;
}

class _CopyWithImpl$Input$CreateCheckRunInput<TRes>
    implements CopyWith$Input$CreateCheckRunInput<TRes> {
  _CopyWithImpl$Input$CreateCheckRunInput(
    this._instance,
    this._then,
  );

  final Input$CreateCheckRunInput _instance;

  final TRes Function(Input$CreateCheckRunInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? actions = _undefined,
    Object? clientMutationId = _undefined,
    Object? completedAt = _undefined,
    Object? conclusion = _undefined,
    Object? detailsUrl = _undefined,
    Object? externalId = _undefined,
    Object? headSha = _undefined,
    Object? name = _undefined,
    Object? output = _undefined,
    Object? repositoryId = _undefined,
    Object? startedAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$CreateCheckRunInput._({
        ..._instance._$data,
        if (actions != _undefined)
          'actions': (actions as List<Input$CheckRunAction>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
        if (conclusion != _undefined)
          'conclusion': (conclusion as Enum$CheckConclusionState?),
        if (detailsUrl != _undefined) 'detailsUrl': (detailsUrl as String?),
        if (externalId != _undefined) 'externalId': (externalId as String?),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
        if (name != _undefined && name != null) 'name': (name as String),
        if (output != _undefined) 'output': (output as Input$CheckRunOutput?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (status != _undefined)
          'status': (status as Enum$RequestableCheckStatusState?),
      }));
  TRes actions(
          Iterable<Input$CheckRunAction>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
              _fn) =>
      call(
          actions:
              _fn(_instance.actions?.map((e) => CopyWith$Input$CheckRunAction(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$CheckRunOutput<TRes> get output {
    final local$output = _instance.output;
    return local$output == null
        ? CopyWith$Input$CheckRunOutput.stub(_then(_instance))
        : CopyWith$Input$CheckRunOutput(local$output, (e) => call(output: e));
  }
}

class _CopyWithStubImpl$Input$CreateCheckRunInput<TRes>
    implements CopyWith$Input$CreateCheckRunInput<TRes> {
  _CopyWithStubImpl$Input$CreateCheckRunInput(this._res);

  TRes _res;

  call({
    List<Input$CheckRunAction>? actions,
    String? clientMutationId,
    DateTime? completedAt,
    Enum$CheckConclusionState? conclusion,
    String? detailsUrl,
    String? externalId,
    String? headSha,
    String? name,
    Input$CheckRunOutput? output,
    String? repositoryId,
    DateTime? startedAt,
    Enum$RequestableCheckStatusState? status,
  }) =>
      _res;
  actions(_fn) => _res;
  CopyWith$Input$CheckRunOutput<TRes> get output =>
      CopyWith$Input$CheckRunOutput.stub(_res);
}

class Input$CreateCheckSuiteInput {
  factory Input$CreateCheckSuiteInput({
    String? clientMutationId,
    required String headSha,
    required String repositoryId,
  }) =>
      Input$CreateCheckSuiteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'headSha': headSha,
        r'repositoryId': repositoryId,
      });

  Input$CreateCheckSuiteInput._(this._$data);

  factory Input$CreateCheckSuiteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$headSha = data['headSha'];
    result$data['headSha'] = (l$headSha as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$CreateCheckSuiteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get headSha => (_$data['headSha'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$headSha = headSha;
    result$data['headSha'] = l$headSha;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$CreateCheckSuiteInput<Input$CreateCheckSuiteInput>
      get copyWith => CopyWith$Input$CreateCheckSuiteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCheckSuiteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$headSha = headSha;
    final lOther$headSha = other.headSha;
    if (l$headSha != lOther$headSha) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$headSha = headSha;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$headSha,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$CreateCheckSuiteInput<TRes> {
  factory CopyWith$Input$CreateCheckSuiteInput(
    Input$CreateCheckSuiteInput instance,
    TRes Function(Input$CreateCheckSuiteInput) then,
  ) = _CopyWithImpl$Input$CreateCheckSuiteInput;

  factory CopyWith$Input$CreateCheckSuiteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCheckSuiteInput;

  TRes call({
    String? clientMutationId,
    String? headSha,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$CreateCheckSuiteInput<TRes>
    implements CopyWith$Input$CreateCheckSuiteInput<TRes> {
  _CopyWithImpl$Input$CreateCheckSuiteInput(
    this._instance,
    this._then,
  );

  final Input$CreateCheckSuiteInput _instance;

  final TRes Function(Input$CreateCheckSuiteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? headSha = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$CreateCheckSuiteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (headSha != _undefined && headSha != null)
          'headSha': (headSha as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateCheckSuiteInput<TRes>
    implements CopyWith$Input$CreateCheckSuiteInput<TRes> {
  _CopyWithStubImpl$Input$CreateCheckSuiteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? headSha,
    String? repositoryId,
  }) =>
      _res;
}

class Input$CreateCommitOnBranchInput {
  factory Input$CreateCommitOnBranchInput({
    required Input$CommittableBranch branch,
    String? clientMutationId,
    required String expectedHeadOid,
    Input$FileChanges? fileChanges,
    required Input$CommitMessage message,
  }) =>
      Input$CreateCommitOnBranchInput._({
        r'branch': branch,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'expectedHeadOid': expectedHeadOid,
        if (fileChanges != null) r'fileChanges': fileChanges,
        r'message': message,
      });

  Input$CreateCommitOnBranchInput._(this._$data);

  factory Input$CreateCommitOnBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$branch = data['branch'];
    result$data['branch'] =
        Input$CommittableBranch.fromJson((l$branch as Map<String, dynamic>));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$expectedHeadOid = data['expectedHeadOid'];
    result$data['expectedHeadOid'] = (l$expectedHeadOid as String);
    if (data.containsKey('fileChanges')) {
      final l$fileChanges = data['fileChanges'];
      result$data['fileChanges'] = l$fileChanges == null
          ? null
          : Input$FileChanges.fromJson((l$fileChanges as Map<String, dynamic>));
    }
    final l$message = data['message'];
    result$data['message'] =
        Input$CommitMessage.fromJson((l$message as Map<String, dynamic>));
    return Input$CreateCommitOnBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CommittableBranch get branch =>
      (_$data['branch'] as Input$CommittableBranch);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get expectedHeadOid => (_$data['expectedHeadOid'] as String);
  Input$FileChanges? get fileChanges =>
      (_$data['fileChanges'] as Input$FileChanges?);
  Input$CommitMessage get message => (_$data['message'] as Input$CommitMessage);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$branch = branch;
    result$data['branch'] = l$branch.toJson();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$expectedHeadOid = expectedHeadOid;
    result$data['expectedHeadOid'] = l$expectedHeadOid;
    if (_$data.containsKey('fileChanges')) {
      final l$fileChanges = fileChanges;
      result$data['fileChanges'] = l$fileChanges?.toJson();
    }
    final l$message = message;
    result$data['message'] = l$message.toJson();
    return result$data;
  }

  CopyWith$Input$CreateCommitOnBranchInput<Input$CreateCommitOnBranchInput>
      get copyWith => CopyWith$Input$CreateCommitOnBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateCommitOnBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$branch = branch;
    final lOther$branch = other.branch;
    if (l$branch != lOther$branch) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$fileChanges = fileChanges;
    final lOther$fileChanges = other.fileChanges;
    if (_$data.containsKey('fileChanges') !=
        other._$data.containsKey('fileChanges')) {
      return false;
    }
    if (l$fileChanges != lOther$fileChanges) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$branch = branch;
    final l$clientMutationId = clientMutationId;
    final l$expectedHeadOid = expectedHeadOid;
    final l$fileChanges = fileChanges;
    final l$message = message;
    return Object.hashAll([
      l$branch,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$expectedHeadOid,
      _$data.containsKey('fileChanges') ? l$fileChanges : const {},
      l$message,
    ]);
  }
}

abstract class CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  factory CopyWith$Input$CreateCommitOnBranchInput(
    Input$CreateCommitOnBranchInput instance,
    TRes Function(Input$CreateCommitOnBranchInput) then,
  ) = _CopyWithImpl$Input$CreateCommitOnBranchInput;

  factory CopyWith$Input$CreateCommitOnBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateCommitOnBranchInput;

  TRes call({
    Input$CommittableBranch? branch,
    String? clientMutationId,
    String? expectedHeadOid,
    Input$FileChanges? fileChanges,
    Input$CommitMessage? message,
  });
  CopyWith$Input$CommittableBranch<TRes> get branch;
  CopyWith$Input$FileChanges<TRes> get fileChanges;
  CopyWith$Input$CommitMessage<TRes> get message;
}

class _CopyWithImpl$Input$CreateCommitOnBranchInput<TRes>
    implements CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  _CopyWithImpl$Input$CreateCommitOnBranchInput(
    this._instance,
    this._then,
  );

  final Input$CreateCommitOnBranchInput _instance;

  final TRes Function(Input$CreateCommitOnBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? branch = _undefined,
    Object? clientMutationId = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? fileChanges = _undefined,
    Object? message = _undefined,
  }) =>
      _then(Input$CreateCommitOnBranchInput._({
        ..._instance._$data,
        if (branch != _undefined && branch != null)
          'branch': (branch as Input$CommittableBranch),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (expectedHeadOid != _undefined && expectedHeadOid != null)
          'expectedHeadOid': (expectedHeadOid as String),
        if (fileChanges != _undefined)
          'fileChanges': (fileChanges as Input$FileChanges?),
        if (message != _undefined && message != null)
          'message': (message as Input$CommitMessage),
      }));
  CopyWith$Input$CommittableBranch<TRes> get branch {
    final local$branch = _instance.branch;
    return CopyWith$Input$CommittableBranch(
        local$branch, (e) => call(branch: e));
  }

  CopyWith$Input$FileChanges<TRes> get fileChanges {
    final local$fileChanges = _instance.fileChanges;
    return local$fileChanges == null
        ? CopyWith$Input$FileChanges.stub(_then(_instance))
        : CopyWith$Input$FileChanges(
            local$fileChanges, (e) => call(fileChanges: e));
  }

  CopyWith$Input$CommitMessage<TRes> get message {
    final local$message = _instance.message;
    return CopyWith$Input$CommitMessage(local$message, (e) => call(message: e));
  }
}

class _CopyWithStubImpl$Input$CreateCommitOnBranchInput<TRes>
    implements CopyWith$Input$CreateCommitOnBranchInput<TRes> {
  _CopyWithStubImpl$Input$CreateCommitOnBranchInput(this._res);

  TRes _res;

  call({
    Input$CommittableBranch? branch,
    String? clientMutationId,
    String? expectedHeadOid,
    Input$FileChanges? fileChanges,
    Input$CommitMessage? message,
  }) =>
      _res;
  CopyWith$Input$CommittableBranch<TRes> get branch =>
      CopyWith$Input$CommittableBranch.stub(_res);
  CopyWith$Input$FileChanges<TRes> get fileChanges =>
      CopyWith$Input$FileChanges.stub(_res);
  CopyWith$Input$CommitMessage<TRes> get message =>
      CopyWith$Input$CommitMessage.stub(_res);
}

class Input$CreateDeploymentInput {
  factory Input$CreateDeploymentInput({
    bool? autoMerge,
    String? clientMutationId,
    String? description,
    String? environment,
    String? payload,
    required String refId,
    required String repositoryId,
    List<String>? requiredContexts,
    String? task,
  }) =>
      Input$CreateDeploymentInput._({
        if (autoMerge != null) r'autoMerge': autoMerge,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (description != null) r'description': description,
        if (environment != null) r'environment': environment,
        if (payload != null) r'payload': payload,
        r'refId': refId,
        r'repositoryId': repositoryId,
        if (requiredContexts != null) r'requiredContexts': requiredContexts,
        if (task != null) r'task': task,
      });

  Input$CreateDeploymentInput._(this._$data);

  factory Input$CreateDeploymentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('autoMerge')) {
      final l$autoMerge = data['autoMerge'];
      result$data['autoMerge'] = (l$autoMerge as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('environment')) {
      final l$environment = data['environment'];
      result$data['environment'] = (l$environment as String?);
    }
    if (data.containsKey('payload')) {
      final l$payload = data['payload'];
      result$data['payload'] = (l$payload as String?);
    }
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('requiredContexts')) {
      final l$requiredContexts = data['requiredContexts'];
      result$data['requiredContexts'] = (l$requiredContexts as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('task')) {
      final l$task = data['task'];
      result$data['task'] = (l$task as String?);
    }
    return Input$CreateDeploymentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get autoMerge => (_$data['autoMerge'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get description => (_$data['description'] as String?);
  String? get environment => (_$data['environment'] as String?);
  String? get payload => (_$data['payload'] as String?);
  String get refId => (_$data['refId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  List<String>? get requiredContexts =>
      (_$data['requiredContexts'] as List<String>?);
  String? get task => (_$data['task'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('autoMerge')) {
      final l$autoMerge = autoMerge;
      result$data['autoMerge'] = l$autoMerge;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('environment')) {
      final l$environment = environment;
      result$data['environment'] = l$environment;
    }
    if (_$data.containsKey('payload')) {
      final l$payload = payload;
      result$data['payload'] = l$payload;
    }
    final l$refId = refId;
    result$data['refId'] = l$refId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('requiredContexts')) {
      final l$requiredContexts = requiredContexts;
      result$data['requiredContexts'] =
          l$requiredContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('task')) {
      final l$task = task;
      result$data['task'] = l$task;
    }
    return result$data;
  }

  CopyWith$Input$CreateDeploymentInput<Input$CreateDeploymentInput>
      get copyWith => CopyWith$Input$CreateDeploymentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateDeploymentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$autoMerge = autoMerge;
    final lOther$autoMerge = other.autoMerge;
    if (_$data.containsKey('autoMerge') !=
        other._$data.containsKey('autoMerge')) {
      return false;
    }
    if (l$autoMerge != lOther$autoMerge) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$environment = environment;
    final lOther$environment = other.environment;
    if (_$data.containsKey('environment') !=
        other._$data.containsKey('environment')) {
      return false;
    }
    if (l$environment != lOther$environment) {
      return false;
    }
    final l$payload = payload;
    final lOther$payload = other.payload;
    if (_$data.containsKey('payload') != other._$data.containsKey('payload')) {
      return false;
    }
    if (l$payload != lOther$payload) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$requiredContexts = requiredContexts;
    final lOther$requiredContexts = other.requiredContexts;
    if (_$data.containsKey('requiredContexts') !=
        other._$data.containsKey('requiredContexts')) {
      return false;
    }
    if (l$requiredContexts != null && lOther$requiredContexts != null) {
      if (l$requiredContexts.length != lOther$requiredContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredContexts.length; i++) {
        final l$requiredContexts$entry = l$requiredContexts[i];
        final lOther$requiredContexts$entry = lOther$requiredContexts[i];
        if (l$requiredContexts$entry != lOther$requiredContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredContexts != lOther$requiredContexts) {
      return false;
    }
    final l$task = task;
    final lOther$task = other.task;
    if (_$data.containsKey('task') != other._$data.containsKey('task')) {
      return false;
    }
    if (l$task != lOther$task) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$autoMerge = autoMerge;
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$environment = environment;
    final l$payload = payload;
    final l$refId = refId;
    final l$repositoryId = repositoryId;
    final l$requiredContexts = requiredContexts;
    final l$task = task;
    return Object.hashAll([
      _$data.containsKey('autoMerge') ? l$autoMerge : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('environment') ? l$environment : const {},
      _$data.containsKey('payload') ? l$payload : const {},
      l$refId,
      l$repositoryId,
      _$data.containsKey('requiredContexts')
          ? l$requiredContexts == null
              ? null
              : Object.hashAll(l$requiredContexts.map((v) => v))
          : const {},
      _$data.containsKey('task') ? l$task : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateDeploymentInput<TRes> {
  factory CopyWith$Input$CreateDeploymentInput(
    Input$CreateDeploymentInput instance,
    TRes Function(Input$CreateDeploymentInput) then,
  ) = _CopyWithImpl$Input$CreateDeploymentInput;

  factory CopyWith$Input$CreateDeploymentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDeploymentInput;

  TRes call({
    bool? autoMerge,
    String? clientMutationId,
    String? description,
    String? environment,
    String? payload,
    String? refId,
    String? repositoryId,
    List<String>? requiredContexts,
    String? task,
  });
}

class _CopyWithImpl$Input$CreateDeploymentInput<TRes>
    implements CopyWith$Input$CreateDeploymentInput<TRes> {
  _CopyWithImpl$Input$CreateDeploymentInput(
    this._instance,
    this._then,
  );

  final Input$CreateDeploymentInput _instance;

  final TRes Function(Input$CreateDeploymentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? autoMerge = _undefined,
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? environment = _undefined,
    Object? payload = _undefined,
    Object? refId = _undefined,
    Object? repositoryId = _undefined,
    Object? requiredContexts = _undefined,
    Object? task = _undefined,
  }) =>
      _then(Input$CreateDeploymentInput._({
        ..._instance._$data,
        if (autoMerge != _undefined) 'autoMerge': (autoMerge as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (environment != _undefined) 'environment': (environment as String?),
        if (payload != _undefined) 'payload': (payload as String?),
        if (refId != _undefined && refId != null) 'refId': (refId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (requiredContexts != _undefined)
          'requiredContexts': (requiredContexts as List<String>?),
        if (task != _undefined) 'task': (task as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateDeploymentInput<TRes>
    implements CopyWith$Input$CreateDeploymentInput<TRes> {
  _CopyWithStubImpl$Input$CreateDeploymentInput(this._res);

  TRes _res;

  call({
    bool? autoMerge,
    String? clientMutationId,
    String? description,
    String? environment,
    String? payload,
    String? refId,
    String? repositoryId,
    List<String>? requiredContexts,
    String? task,
  }) =>
      _res;
}

class Input$CreateDeploymentStatusInput {
  factory Input$CreateDeploymentStatusInput({
    bool? autoInactive,
    String? clientMutationId,
    required String deploymentId,
    String? description,
    String? environment,
    String? environmentUrl,
    String? logUrl,
    required Enum$DeploymentStatusState state,
  }) =>
      Input$CreateDeploymentStatusInput._({
        if (autoInactive != null) r'autoInactive': autoInactive,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'deploymentId': deploymentId,
        if (description != null) r'description': description,
        if (environment != null) r'environment': environment,
        if (environmentUrl != null) r'environmentUrl': environmentUrl,
        if (logUrl != null) r'logUrl': logUrl,
        r'state': state,
      });

  Input$CreateDeploymentStatusInput._(this._$data);

  factory Input$CreateDeploymentStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('autoInactive')) {
      final l$autoInactive = data['autoInactive'];
      result$data['autoInactive'] = (l$autoInactive as bool?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$deploymentId = data['deploymentId'];
    result$data['deploymentId'] = (l$deploymentId as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('environment')) {
      final l$environment = data['environment'];
      result$data['environment'] = (l$environment as String?);
    }
    if (data.containsKey('environmentUrl')) {
      final l$environmentUrl = data['environmentUrl'];
      result$data['environmentUrl'] = (l$environmentUrl as String?);
    }
    if (data.containsKey('logUrl')) {
      final l$logUrl = data['logUrl'];
      result$data['logUrl'] = (l$logUrl as String?);
    }
    final l$state = data['state'];
    result$data['state'] =
        fromJson$Enum$DeploymentStatusState((l$state as String));
    return Input$CreateDeploymentStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get autoInactive => (_$data['autoInactive'] as bool?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get deploymentId => (_$data['deploymentId'] as String);
  String? get description => (_$data['description'] as String?);
  String? get environment => (_$data['environment'] as String?);
  String? get environmentUrl => (_$data['environmentUrl'] as String?);
  String? get logUrl => (_$data['logUrl'] as String?);
  Enum$DeploymentStatusState get state =>
      (_$data['state'] as Enum$DeploymentStatusState);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('autoInactive')) {
      final l$autoInactive = autoInactive;
      result$data['autoInactive'] = l$autoInactive;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$deploymentId = deploymentId;
    result$data['deploymentId'] = l$deploymentId;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('environment')) {
      final l$environment = environment;
      result$data['environment'] = l$environment;
    }
    if (_$data.containsKey('environmentUrl')) {
      final l$environmentUrl = environmentUrl;
      result$data['environmentUrl'] = l$environmentUrl;
    }
    if (_$data.containsKey('logUrl')) {
      final l$logUrl = logUrl;
      result$data['logUrl'] = l$logUrl;
    }
    final l$state = state;
    result$data['state'] = toJson$Enum$DeploymentStatusState(l$state);
    return result$data;
  }

  CopyWith$Input$CreateDeploymentStatusInput<Input$CreateDeploymentStatusInput>
      get copyWith => CopyWith$Input$CreateDeploymentStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateDeploymentStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$autoInactive = autoInactive;
    final lOther$autoInactive = other.autoInactive;
    if (_$data.containsKey('autoInactive') !=
        other._$data.containsKey('autoInactive')) {
      return false;
    }
    if (l$autoInactive != lOther$autoInactive) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$deploymentId = deploymentId;
    final lOther$deploymentId = other.deploymentId;
    if (l$deploymentId != lOther$deploymentId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$environment = environment;
    final lOther$environment = other.environment;
    if (_$data.containsKey('environment') !=
        other._$data.containsKey('environment')) {
      return false;
    }
    if (l$environment != lOther$environment) {
      return false;
    }
    final l$environmentUrl = environmentUrl;
    final lOther$environmentUrl = other.environmentUrl;
    if (_$data.containsKey('environmentUrl') !=
        other._$data.containsKey('environmentUrl')) {
      return false;
    }
    if (l$environmentUrl != lOther$environmentUrl) {
      return false;
    }
    final l$logUrl = logUrl;
    final lOther$logUrl = other.logUrl;
    if (_$data.containsKey('logUrl') != other._$data.containsKey('logUrl')) {
      return false;
    }
    if (l$logUrl != lOther$logUrl) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (l$state != lOther$state) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$autoInactive = autoInactive;
    final l$clientMutationId = clientMutationId;
    final l$deploymentId = deploymentId;
    final l$description = description;
    final l$environment = environment;
    final l$environmentUrl = environmentUrl;
    final l$logUrl = logUrl;
    final l$state = state;
    return Object.hashAll([
      _$data.containsKey('autoInactive') ? l$autoInactive : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$deploymentId,
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('environment') ? l$environment : const {},
      _$data.containsKey('environmentUrl') ? l$environmentUrl : const {},
      _$data.containsKey('logUrl') ? l$logUrl : const {},
      l$state,
    ]);
  }
}

abstract class CopyWith$Input$CreateDeploymentStatusInput<TRes> {
  factory CopyWith$Input$CreateDeploymentStatusInput(
    Input$CreateDeploymentStatusInput instance,
    TRes Function(Input$CreateDeploymentStatusInput) then,
  ) = _CopyWithImpl$Input$CreateDeploymentStatusInput;

  factory CopyWith$Input$CreateDeploymentStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDeploymentStatusInput;

  TRes call({
    bool? autoInactive,
    String? clientMutationId,
    String? deploymentId,
    String? description,
    String? environment,
    String? environmentUrl,
    String? logUrl,
    Enum$DeploymentStatusState? state,
  });
}

class _CopyWithImpl$Input$CreateDeploymentStatusInput<TRes>
    implements CopyWith$Input$CreateDeploymentStatusInput<TRes> {
  _CopyWithImpl$Input$CreateDeploymentStatusInput(
    this._instance,
    this._then,
  );

  final Input$CreateDeploymentStatusInput _instance;

  final TRes Function(Input$CreateDeploymentStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? autoInactive = _undefined,
    Object? clientMutationId = _undefined,
    Object? deploymentId = _undefined,
    Object? description = _undefined,
    Object? environment = _undefined,
    Object? environmentUrl = _undefined,
    Object? logUrl = _undefined,
    Object? state = _undefined,
  }) =>
      _then(Input$CreateDeploymentStatusInput._({
        ..._instance._$data,
        if (autoInactive != _undefined) 'autoInactive': (autoInactive as bool?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (deploymentId != _undefined && deploymentId != null)
          'deploymentId': (deploymentId as String),
        if (description != _undefined) 'description': (description as String?),
        if (environment != _undefined) 'environment': (environment as String?),
        if (environmentUrl != _undefined)
          'environmentUrl': (environmentUrl as String?),
        if (logUrl != _undefined) 'logUrl': (logUrl as String?),
        if (state != _undefined && state != null)
          'state': (state as Enum$DeploymentStatusState),
      }));
}

class _CopyWithStubImpl$Input$CreateDeploymentStatusInput<TRes>
    implements CopyWith$Input$CreateDeploymentStatusInput<TRes> {
  _CopyWithStubImpl$Input$CreateDeploymentStatusInput(this._res);

  TRes _res;

  call({
    bool? autoInactive,
    String? clientMutationId,
    String? deploymentId,
    String? description,
    String? environment,
    String? environmentUrl,
    String? logUrl,
    Enum$DeploymentStatusState? state,
  }) =>
      _res;
}

class Input$CreateDiscussionInput {
  factory Input$CreateDiscussionInput({
    required String body,
    required String categoryId,
    String? clientMutationId,
    required String repositoryId,
    required String title,
  }) =>
      Input$CreateDiscussionInput._({
        r'body': body,
        r'categoryId': categoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'title': title,
      });

  Input$CreateDiscussionInput._(this._$data);

  factory Input$CreateDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    final l$categoryId = data['categoryId'];
    result$data['categoryId'] = (l$categoryId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$CreateDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String get categoryId => (_$data['categoryId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    final l$categoryId = categoryId;
    result$data['categoryId'] = l$categoryId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$CreateDiscussionInput<Input$CreateDiscussionInput>
      get copyWith => CopyWith$Input$CreateDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$categoryId = categoryId;
    final lOther$categoryId = other.categoryId;
    if (l$categoryId != lOther$categoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$categoryId = categoryId;
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$title = title;
    return Object.hashAll([
      l$body,
      l$categoryId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$CreateDiscussionInput<TRes> {
  factory CopyWith$Input$CreateDiscussionInput(
    Input$CreateDiscussionInput instance,
    TRes Function(Input$CreateDiscussionInput) then,
  ) = _CopyWithImpl$Input$CreateDiscussionInput;

  factory CopyWith$Input$CreateDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateDiscussionInput;

  TRes call({
    String? body,
    String? categoryId,
    String? clientMutationId,
    String? repositoryId,
    String? title,
  });
}

class _CopyWithImpl$Input$CreateDiscussionInput<TRes>
    implements CopyWith$Input$CreateDiscussionInput<TRes> {
  _CopyWithImpl$Input$CreateDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CreateDiscussionInput _instance;

  final TRes Function(Input$CreateDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? categoryId = _undefined,
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CreateDiscussionInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (categoryId != _undefined && categoryId != null)
          'categoryId': (categoryId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$CreateDiscussionInput<TRes>
    implements CopyWith$Input$CreateDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CreateDiscussionInput(this._res);

  TRes _res;

  call({
    String? body,
    String? categoryId,
    String? clientMutationId,
    String? repositoryId,
    String? title,
  }) =>
      _res;
}

class Input$CreateEnterpriseOrganizationInput {
  factory Input$CreateEnterpriseOrganizationInput({
    required List<String> adminLogins,
    required String billingEmail,
    String? clientMutationId,
    required String enterpriseId,
    required String login,
    required String profileName,
  }) =>
      Input$CreateEnterpriseOrganizationInput._({
        r'adminLogins': adminLogins,
        r'billingEmail': billingEmail,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
        r'profileName': profileName,
      });

  Input$CreateEnterpriseOrganizationInput._(this._$data);

  factory Input$CreateEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$adminLogins = data['adminLogins'];
    result$data['adminLogins'] =
        (l$adminLogins as List<dynamic>).map((e) => (e as String)).toList();
    final l$billingEmail = data['billingEmail'];
    result$data['billingEmail'] = (l$billingEmail as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    final l$profileName = data['profileName'];
    result$data['profileName'] = (l$profileName as String);
    return Input$CreateEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String> get adminLogins => (_$data['adminLogins'] as List<String>);
  String get billingEmail => (_$data['billingEmail'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  String get profileName => (_$data['profileName'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$adminLogins = adminLogins;
    result$data['adminLogins'] = l$adminLogins.map((e) => e).toList();
    final l$billingEmail = billingEmail;
    result$data['billingEmail'] = l$billingEmail;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    final l$profileName = profileName;
    result$data['profileName'] = l$profileName;
    return result$data;
  }

  CopyWith$Input$CreateEnterpriseOrganizationInput<
          Input$CreateEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$CreateEnterpriseOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateEnterpriseOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$adminLogins = adminLogins;
    final lOther$adminLogins = other.adminLogins;
    if (l$adminLogins.length != lOther$adminLogins.length) {
      return false;
    }
    for (int i = 0; i < l$adminLogins.length; i++) {
      final l$adminLogins$entry = l$adminLogins[i];
      final lOther$adminLogins$entry = lOther$adminLogins[i];
      if (l$adminLogins$entry != lOther$adminLogins$entry) {
        return false;
      }
    }
    final l$billingEmail = billingEmail;
    final lOther$billingEmail = other.billingEmail;
    if (l$billingEmail != lOther$billingEmail) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$profileName = profileName;
    final lOther$profileName = other.profileName;
    if (l$profileName != lOther$profileName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$adminLogins = adminLogins;
    final l$billingEmail = billingEmail;
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$profileName = profileName;
    return Object.hashAll([
      Object.hashAll(l$adminLogins.map((v) => v)),
      l$billingEmail,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
      l$profileName,
    ]);
  }
}

abstract class CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$CreateEnterpriseOrganizationInput(
    Input$CreateEnterpriseOrganizationInput instance,
    TRes Function(Input$CreateEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$CreateEnterpriseOrganizationInput;

  factory CopyWith$Input$CreateEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput;

  TRes call({
    List<String>? adminLogins,
    String? billingEmail,
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    String? profileName,
  });
}

class _CopyWithImpl$Input$CreateEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$CreateEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnterpriseOrganizationInput _instance;

  final TRes Function(Input$CreateEnterpriseOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? adminLogins = _undefined,
    Object? billingEmail = _undefined,
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? profileName = _undefined,
  }) =>
      _then(Input$CreateEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (adminLogins != _undefined && adminLogins != null)
          'adminLogins': (adminLogins as List<String>),
        if (billingEmail != _undefined && billingEmail != null)
          'billingEmail': (billingEmail as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (profileName != _undefined && profileName != null)
          'profileName': (profileName as String),
      }));
}

class _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$CreateEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    List<String>? adminLogins,
    String? billingEmail,
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    String? profileName,
  }) =>
      _res;
}

class Input$CreateEnvironmentInput {
  factory Input$CreateEnvironmentInput({
    String? clientMutationId,
    required String name,
    required String repositoryId,
  }) =>
      Input$CreateEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'repositoryId': repositoryId,
      });

  Input$CreateEnvironmentInput._(this._$data);

  factory Input$CreateEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$CreateEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$CreateEnvironmentInput<Input$CreateEnvironmentInput>
      get copyWith => CopyWith$Input$CreateEnvironmentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateEnvironmentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$CreateEnvironmentInput<TRes> {
  factory CopyWith$Input$CreateEnvironmentInput(
    Input$CreateEnvironmentInput instance,
    TRes Function(Input$CreateEnvironmentInput) then,
  ) = _CopyWithImpl$Input$CreateEnvironmentInput;

  factory CopyWith$Input$CreateEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$CreateEnvironmentInput<TRes>
    implements CopyWith$Input$CreateEnvironmentInput<TRes> {
  _CopyWithImpl$Input$CreateEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$CreateEnvironmentInput _instance;

  final TRes Function(Input$CreateEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$CreateEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateEnvironmentInput<TRes>
    implements CopyWith$Input$CreateEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$CreateEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? repositoryId,
  }) =>
      _res;
}

class Input$CreateIpAllowListEntryInput {
  factory Input$CreateIpAllowListEntryInput({
    required String allowListValue,
    String? clientMutationId,
    required bool isActive,
    String? name,
    required String ownerId,
  }) =>
      Input$CreateIpAllowListEntryInput._({
        r'allowListValue': allowListValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'isActive': isActive,
        if (name != null) r'name': name,
        r'ownerId': ownerId,
      });

  Input$CreateIpAllowListEntryInput._(this._$data);

  factory Input$CreateIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$allowListValue = data['allowListValue'];
    result$data['allowListValue'] = (l$allowListValue as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    return Input$CreateIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get allowListValue => (_$data['allowListValue'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get isActive => (_$data['isActive'] as bool);
  String? get name => (_$data['name'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$allowListValue = allowListValue;
    result$data['allowListValue'] = l$allowListValue;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    return result$data;
  }

  CopyWith$Input$CreateIpAllowListEntryInput<Input$CreateIpAllowListEntryInput>
      get copyWith => CopyWith$Input$CreateIpAllowListEntryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateIpAllowListEntryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$allowListValue = allowListValue;
    final lOther$allowListValue = other.allowListValue;
    if (l$allowListValue != lOther$allowListValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$allowListValue = allowListValue;
    final l$clientMutationId = clientMutationId;
    final l$isActive = isActive;
    final l$name = name;
    final l$ownerId = ownerId;
    return Object.hashAll([
      l$allowListValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$isActive,
      _$data.containsKey('name') ? l$name : const {},
      l$ownerId,
    ]);
  }
}

abstract class CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$CreateIpAllowListEntryInput(
    Input$CreateIpAllowListEntryInput instance,
    TRes Function(Input$CreateIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$CreateIpAllowListEntryInput;

  factory CopyWith$Input$CreateIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIpAllowListEntryInput;

  TRes call({
    String? allowListValue,
    String? clientMutationId,
    bool? isActive,
    String? name,
    String? ownerId,
  });
}

class _CopyWithImpl$Input$CreateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$CreateIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$CreateIpAllowListEntryInput _instance;

  final TRes Function(Input$CreateIpAllowListEntryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? allowListValue = _undefined,
    Object? clientMutationId = _undefined,
    Object? isActive = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
  }) =>
      _then(Input$CreateIpAllowListEntryInput._({
        ..._instance._$data,
        if (allowListValue != _undefined && allowListValue != null)
          'allowListValue': (allowListValue as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
        if (name != _undefined) 'name': (name as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$CreateIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$CreateIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? allowListValue,
    String? clientMutationId,
    bool? isActive,
    String? name,
    String? ownerId,
  }) =>
      _res;
}

class Input$CreateIssueInput {
  factory Input$CreateIssueInput({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? issueTemplate,
    List<String>? labelIds,
    String? milestoneId,
    List<String>? projectIds,
    required String repositoryId,
    required String title,
  }) =>
      Input$CreateIssueInput._({
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (issueTemplate != null) r'issueTemplate': issueTemplate,
        if (labelIds != null) r'labelIds': labelIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (projectIds != null) r'projectIds': projectIds,
        r'repositoryId': repositoryId,
        r'title': title,
      });

  Input$CreateIssueInput._(this._$data);

  factory Input$CreateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('issueTemplate')) {
      final l$issueTemplate = data['issueTemplate'];
      result$data['issueTemplate'] = (l$issueTemplate as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$CreateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get issueTemplate => (_$data['issueTemplate'] as String?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);
  String get repositoryId => (_$data['repositoryId'] as String);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('issueTemplate')) {
      final l$issueTemplate = issueTemplate;
      result$data['issueTemplate'] = l$issueTemplate;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$CreateIssueInput<Input$CreateIssueInput> get copyWith =>
      CopyWith$Input$CreateIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueTemplate = issueTemplate;
    final lOther$issueTemplate = other.issueTemplate;
    if (_$data.containsKey('issueTemplate') !=
        other._$data.containsKey('issueTemplate')) {
      return false;
    }
    if (l$issueTemplate != lOther$issueTemplate) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assigneeIds = assigneeIds;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$issueTemplate = issueTemplate;
    final l$labelIds = labelIds;
    final l$milestoneId = milestoneId;
    final l$projectIds = projectIds;
    final l$repositoryId = repositoryId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('issueTemplate') ? l$issueTemplate : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      l$repositoryId,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$CreateIssueInput<TRes> {
  factory CopyWith$Input$CreateIssueInput(
    Input$CreateIssueInput instance,
    TRes Function(Input$CreateIssueInput) then,
  ) = _CopyWithImpl$Input$CreateIssueInput;

  factory CopyWith$Input$CreateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateIssueInput;

  TRes call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? issueTemplate,
    List<String>? labelIds,
    String? milestoneId,
    List<String>? projectIds,
    String? repositoryId,
    String? title,
  });
}

class _CopyWithImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithImpl$Input$CreateIssueInput(
    this._instance,
    this._then,
  );

  final Input$CreateIssueInput _instance;

  final TRes Function(Input$CreateIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assigneeIds = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? issueTemplate = _undefined,
    Object? labelIds = _undefined,
    Object? milestoneId = _undefined,
    Object? projectIds = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CreateIssueInput._({
        ..._instance._$data,
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueTemplate != _undefined)
          'issueTemplate': (issueTemplate as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$CreateIssueInput<TRes>
    implements CopyWith$Input$CreateIssueInput<TRes> {
  _CopyWithStubImpl$Input$CreateIssueInput(this._res);

  TRes _res;

  call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? issueTemplate,
    List<String>? labelIds,
    String? milestoneId,
    List<String>? projectIds,
    String? repositoryId,
    String? title,
  }) =>
      _res;
}

class Input$CreateLabelInput {
  factory Input$CreateLabelInput({
    String? clientMutationId,
    required String color,
    String? description,
    required String name,
    required String repositoryId,
  }) =>
      Input$CreateLabelInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'color': color,
        if (description != null) r'description': description,
        r'name': name,
        r'repositoryId': repositoryId,
      });

  Input$CreateLabelInput._(this._$data);

  factory Input$CreateLabelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$color = data['color'];
    result$data['color'] = (l$color as String);
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$CreateLabelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get color => (_$data['color'] as String);
  String? get description => (_$data['description'] as String?);
  String get name => (_$data['name'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$color = color;
    result$data['color'] = l$color;
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$CreateLabelInput<Input$CreateLabelInput> get copyWith =>
      CopyWith$Input$CreateLabelInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateLabelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$color = color;
    final l$description = description;
    final l$name = name;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$color,
      _$data.containsKey('description') ? l$description : const {},
      l$name,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$CreateLabelInput<TRes> {
  factory CopyWith$Input$CreateLabelInput(
    Input$CreateLabelInput instance,
    TRes Function(Input$CreateLabelInput) then,
  ) = _CopyWithImpl$Input$CreateLabelInput;

  factory CopyWith$Input$CreateLabelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateLabelInput;

  TRes call({
    String? clientMutationId,
    String? color,
    String? description,
    String? name,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$CreateLabelInput<TRes>
    implements CopyWith$Input$CreateLabelInput<TRes> {
  _CopyWithImpl$Input$CreateLabelInput(
    this._instance,
    this._then,
  );

  final Input$CreateLabelInput _instance;

  final TRes Function(Input$CreateLabelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? color = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$CreateLabelInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (color != _undefined && color != null) 'color': (color as String),
        if (description != _undefined) 'description': (description as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateLabelInput<TRes>
    implements CopyWith$Input$CreateLabelInput<TRes> {
  _CopyWithStubImpl$Input$CreateLabelInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? color,
    String? description,
    String? name,
    String? repositoryId,
  }) =>
      _res;
}

class Input$CreateLinkedBranchInput {
  factory Input$CreateLinkedBranchInput({
    String? clientMutationId,
    required String issueId,
    String? name,
    required String oid,
    String? repositoryId,
  }) =>
      Input$CreateLinkedBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
        if (name != null) r'name': name,
        r'oid': oid,
        if (repositoryId != null) r'repositoryId': repositoryId,
      });

  Input$CreateLinkedBranchInput._(this._$data);

  factory Input$CreateLinkedBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    return Input$CreateLinkedBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get issueId => (_$data['issueId'] as String);
  String? get name => (_$data['name'] as String?);
  String get oid => (_$data['oid'] as String);
  String? get repositoryId => (_$data['repositoryId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$oid = oid;
    result$data['oid'] = l$oid;
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    return result$data;
  }

  CopyWith$Input$CreateLinkedBranchInput<Input$CreateLinkedBranchInput>
      get copyWith => CopyWith$Input$CreateLinkedBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateLinkedBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    final l$name = name;
    final l$oid = oid;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
      _$data.containsKey('name') ? l$name : const {},
      l$oid,
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateLinkedBranchInput<TRes> {
  factory CopyWith$Input$CreateLinkedBranchInput(
    Input$CreateLinkedBranchInput instance,
    TRes Function(Input$CreateLinkedBranchInput) then,
  ) = _CopyWithImpl$Input$CreateLinkedBranchInput;

  factory CopyWith$Input$CreateLinkedBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateLinkedBranchInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
    String? name,
    String? oid,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$CreateLinkedBranchInput<TRes>
    implements CopyWith$Input$CreateLinkedBranchInput<TRes> {
  _CopyWithImpl$Input$CreateLinkedBranchInput(
    this._instance,
    this._then,
  );

  final Input$CreateLinkedBranchInput _instance;

  final TRes Function(Input$CreateLinkedBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
    Object? name = _undefined,
    Object? oid = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$CreateLinkedBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (name != _undefined) 'name': (name as String?),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateLinkedBranchInput<TRes>
    implements CopyWith$Input$CreateLinkedBranchInput<TRes> {
  _CopyWithStubImpl$Input$CreateLinkedBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
    String? name,
    String? oid,
    String? repositoryId,
  }) =>
      _res;
}

class Input$CreateMigrationSourceInput {
  factory Input$CreateMigrationSourceInput({
    String? accessToken,
    String? clientMutationId,
    String? githubPat,
    required String name,
    required String ownerId,
    required Enum$MigrationSourceType type,
    String? url,
  }) =>
      Input$CreateMigrationSourceInput._({
        if (accessToken != null) r'accessToken': accessToken,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (githubPat != null) r'githubPat': githubPat,
        r'name': name,
        r'ownerId': ownerId,
        r'type': type,
        if (url != null) r'url': url,
      });

  Input$CreateMigrationSourceInput._(this._$data);

  factory Input$CreateMigrationSourceInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('githubPat')) {
      final l$githubPat = data['githubPat'];
      result$data['githubPat'] = (l$githubPat as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$type = data['type'];
    result$data['type'] = fromJson$Enum$MigrationSourceType((l$type as String));
    if (data.containsKey('url')) {
      final l$url = data['url'];
      result$data['url'] = (l$url as String?);
    }
    return Input$CreateMigrationSourceInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get accessToken => (_$data['accessToken'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get githubPat => (_$data['githubPat'] as String?);
  String get name => (_$data['name'] as String);
  String get ownerId => (_$data['ownerId'] as String);
  Enum$MigrationSourceType get type =>
      (_$data['type'] as Enum$MigrationSourceType);
  String? get url => (_$data['url'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('githubPat')) {
      final l$githubPat = githubPat;
      result$data['githubPat'] = l$githubPat;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$type = type;
    result$data['type'] = toJson$Enum$MigrationSourceType(l$type);
    if (_$data.containsKey('url')) {
      final l$url = url;
      result$data['url'] = l$url;
    }
    return result$data;
  }

  CopyWith$Input$CreateMigrationSourceInput<Input$CreateMigrationSourceInput>
      get copyWith => CopyWith$Input$CreateMigrationSourceInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateMigrationSourceInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$githubPat = githubPat;
    final lOther$githubPat = other.githubPat;
    if (_$data.containsKey('githubPat') !=
        other._$data.containsKey('githubPat')) {
      return false;
    }
    if (l$githubPat != lOther$githubPat) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$url = url;
    final lOther$url = other.url;
    if (_$data.containsKey('url') != other._$data.containsKey('url')) {
      return false;
    }
    if (l$url != lOther$url) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$clientMutationId = clientMutationId;
    final l$githubPat = githubPat;
    final l$name = name;
    final l$ownerId = ownerId;
    final l$type = type;
    final l$url = url;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('githubPat') ? l$githubPat : const {},
      l$name,
      l$ownerId,
      l$type,
      _$data.containsKey('url') ? l$url : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateMigrationSourceInput<TRes> {
  factory CopyWith$Input$CreateMigrationSourceInput(
    Input$CreateMigrationSourceInput instance,
    TRes Function(Input$CreateMigrationSourceInput) then,
  ) = _CopyWithImpl$Input$CreateMigrationSourceInput;

  factory CopyWith$Input$CreateMigrationSourceInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateMigrationSourceInput;

  TRes call({
    String? accessToken,
    String? clientMutationId,
    String? githubPat,
    String? name,
    String? ownerId,
    Enum$MigrationSourceType? type,
    String? url,
  });
}

class _CopyWithImpl$Input$CreateMigrationSourceInput<TRes>
    implements CopyWith$Input$CreateMigrationSourceInput<TRes> {
  _CopyWithImpl$Input$CreateMigrationSourceInput(
    this._instance,
    this._then,
  );

  final Input$CreateMigrationSourceInput _instance;

  final TRes Function(Input$CreateMigrationSourceInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? accessToken = _undefined,
    Object? clientMutationId = _undefined,
    Object? githubPat = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? type = _undefined,
    Object? url = _undefined,
  }) =>
      _then(Input$CreateMigrationSourceInput._({
        ..._instance._$data,
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (githubPat != _undefined) 'githubPat': (githubPat as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (type != _undefined && type != null)
          'type': (type as Enum$MigrationSourceType),
        if (url != _undefined) 'url': (url as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateMigrationSourceInput<TRes>
    implements CopyWith$Input$CreateMigrationSourceInput<TRes> {
  _CopyWithStubImpl$Input$CreateMigrationSourceInput(this._res);

  TRes _res;

  call({
    String? accessToken,
    String? clientMutationId,
    String? githubPat,
    String? name,
    String? ownerId,
    Enum$MigrationSourceType? type,
    String? url,
  }) =>
      _res;
}

class Input$CreateProjectInput {
  factory Input$CreateProjectInput({
    String? body,
    String? clientMutationId,
    required String name,
    required String ownerId,
    List<String>? repositoryIds,
    Enum$ProjectTemplate? template,
  }) =>
      Input$CreateProjectInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'ownerId': ownerId,
        if (repositoryIds != null) r'repositoryIds': repositoryIds,
        if (template != null) r'template': template,
      });

  Input$CreateProjectInput._(this._$data);

  factory Input$CreateProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    if (data.containsKey('repositoryIds')) {
      final l$repositoryIds = data['repositoryIds'];
      result$data['repositoryIds'] = (l$repositoryIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = l$template == null
          ? null
          : fromJson$Enum$ProjectTemplate((l$template as String));
    }
    return Input$CreateProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get ownerId => (_$data['ownerId'] as String);
  List<String>? get repositoryIds => (_$data['repositoryIds'] as List<String>?);
  Enum$ProjectTemplate? get template =>
      (_$data['template'] as Enum$ProjectTemplate?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    if (_$data.containsKey('repositoryIds')) {
      final l$repositoryIds = repositoryIds;
      result$data['repositoryIds'] = l$repositoryIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] =
          l$template == null ? null : toJson$Enum$ProjectTemplate(l$template);
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectInput<Input$CreateProjectInput> get copyWith =>
      CopyWith$Input$CreateProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$repositoryIds = repositoryIds;
    final lOther$repositoryIds = other.repositoryIds;
    if (_$data.containsKey('repositoryIds') !=
        other._$data.containsKey('repositoryIds')) {
      return false;
    }
    if (l$repositoryIds != null && lOther$repositoryIds != null) {
      if (l$repositoryIds.length != lOther$repositoryIds.length) {
        return false;
      }
      for (int i = 0; i < l$repositoryIds.length; i++) {
        final l$repositoryIds$entry = l$repositoryIds[i];
        final lOther$repositoryIds$entry = lOther$repositoryIds[i];
        if (l$repositoryIds$entry != lOther$repositoryIds$entry) {
          return false;
        }
      }
    } else if (l$repositoryIds != lOther$repositoryIds) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$ownerId = ownerId;
    final l$repositoryIds = repositoryIds;
    final l$template = template;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$ownerId,
      _$data.containsKey('repositoryIds')
          ? l$repositoryIds == null
              ? null
              : Object.hashAll(l$repositoryIds.map((v) => v))
          : const {},
      _$data.containsKey('template') ? l$template : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectInput<TRes> {
  factory CopyWith$Input$CreateProjectInput(
    Input$CreateProjectInput instance,
    TRes Function(Input$CreateProjectInput) then,
  ) = _CopyWithImpl$Input$CreateProjectInput;

  factory CopyWith$Input$CreateProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? name,
    String? ownerId,
    List<String>? repositoryIds,
    Enum$ProjectTemplate? template,
  });
}

class _CopyWithImpl$Input$CreateProjectInput<TRes>
    implements CopyWith$Input$CreateProjectInput<TRes> {
  _CopyWithImpl$Input$CreateProjectInput(
    this._instance,
    this._then,
  );

  final Input$CreateProjectInput _instance;

  final TRes Function(Input$CreateProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? repositoryIds = _undefined,
    Object? template = _undefined,
  }) =>
      _then(Input$CreateProjectInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (repositoryIds != _undefined)
          'repositoryIds': (repositoryIds as List<String>?),
        if (template != _undefined)
          'template': (template as Enum$ProjectTemplate?),
      }));
}

class _CopyWithStubImpl$Input$CreateProjectInput<TRes>
    implements CopyWith$Input$CreateProjectInput<TRes> {
  _CopyWithStubImpl$Input$CreateProjectInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? name,
    String? ownerId,
    List<String>? repositoryIds,
    Enum$ProjectTemplate? template,
  }) =>
      _res;
}

class Input$CreateProjectV2FieldInput {
  factory Input$CreateProjectV2FieldInput({
    String? clientMutationId,
    required Enum$ProjectV2CustomFieldType dataType,
    required String name,
    required String projectId,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
  }) =>
      Input$CreateProjectV2FieldInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'dataType': dataType,
        r'name': name,
        r'projectId': projectId,
        if (singleSelectOptions != null)
          r'singleSelectOptions': singleSelectOptions,
      });

  Input$CreateProjectV2FieldInput._(this._$data);

  factory Input$CreateProjectV2FieldInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$dataType = data['dataType'];
    result$data['dataType'] =
        fromJson$Enum$ProjectV2CustomFieldType((l$dataType as String));
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('singleSelectOptions')) {
      final l$singleSelectOptions = data['singleSelectOptions'];
      result$data['singleSelectOptions'] =
          (l$singleSelectOptions as List<dynamic>?)
              ?.map((e) => Input$ProjectV2SingleSelectFieldOptionInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    return Input$CreateProjectV2FieldInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$ProjectV2CustomFieldType get dataType =>
      (_$data['dataType'] as Enum$ProjectV2CustomFieldType);
  String get name => (_$data['name'] as String);
  String get projectId => (_$data['projectId'] as String);
  List<Input$ProjectV2SingleSelectFieldOptionInput>? get singleSelectOptions =>
      (_$data['singleSelectOptions']
          as List<Input$ProjectV2SingleSelectFieldOptionInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$dataType = dataType;
    result$data['dataType'] = toJson$Enum$ProjectV2CustomFieldType(l$dataType);
    final l$name = name;
    result$data['name'] = l$name;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('singleSelectOptions')) {
      final l$singleSelectOptions = singleSelectOptions;
      result$data['singleSelectOptions'] =
          l$singleSelectOptions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$CreateProjectV2FieldInput<Input$CreateProjectV2FieldInput>
      get copyWith => CopyWith$Input$CreateProjectV2FieldInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateProjectV2FieldInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$dataType = dataType;
    final lOther$dataType = other.dataType;
    if (l$dataType != lOther$dataType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$singleSelectOptions = singleSelectOptions;
    final lOther$singleSelectOptions = other.singleSelectOptions;
    if (_$data.containsKey('singleSelectOptions') !=
        other._$data.containsKey('singleSelectOptions')) {
      return false;
    }
    if (l$singleSelectOptions != null && lOther$singleSelectOptions != null) {
      if (l$singleSelectOptions.length != lOther$singleSelectOptions.length) {
        return false;
      }
      for (int i = 0; i < l$singleSelectOptions.length; i++) {
        final l$singleSelectOptions$entry = l$singleSelectOptions[i];
        final lOther$singleSelectOptions$entry = lOther$singleSelectOptions[i];
        if (l$singleSelectOptions$entry != lOther$singleSelectOptions$entry) {
          return false;
        }
      }
    } else if (l$singleSelectOptions != lOther$singleSelectOptions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$dataType = dataType;
    final l$name = name;
    final l$projectId = projectId;
    final l$singleSelectOptions = singleSelectOptions;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$dataType,
      l$name,
      l$projectId,
      _$data.containsKey('singleSelectOptions')
          ? l$singleSelectOptions == null
              ? null
              : Object.hashAll(l$singleSelectOptions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectV2FieldInput<TRes> {
  factory CopyWith$Input$CreateProjectV2FieldInput(
    Input$CreateProjectV2FieldInput instance,
    TRes Function(Input$CreateProjectV2FieldInput) then,
  ) = _CopyWithImpl$Input$CreateProjectV2FieldInput;

  factory CopyWith$Input$CreateProjectV2FieldInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectV2FieldInput;

  TRes call({
    String? clientMutationId,
    Enum$ProjectV2CustomFieldType? dataType,
    String? name,
    String? projectId,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
  });
  TRes singleSelectOptions(
      Iterable<Input$ProjectV2SingleSelectFieldOptionInput>? Function(
              Iterable<
                  CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
                      Input$ProjectV2SingleSelectFieldOptionInput>>?)
          _fn);
}

class _CopyWithImpl$Input$CreateProjectV2FieldInput<TRes>
    implements CopyWith$Input$CreateProjectV2FieldInput<TRes> {
  _CopyWithImpl$Input$CreateProjectV2FieldInput(
    this._instance,
    this._then,
  );

  final Input$CreateProjectV2FieldInput _instance;

  final TRes Function(Input$CreateProjectV2FieldInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? dataType = _undefined,
    Object? name = _undefined,
    Object? projectId = _undefined,
    Object? singleSelectOptions = _undefined,
  }) =>
      _then(Input$CreateProjectV2FieldInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (dataType != _undefined && dataType != null)
          'dataType': (dataType as Enum$ProjectV2CustomFieldType),
        if (name != _undefined && name != null) 'name': (name as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (singleSelectOptions != _undefined)
          'singleSelectOptions': (singleSelectOptions
              as List<Input$ProjectV2SingleSelectFieldOptionInput>?),
      }));
  TRes singleSelectOptions(
          Iterable<Input$ProjectV2SingleSelectFieldOptionInput>? Function(
                  Iterable<
                      CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
                          Input$ProjectV2SingleSelectFieldOptionInput>>?)
              _fn) =>
      call(
          singleSelectOptions: _fn(_instance.singleSelectOptions
              ?.map((e) => CopyWith$Input$ProjectV2SingleSelectFieldOptionInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$CreateProjectV2FieldInput<TRes>
    implements CopyWith$Input$CreateProjectV2FieldInput<TRes> {
  _CopyWithStubImpl$Input$CreateProjectV2FieldInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$ProjectV2CustomFieldType? dataType,
    String? name,
    String? projectId,
    List<Input$ProjectV2SingleSelectFieldOptionInput>? singleSelectOptions,
  }) =>
      _res;
  singleSelectOptions(_fn) => _res;
}

class Input$CreateProjectV2Input {
  factory Input$CreateProjectV2Input({
    String? clientMutationId,
    required String ownerId,
    String? repositoryId,
    String? teamId,
    required String title,
  }) =>
      Input$CreateProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (teamId != null) r'teamId': teamId,
        r'title': title,
      });

  Input$CreateProjectV2Input._(this._$data);

  factory Input$CreateProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$CreateProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  String? get repositoryId => (_$data['repositoryId'] as String?);
  String? get teamId => (_$data['teamId'] as String?);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$CreateProjectV2Input<Input$CreateProjectV2Input>
      get copyWith => CopyWith$Input$CreateProjectV2Input(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateProjectV2Input) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$repositoryId = repositoryId;
    final l$teamId = teamId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$CreateProjectV2Input<TRes> {
  factory CopyWith$Input$CreateProjectV2Input(
    Input$CreateProjectV2Input instance,
    TRes Function(Input$CreateProjectV2Input) then,
  ) = _CopyWithImpl$Input$CreateProjectV2Input;

  factory CopyWith$Input$CreateProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateProjectV2Input;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    String? repositoryId,
    String? teamId,
    String? title,
  });
}

class _CopyWithImpl$Input$CreateProjectV2Input<TRes>
    implements CopyWith$Input$CreateProjectV2Input<TRes> {
  _CopyWithImpl$Input$CreateProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$CreateProjectV2Input _instance;

  final TRes Function(Input$CreateProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? repositoryId = _undefined,
    Object? teamId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CreateProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$CreateProjectV2Input<TRes>
    implements CopyWith$Input$CreateProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$CreateProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    String? repositoryId,
    String? teamId,
    String? title,
  }) =>
      _res;
}

class Input$CreatePullRequestInput {
  factory Input$CreatePullRequestInput({
    required String baseRefName,
    String? body,
    String? clientMutationId,
    bool? draft,
    required String headRefName,
    String? headRepositoryId,
    bool? maintainerCanModify,
    required String repositoryId,
    required String title,
  }) =>
      Input$CreatePullRequestInput._({
        r'baseRefName': baseRefName,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (draft != null) r'draft': draft,
        r'headRefName': headRefName,
        if (headRepositoryId != null) r'headRepositoryId': headRepositoryId,
        if (maintainerCanModify != null)
          r'maintainerCanModify': maintainerCanModify,
        r'repositoryId': repositoryId,
        r'title': title,
      });

  Input$CreatePullRequestInput._(this._$data);

  factory Input$CreatePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$baseRefName = data['baseRefName'];
    result$data['baseRefName'] = (l$baseRefName as String);
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('draft')) {
      final l$draft = data['draft'];
      result$data['draft'] = (l$draft as bool?);
    }
    final l$headRefName = data['headRefName'];
    result$data['headRefName'] = (l$headRefName as String);
    if (data.containsKey('headRepositoryId')) {
      final l$headRepositoryId = data['headRepositoryId'];
      result$data['headRepositoryId'] = (l$headRepositoryId as String?);
    }
    if (data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = data['maintainerCanModify'];
      result$data['maintainerCanModify'] = (l$maintainerCanModify as bool?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$CreatePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get baseRefName => (_$data['baseRefName'] as String);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get draft => (_$data['draft'] as bool?);
  String get headRefName => (_$data['headRefName'] as String);
  String? get headRepositoryId => (_$data['headRepositoryId'] as String?);
  bool? get maintainerCanModify => (_$data['maintainerCanModify'] as bool?);
  String get repositoryId => (_$data['repositoryId'] as String);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$baseRefName = baseRefName;
    result$data['baseRefName'] = l$baseRefName;
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('draft')) {
      final l$draft = draft;
      result$data['draft'] = l$draft;
    }
    final l$headRefName = headRefName;
    result$data['headRefName'] = l$headRefName;
    if (_$data.containsKey('headRepositoryId')) {
      final l$headRepositoryId = headRepositoryId;
      result$data['headRepositoryId'] = l$headRepositoryId;
    }
    if (_$data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = maintainerCanModify;
      result$data['maintainerCanModify'] = l$maintainerCanModify;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$CreatePullRequestInput<Input$CreatePullRequestInput>
      get copyWith => CopyWith$Input$CreatePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreatePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$baseRefName = baseRefName;
    final lOther$baseRefName = other.baseRefName;
    if (l$baseRefName != lOther$baseRefName) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$draft = draft;
    final lOther$draft = other.draft;
    if (_$data.containsKey('draft') != other._$data.containsKey('draft')) {
      return false;
    }
    if (l$draft != lOther$draft) {
      return false;
    }
    final l$headRefName = headRefName;
    final lOther$headRefName = other.headRefName;
    if (l$headRefName != lOther$headRefName) {
      return false;
    }
    final l$headRepositoryId = headRepositoryId;
    final lOther$headRepositoryId = other.headRepositoryId;
    if (_$data.containsKey('headRepositoryId') !=
        other._$data.containsKey('headRepositoryId')) {
      return false;
    }
    if (l$headRepositoryId != lOther$headRepositoryId) {
      return false;
    }
    final l$maintainerCanModify = maintainerCanModify;
    final lOther$maintainerCanModify = other.maintainerCanModify;
    if (_$data.containsKey('maintainerCanModify') !=
        other._$data.containsKey('maintainerCanModify')) {
      return false;
    }
    if (l$maintainerCanModify != lOther$maintainerCanModify) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$baseRefName = baseRefName;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$draft = draft;
    final l$headRefName = headRefName;
    final l$headRepositoryId = headRepositoryId;
    final l$maintainerCanModify = maintainerCanModify;
    final l$repositoryId = repositoryId;
    final l$title = title;
    return Object.hashAll([
      l$baseRefName,
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('draft') ? l$draft : const {},
      l$headRefName,
      _$data.containsKey('headRepositoryId') ? l$headRepositoryId : const {},
      _$data.containsKey('maintainerCanModify')
          ? l$maintainerCanModify
          : const {},
      l$repositoryId,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$CreatePullRequestInput<TRes> {
  factory CopyWith$Input$CreatePullRequestInput(
    Input$CreatePullRequestInput instance,
    TRes Function(Input$CreatePullRequestInput) then,
  ) = _CopyWithImpl$Input$CreatePullRequestInput;

  factory CopyWith$Input$CreatePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreatePullRequestInput;

  TRes call({
    String? baseRefName,
    String? body,
    String? clientMutationId,
    bool? draft,
    String? headRefName,
    String? headRepositoryId,
    bool? maintainerCanModify,
    String? repositoryId,
    String? title,
  });
}

class _CopyWithImpl$Input$CreatePullRequestInput<TRes>
    implements CopyWith$Input$CreatePullRequestInput<TRes> {
  _CopyWithImpl$Input$CreatePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$CreatePullRequestInput _instance;

  final TRes Function(Input$CreatePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? baseRefName = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? draft = _undefined,
    Object? headRefName = _undefined,
    Object? headRepositoryId = _undefined,
    Object? maintainerCanModify = _undefined,
    Object? repositoryId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CreatePullRequestInput._({
        ..._instance._$data,
        if (baseRefName != _undefined && baseRefName != null)
          'baseRefName': (baseRefName as String),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (draft != _undefined) 'draft': (draft as bool?),
        if (headRefName != _undefined && headRefName != null)
          'headRefName': (headRefName as String),
        if (headRepositoryId != _undefined)
          'headRepositoryId': (headRepositoryId as String?),
        if (maintainerCanModify != _undefined)
          'maintainerCanModify': (maintainerCanModify as bool?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$CreatePullRequestInput<TRes>
    implements CopyWith$Input$CreatePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$CreatePullRequestInput(this._res);

  TRes _res;

  call({
    String? baseRefName,
    String? body,
    String? clientMutationId,
    bool? draft,
    String? headRefName,
    String? headRepositoryId,
    bool? maintainerCanModify,
    String? repositoryId,
    String? title,
  }) =>
      _res;
}

class Input$CreateRefInput {
  factory Input$CreateRefInput({
    String? clientMutationId,
    required String name,
    required String oid,
    required String repositoryId,
  }) =>
      Input$CreateRefInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'oid': oid,
        r'repositoryId': repositoryId,
      });

  Input$CreateRefInput._(this._$data);

  factory Input$CreateRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$CreateRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get oid => (_$data['oid'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$oid = oid;
    result$data['oid'] = l$oid;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$CreateRefInput<Input$CreateRefInput> get copyWith =>
      CopyWith$Input$CreateRefInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateRefInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$oid = oid;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$oid,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$CreateRefInput<TRes> {
  factory CopyWith$Input$CreateRefInput(
    Input$CreateRefInput instance,
    TRes Function(Input$CreateRefInput) then,
  ) = _CopyWithImpl$Input$CreateRefInput;

  factory CopyWith$Input$CreateRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRefInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? oid,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$CreateRefInput<TRes>
    implements CopyWith$Input$CreateRefInput<TRes> {
  _CopyWithImpl$Input$CreateRefInput(
    this._instance,
    this._then,
  );

  final Input$CreateRefInput _instance;

  final TRes Function(Input$CreateRefInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? oid = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$CreateRefInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateRefInput<TRes>
    implements CopyWith$Input$CreateRefInput<TRes> {
  _CopyWithStubImpl$Input$CreateRefInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? oid,
    String? repositoryId,
  }) =>
      _res;
}

class Input$CreateRepositoryInput {
  factory Input$CreateRepositoryInput({
    String? clientMutationId,
    String? description,
    bool? hasIssuesEnabled,
    bool? hasWikiEnabled,
    String? homepageUrl,
    required String name,
    String? ownerId,
    String? teamId,
    bool? template,
    required Enum$RepositoryVisibility visibility,
  }) =>
      Input$CreateRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (description != null) r'description': description,
        if (hasIssuesEnabled != null) r'hasIssuesEnabled': hasIssuesEnabled,
        if (hasWikiEnabled != null) r'hasWikiEnabled': hasWikiEnabled,
        if (homepageUrl != null) r'homepageUrl': homepageUrl,
        r'name': name,
        if (ownerId != null) r'ownerId': ownerId,
        if (teamId != null) r'teamId': teamId,
        if (template != null) r'template': template,
        r'visibility': visibility,
      });

  Input$CreateRepositoryInput._(this._$data);

  factory Input$CreateRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = data['hasIssuesEnabled'];
      result$data['hasIssuesEnabled'] = (l$hasIssuesEnabled as bool?);
    }
    if (data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = data['hasWikiEnabled'];
      result$data['hasWikiEnabled'] = (l$hasWikiEnabled as bool?);
    }
    if (data.containsKey('homepageUrl')) {
      final l$homepageUrl = data['homepageUrl'];
      result$data['homepageUrl'] = (l$homepageUrl as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('ownerId')) {
      final l$ownerId = data['ownerId'];
      result$data['ownerId'] = (l$ownerId as String?);
    }
    if (data.containsKey('teamId')) {
      final l$teamId = data['teamId'];
      result$data['teamId'] = (l$teamId as String?);
    }
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as bool?);
    }
    final l$visibility = data['visibility'];
    result$data['visibility'] =
        fromJson$Enum$RepositoryVisibility((l$visibility as String));
    return Input$CreateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get description => (_$data['description'] as String?);
  bool? get hasIssuesEnabled => (_$data['hasIssuesEnabled'] as bool?);
  bool? get hasWikiEnabled => (_$data['hasWikiEnabled'] as bool?);
  String? get homepageUrl => (_$data['homepageUrl'] as String?);
  String get name => (_$data['name'] as String);
  String? get ownerId => (_$data['ownerId'] as String?);
  String? get teamId => (_$data['teamId'] as String?);
  bool? get template => (_$data['template'] as bool?);
  Enum$RepositoryVisibility get visibility =>
      (_$data['visibility'] as Enum$RepositoryVisibility);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = hasIssuesEnabled;
      result$data['hasIssuesEnabled'] = l$hasIssuesEnabled;
    }
    if (_$data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = hasWikiEnabled;
      result$data['hasWikiEnabled'] = l$hasWikiEnabled;
    }
    if (_$data.containsKey('homepageUrl')) {
      final l$homepageUrl = homepageUrl;
      result$data['homepageUrl'] = l$homepageUrl;
    }
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('ownerId')) {
      final l$ownerId = ownerId;
      result$data['ownerId'] = l$ownerId;
    }
    if (_$data.containsKey('teamId')) {
      final l$teamId = teamId;
      result$data['teamId'] = l$teamId;
    }
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    final l$visibility = visibility;
    result$data['visibility'] = toJson$Enum$RepositoryVisibility(l$visibility);
    return result$data;
  }

  CopyWith$Input$CreateRepositoryInput<Input$CreateRepositoryInput>
      get copyWith => CopyWith$Input$CreateRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final lOther$hasIssuesEnabled = other.hasIssuesEnabled;
    if (_$data.containsKey('hasIssuesEnabled') !=
        other._$data.containsKey('hasIssuesEnabled')) {
      return false;
    }
    if (l$hasIssuesEnabled != lOther$hasIssuesEnabled) {
      return false;
    }
    final l$hasWikiEnabled = hasWikiEnabled;
    final lOther$hasWikiEnabled = other.hasWikiEnabled;
    if (_$data.containsKey('hasWikiEnabled') !=
        other._$data.containsKey('hasWikiEnabled')) {
      return false;
    }
    if (l$hasWikiEnabled != lOther$hasWikiEnabled) {
      return false;
    }
    final l$homepageUrl = homepageUrl;
    final lOther$homepageUrl = other.homepageUrl;
    if (_$data.containsKey('homepageUrl') !=
        other._$data.containsKey('homepageUrl')) {
      return false;
    }
    if (l$homepageUrl != lOther$homepageUrl) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (_$data.containsKey('ownerId') != other._$data.containsKey('ownerId')) {
      return false;
    }
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (_$data.containsKey('teamId') != other._$data.containsKey('teamId')) {
      return false;
    }
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    final l$visibility = visibility;
    final lOther$visibility = other.visibility;
    if (l$visibility != lOther$visibility) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final l$hasWikiEnabled = hasWikiEnabled;
    final l$homepageUrl = homepageUrl;
    final l$name = name;
    final l$ownerId = ownerId;
    final l$teamId = teamId;
    final l$template = template;
    final l$visibility = visibility;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('hasIssuesEnabled') ? l$hasIssuesEnabled : const {},
      _$data.containsKey('hasWikiEnabled') ? l$hasWikiEnabled : const {},
      _$data.containsKey('homepageUrl') ? l$homepageUrl : const {},
      l$name,
      _$data.containsKey('ownerId') ? l$ownerId : const {},
      _$data.containsKey('teamId') ? l$teamId : const {},
      _$data.containsKey('template') ? l$template : const {},
      l$visibility,
    ]);
  }
}

abstract class CopyWith$Input$CreateRepositoryInput<TRes> {
  factory CopyWith$Input$CreateRepositoryInput(
    Input$CreateRepositoryInput instance,
    TRes Function(Input$CreateRepositoryInput) then,
  ) = _CopyWithImpl$Input$CreateRepositoryInput;

  factory CopyWith$Input$CreateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? description,
    bool? hasIssuesEnabled,
    bool? hasWikiEnabled,
    String? homepageUrl,
    String? name,
    String? ownerId,
    String? teamId,
    bool? template,
    Enum$RepositoryVisibility? visibility,
  });
}

class _CopyWithImpl$Input$CreateRepositoryInput<TRes>
    implements CopyWith$Input$CreateRepositoryInput<TRes> {
  _CopyWithImpl$Input$CreateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$CreateRepositoryInput _instance;

  final TRes Function(Input$CreateRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? hasIssuesEnabled = _undefined,
    Object? hasWikiEnabled = _undefined,
    Object? homepageUrl = _undefined,
    Object? name = _undefined,
    Object? ownerId = _undefined,
    Object? teamId = _undefined,
    Object? template = _undefined,
    Object? visibility = _undefined,
  }) =>
      _then(Input$CreateRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (hasIssuesEnabled != _undefined)
          'hasIssuesEnabled': (hasIssuesEnabled as bool?),
        if (hasWikiEnabled != _undefined)
          'hasWikiEnabled': (hasWikiEnabled as bool?),
        if (homepageUrl != _undefined) 'homepageUrl': (homepageUrl as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerId != _undefined) 'ownerId': (ownerId as String?),
        if (teamId != _undefined) 'teamId': (teamId as String?),
        if (template != _undefined) 'template': (template as bool?),
        if (visibility != _undefined && visibility != null)
          'visibility': (visibility as Enum$RepositoryVisibility),
      }));
}

class _CopyWithStubImpl$Input$CreateRepositoryInput<TRes>
    implements CopyWith$Input$CreateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$CreateRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? description,
    bool? hasIssuesEnabled,
    bool? hasWikiEnabled,
    String? homepageUrl,
    String? name,
    String? ownerId,
    String? teamId,
    bool? template,
    Enum$RepositoryVisibility? visibility,
  }) =>
      _res;
}

class Input$CreateSponsorsListingInput {
  factory Input$CreateSponsorsListingInput({
    Enum$SponsorsCountryOrRegionCode? billingCountryOrRegionCode,
    String? clientMutationId,
    String? contactEmail,
    String? fiscalHostLogin,
    String? fiscallyHostedProjectProfileUrl,
    String? fullDescription,
    Enum$SponsorsCountryOrRegionCode? residenceCountryOrRegionCode,
    String? sponsorableLogin,
  }) =>
      Input$CreateSponsorsListingInput._({
        if (billingCountryOrRegionCode != null)
          r'billingCountryOrRegionCode': billingCountryOrRegionCode,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (contactEmail != null) r'contactEmail': contactEmail,
        if (fiscalHostLogin != null) r'fiscalHostLogin': fiscalHostLogin,
        if (fiscallyHostedProjectProfileUrl != null)
          r'fiscallyHostedProjectProfileUrl': fiscallyHostedProjectProfileUrl,
        if (fullDescription != null) r'fullDescription': fullDescription,
        if (residenceCountryOrRegionCode != null)
          r'residenceCountryOrRegionCode': residenceCountryOrRegionCode,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
      });

  Input$CreateSponsorsListingInput._(this._$data);

  factory Input$CreateSponsorsListingInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('billingCountryOrRegionCode')) {
      final l$billingCountryOrRegionCode = data['billingCountryOrRegionCode'];
      result$data['billingCountryOrRegionCode'] =
          l$billingCountryOrRegionCode == null
              ? null
              : fromJson$Enum$SponsorsCountryOrRegionCode(
                  (l$billingCountryOrRegionCode as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('contactEmail')) {
      final l$contactEmail = data['contactEmail'];
      result$data['contactEmail'] = (l$contactEmail as String?);
    }
    if (data.containsKey('fiscalHostLogin')) {
      final l$fiscalHostLogin = data['fiscalHostLogin'];
      result$data['fiscalHostLogin'] = (l$fiscalHostLogin as String?);
    }
    if (data.containsKey('fiscallyHostedProjectProfileUrl')) {
      final l$fiscallyHostedProjectProfileUrl =
          data['fiscallyHostedProjectProfileUrl'];
      result$data['fiscallyHostedProjectProfileUrl'] =
          (l$fiscallyHostedProjectProfileUrl as String?);
    }
    if (data.containsKey('fullDescription')) {
      final l$fullDescription = data['fullDescription'];
      result$data['fullDescription'] = (l$fullDescription as String?);
    }
    if (data.containsKey('residenceCountryOrRegionCode')) {
      final l$residenceCountryOrRegionCode =
          data['residenceCountryOrRegionCode'];
      result$data['residenceCountryOrRegionCode'] =
          l$residenceCountryOrRegionCode == null
              ? null
              : fromJson$Enum$SponsorsCountryOrRegionCode(
                  (l$residenceCountryOrRegionCode as String));
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    return Input$CreateSponsorsListingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SponsorsCountryOrRegionCode? get billingCountryOrRegionCode =>
      (_$data['billingCountryOrRegionCode']
          as Enum$SponsorsCountryOrRegionCode?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get contactEmail => (_$data['contactEmail'] as String?);
  String? get fiscalHostLogin => (_$data['fiscalHostLogin'] as String?);
  String? get fiscallyHostedProjectProfileUrl =>
      (_$data['fiscallyHostedProjectProfileUrl'] as String?);
  String? get fullDescription => (_$data['fullDescription'] as String?);
  Enum$SponsorsCountryOrRegionCode? get residenceCountryOrRegionCode =>
      (_$data['residenceCountryOrRegionCode']
          as Enum$SponsorsCountryOrRegionCode?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('billingCountryOrRegionCode')) {
      final l$billingCountryOrRegionCode = billingCountryOrRegionCode;
      result$data['billingCountryOrRegionCode'] =
          l$billingCountryOrRegionCode == null
              ? null
              : toJson$Enum$SponsorsCountryOrRegionCode(
                  l$billingCountryOrRegionCode);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('contactEmail')) {
      final l$contactEmail = contactEmail;
      result$data['contactEmail'] = l$contactEmail;
    }
    if (_$data.containsKey('fiscalHostLogin')) {
      final l$fiscalHostLogin = fiscalHostLogin;
      result$data['fiscalHostLogin'] = l$fiscalHostLogin;
    }
    if (_$data.containsKey('fiscallyHostedProjectProfileUrl')) {
      final l$fiscallyHostedProjectProfileUrl = fiscallyHostedProjectProfileUrl;
      result$data['fiscallyHostedProjectProfileUrl'] =
          l$fiscallyHostedProjectProfileUrl;
    }
    if (_$data.containsKey('fullDescription')) {
      final l$fullDescription = fullDescription;
      result$data['fullDescription'] = l$fullDescription;
    }
    if (_$data.containsKey('residenceCountryOrRegionCode')) {
      final l$residenceCountryOrRegionCode = residenceCountryOrRegionCode;
      result$data['residenceCountryOrRegionCode'] =
          l$residenceCountryOrRegionCode == null
              ? null
              : toJson$Enum$SponsorsCountryOrRegionCode(
                  l$residenceCountryOrRegionCode);
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorsListingInput<Input$CreateSponsorsListingInput>
      get copyWith => CopyWith$Input$CreateSponsorsListingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateSponsorsListingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$billingCountryOrRegionCode = billingCountryOrRegionCode;
    final lOther$billingCountryOrRegionCode = other.billingCountryOrRegionCode;
    if (_$data.containsKey('billingCountryOrRegionCode') !=
        other._$data.containsKey('billingCountryOrRegionCode')) {
      return false;
    }
    if (l$billingCountryOrRegionCode != lOther$billingCountryOrRegionCode) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$contactEmail = contactEmail;
    final lOther$contactEmail = other.contactEmail;
    if (_$data.containsKey('contactEmail') !=
        other._$data.containsKey('contactEmail')) {
      return false;
    }
    if (l$contactEmail != lOther$contactEmail) {
      return false;
    }
    final l$fiscalHostLogin = fiscalHostLogin;
    final lOther$fiscalHostLogin = other.fiscalHostLogin;
    if (_$data.containsKey('fiscalHostLogin') !=
        other._$data.containsKey('fiscalHostLogin')) {
      return false;
    }
    if (l$fiscalHostLogin != lOther$fiscalHostLogin) {
      return false;
    }
    final l$fiscallyHostedProjectProfileUrl = fiscallyHostedProjectProfileUrl;
    final lOther$fiscallyHostedProjectProfileUrl =
        other.fiscallyHostedProjectProfileUrl;
    if (_$data.containsKey('fiscallyHostedProjectProfileUrl') !=
        other._$data.containsKey('fiscallyHostedProjectProfileUrl')) {
      return false;
    }
    if (l$fiscallyHostedProjectProfileUrl !=
        lOther$fiscallyHostedProjectProfileUrl) {
      return false;
    }
    final l$fullDescription = fullDescription;
    final lOther$fullDescription = other.fullDescription;
    if (_$data.containsKey('fullDescription') !=
        other._$data.containsKey('fullDescription')) {
      return false;
    }
    if (l$fullDescription != lOther$fullDescription) {
      return false;
    }
    final l$residenceCountryOrRegionCode = residenceCountryOrRegionCode;
    final lOther$residenceCountryOrRegionCode =
        other.residenceCountryOrRegionCode;
    if (_$data.containsKey('residenceCountryOrRegionCode') !=
        other._$data.containsKey('residenceCountryOrRegionCode')) {
      return false;
    }
    if (l$residenceCountryOrRegionCode != lOther$residenceCountryOrRegionCode) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$billingCountryOrRegionCode = billingCountryOrRegionCode;
    final l$clientMutationId = clientMutationId;
    final l$contactEmail = contactEmail;
    final l$fiscalHostLogin = fiscalHostLogin;
    final l$fiscallyHostedProjectProfileUrl = fiscallyHostedProjectProfileUrl;
    final l$fullDescription = fullDescription;
    final l$residenceCountryOrRegionCode = residenceCountryOrRegionCode;
    final l$sponsorableLogin = sponsorableLogin;
    return Object.hashAll([
      _$data.containsKey('billingCountryOrRegionCode')
          ? l$billingCountryOrRegionCode
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('contactEmail') ? l$contactEmail : const {},
      _$data.containsKey('fiscalHostLogin') ? l$fiscalHostLogin : const {},
      _$data.containsKey('fiscallyHostedProjectProfileUrl')
          ? l$fiscallyHostedProjectProfileUrl
          : const {},
      _$data.containsKey('fullDescription') ? l$fullDescription : const {},
      _$data.containsKey('residenceCountryOrRegionCode')
          ? l$residenceCountryOrRegionCode
          : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorsListingInput<TRes> {
  factory CopyWith$Input$CreateSponsorsListingInput(
    Input$CreateSponsorsListingInput instance,
    TRes Function(Input$CreateSponsorsListingInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorsListingInput;

  factory CopyWith$Input$CreateSponsorsListingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorsListingInput;

  TRes call({
    Enum$SponsorsCountryOrRegionCode? billingCountryOrRegionCode,
    String? clientMutationId,
    String? contactEmail,
    String? fiscalHostLogin,
    String? fiscallyHostedProjectProfileUrl,
    String? fullDescription,
    Enum$SponsorsCountryOrRegionCode? residenceCountryOrRegionCode,
    String? sponsorableLogin,
  });
}

class _CopyWithImpl$Input$CreateSponsorsListingInput<TRes>
    implements CopyWith$Input$CreateSponsorsListingInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorsListingInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorsListingInput _instance;

  final TRes Function(Input$CreateSponsorsListingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? billingCountryOrRegionCode = _undefined,
    Object? clientMutationId = _undefined,
    Object? contactEmail = _undefined,
    Object? fiscalHostLogin = _undefined,
    Object? fiscallyHostedProjectProfileUrl = _undefined,
    Object? fullDescription = _undefined,
    Object? residenceCountryOrRegionCode = _undefined,
    Object? sponsorableLogin = _undefined,
  }) =>
      _then(Input$CreateSponsorsListingInput._({
        ..._instance._$data,
        if (billingCountryOrRegionCode != _undefined)
          'billingCountryOrRegionCode':
              (billingCountryOrRegionCode as Enum$SponsorsCountryOrRegionCode?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (contactEmail != _undefined)
          'contactEmail': (contactEmail as String?),
        if (fiscalHostLogin != _undefined)
          'fiscalHostLogin': (fiscalHostLogin as String?),
        if (fiscallyHostedProjectProfileUrl != _undefined)
          'fiscallyHostedProjectProfileUrl':
              (fiscallyHostedProjectProfileUrl as String?),
        if (fullDescription != _undefined)
          'fullDescription': (fullDescription as String?),
        if (residenceCountryOrRegionCode != _undefined)
          'residenceCountryOrRegionCode': (residenceCountryOrRegionCode
              as Enum$SponsorsCountryOrRegionCode?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorsListingInput<TRes>
    implements CopyWith$Input$CreateSponsorsListingInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorsListingInput(this._res);

  TRes _res;

  call({
    Enum$SponsorsCountryOrRegionCode? billingCountryOrRegionCode,
    String? clientMutationId,
    String? contactEmail,
    String? fiscalHostLogin,
    String? fiscallyHostedProjectProfileUrl,
    String? fullDescription,
    Enum$SponsorsCountryOrRegionCode? residenceCountryOrRegionCode,
    String? sponsorableLogin,
  }) =>
      _res;
}

class Input$CreateSponsorsTierInput {
  factory Input$CreateSponsorsTierInput({
    required int amount,
    String? clientMutationId,
    required String description,
    bool? isRecurring,
    bool? publish,
    String? repositoryId,
    String? repositoryName,
    String? repositoryOwnerLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? welcomeMessage,
  }) =>
      Input$CreateSponsorsTierInput._({
        r'amount': amount,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'description': description,
        if (isRecurring != null) r'isRecurring': isRecurring,
        if (publish != null) r'publish': publish,
        if (repositoryId != null) r'repositoryId': repositoryId,
        if (repositoryName != null) r'repositoryName': repositoryName,
        if (repositoryOwnerLogin != null)
          r'repositoryOwnerLogin': repositoryOwnerLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (welcomeMessage != null) r'welcomeMessage': welcomeMessage,
      });

  Input$CreateSponsorsTierInput._(this._$data);

  factory Input$CreateSponsorsTierInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$amount = data['amount'];
    result$data['amount'] = (l$amount as int);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('isRecurring')) {
      final l$isRecurring = data['isRecurring'];
      result$data['isRecurring'] = (l$isRecurring as bool?);
    }
    if (data.containsKey('publish')) {
      final l$publish = data['publish'];
      result$data['publish'] = (l$publish as bool?);
    }
    if (data.containsKey('repositoryId')) {
      final l$repositoryId = data['repositoryId'];
      result$data['repositoryId'] = (l$repositoryId as String?);
    }
    if (data.containsKey('repositoryName')) {
      final l$repositoryName = data['repositoryName'];
      result$data['repositoryName'] = (l$repositoryName as String?);
    }
    if (data.containsKey('repositoryOwnerLogin')) {
      final l$repositoryOwnerLogin = data['repositoryOwnerLogin'];
      result$data['repositoryOwnerLogin'] = (l$repositoryOwnerLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('welcomeMessage')) {
      final l$welcomeMessage = data['welcomeMessage'];
      result$data['welcomeMessage'] = (l$welcomeMessage as String?);
    }
    return Input$CreateSponsorsTierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get amount => (_$data['amount'] as int);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get description => (_$data['description'] as String);
  bool? get isRecurring => (_$data['isRecurring'] as bool?);
  bool? get publish => (_$data['publish'] as bool?);
  String? get repositoryId => (_$data['repositoryId'] as String?);
  String? get repositoryName => (_$data['repositoryName'] as String?);
  String? get repositoryOwnerLogin =>
      (_$data['repositoryOwnerLogin'] as String?);
  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  String? get welcomeMessage => (_$data['welcomeMessage'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$amount = amount;
    result$data['amount'] = l$amount;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('isRecurring')) {
      final l$isRecurring = isRecurring;
      result$data['isRecurring'] = l$isRecurring;
    }
    if (_$data.containsKey('publish')) {
      final l$publish = publish;
      result$data['publish'] = l$publish;
    }
    if (_$data.containsKey('repositoryId')) {
      final l$repositoryId = repositoryId;
      result$data['repositoryId'] = l$repositoryId;
    }
    if (_$data.containsKey('repositoryName')) {
      final l$repositoryName = repositoryName;
      result$data['repositoryName'] = l$repositoryName;
    }
    if (_$data.containsKey('repositoryOwnerLogin')) {
      final l$repositoryOwnerLogin = repositoryOwnerLogin;
      result$data['repositoryOwnerLogin'] = l$repositoryOwnerLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('welcomeMessage')) {
      final l$welcomeMessage = welcomeMessage;
      result$data['welcomeMessage'] = l$welcomeMessage;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorsTierInput<Input$CreateSponsorsTierInput>
      get copyWith => CopyWith$Input$CreateSponsorsTierInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateSponsorsTierInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$isRecurring = isRecurring;
    final lOther$isRecurring = other.isRecurring;
    if (_$data.containsKey('isRecurring') !=
        other._$data.containsKey('isRecurring')) {
      return false;
    }
    if (l$isRecurring != lOther$isRecurring) {
      return false;
    }
    final l$publish = publish;
    final lOther$publish = other.publish;
    if (_$data.containsKey('publish') != other._$data.containsKey('publish')) {
      return false;
    }
    if (l$publish != lOther$publish) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (_$data.containsKey('repositoryId') !=
        other._$data.containsKey('repositoryId')) {
      return false;
    }
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$repositoryName = repositoryName;
    final lOther$repositoryName = other.repositoryName;
    if (_$data.containsKey('repositoryName') !=
        other._$data.containsKey('repositoryName')) {
      return false;
    }
    if (l$repositoryName != lOther$repositoryName) {
      return false;
    }
    final l$repositoryOwnerLogin = repositoryOwnerLogin;
    final lOther$repositoryOwnerLogin = other.repositoryOwnerLogin;
    if (_$data.containsKey('repositoryOwnerLogin') !=
        other._$data.containsKey('repositoryOwnerLogin')) {
      return false;
    }
    if (l$repositoryOwnerLogin != lOther$repositoryOwnerLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$welcomeMessage = welcomeMessage;
    final lOther$welcomeMessage = other.welcomeMessage;
    if (_$data.containsKey('welcomeMessage') !=
        other._$data.containsKey('welcomeMessage')) {
      return false;
    }
    if (l$welcomeMessage != lOther$welcomeMessage) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$isRecurring = isRecurring;
    final l$publish = publish;
    final l$repositoryId = repositoryId;
    final l$repositoryName = repositoryName;
    final l$repositoryOwnerLogin = repositoryOwnerLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$welcomeMessage = welcomeMessage;
    return Object.hashAll([
      l$amount,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$description,
      _$data.containsKey('isRecurring') ? l$isRecurring : const {},
      _$data.containsKey('publish') ? l$publish : const {},
      _$data.containsKey('repositoryId') ? l$repositoryId : const {},
      _$data.containsKey('repositoryName') ? l$repositoryName : const {},
      _$data.containsKey('repositoryOwnerLogin')
          ? l$repositoryOwnerLogin
          : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('welcomeMessage') ? l$welcomeMessage : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorsTierInput<TRes> {
  factory CopyWith$Input$CreateSponsorsTierInput(
    Input$CreateSponsorsTierInput instance,
    TRes Function(Input$CreateSponsorsTierInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorsTierInput;

  factory CopyWith$Input$CreateSponsorsTierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorsTierInput;

  TRes call({
    int? amount,
    String? clientMutationId,
    String? description,
    bool? isRecurring,
    bool? publish,
    String? repositoryId,
    String? repositoryName,
    String? repositoryOwnerLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? welcomeMessage,
  });
}

class _CopyWithImpl$Input$CreateSponsorsTierInput<TRes>
    implements CopyWith$Input$CreateSponsorsTierInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorsTierInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorsTierInput _instance;

  final TRes Function(Input$CreateSponsorsTierInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? isRecurring = _undefined,
    Object? publish = _undefined,
    Object? repositoryId = _undefined,
    Object? repositoryName = _undefined,
    Object? repositoryOwnerLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? welcomeMessage = _undefined,
  }) =>
      _then(Input$CreateSponsorsTierInput._({
        ..._instance._$data,
        if (amount != _undefined && amount != null) 'amount': (amount as int),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (isRecurring != _undefined) 'isRecurring': (isRecurring as bool?),
        if (publish != _undefined) 'publish': (publish as bool?),
        if (repositoryId != _undefined)
          'repositoryId': (repositoryId as String?),
        if (repositoryName != _undefined)
          'repositoryName': (repositoryName as String?),
        if (repositoryOwnerLogin != _undefined)
          'repositoryOwnerLogin': (repositoryOwnerLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (welcomeMessage != _undefined)
          'welcomeMessage': (welcomeMessage as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorsTierInput<TRes>
    implements CopyWith$Input$CreateSponsorsTierInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorsTierInput(this._res);

  TRes _res;

  call({
    int? amount,
    String? clientMutationId,
    String? description,
    bool? isRecurring,
    bool? publish,
    String? repositoryId,
    String? repositoryName,
    String? repositoryOwnerLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? welcomeMessage,
  }) =>
      _res;
}

class Input$CreateSponsorshipInput {
  factory Input$CreateSponsorshipInput({
    int? amount,
    String? clientMutationId,
    bool? isRecurring,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? receiveEmails,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
  }) =>
      Input$CreateSponsorshipInput._({
        if (amount != null) r'amount': amount,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (isRecurring != null) r'isRecurring': isRecurring,
        if (privacyLevel != null) r'privacyLevel': privacyLevel,
        if (receiveEmails != null) r'receiveEmails': receiveEmails,
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
        if (tierId != null) r'tierId': tierId,
      });

  Input$CreateSponsorshipInput._(this._$data);

  factory Input$CreateSponsorshipInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('amount')) {
      final l$amount = data['amount'];
      result$data['amount'] = (l$amount as int?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('isRecurring')) {
      final l$isRecurring = data['isRecurring'];
      result$data['isRecurring'] = (l$isRecurring as bool?);
    }
    if (data.containsKey('privacyLevel')) {
      final l$privacyLevel = data['privacyLevel'];
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : fromJson$Enum$SponsorshipPrivacy((l$privacyLevel as String));
    }
    if (data.containsKey('receiveEmails')) {
      final l$receiveEmails = data['receiveEmails'];
      result$data['receiveEmails'] = (l$receiveEmails as bool?);
    }
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    if (data.containsKey('tierId')) {
      final l$tierId = data['tierId'];
      result$data['tierId'] = (l$tierId as String?);
    }
    return Input$CreateSponsorshipInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get amount => (_$data['amount'] as int?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get isRecurring => (_$data['isRecurring'] as bool?);
  Enum$SponsorshipPrivacy? get privacyLevel =>
      (_$data['privacyLevel'] as Enum$SponsorshipPrivacy?);
  bool? get receiveEmails => (_$data['receiveEmails'] as bool?);
  String? get sponsorId => (_$data['sponsorId'] as String?);
  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);
  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  String? get tierId => (_$data['tierId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('amount')) {
      final l$amount = amount;
      result$data['amount'] = l$amount;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('isRecurring')) {
      final l$isRecurring = isRecurring;
      result$data['isRecurring'] = l$isRecurring;
    }
    if (_$data.containsKey('privacyLevel')) {
      final l$privacyLevel = privacyLevel;
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : toJson$Enum$SponsorshipPrivacy(l$privacyLevel);
    }
    if (_$data.containsKey('receiveEmails')) {
      final l$receiveEmails = receiveEmails;
      result$data['receiveEmails'] = l$receiveEmails;
    }
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    if (_$data.containsKey('tierId')) {
      final l$tierId = tierId;
      result$data['tierId'] = l$tierId;
    }
    return result$data;
  }

  CopyWith$Input$CreateSponsorshipInput<Input$CreateSponsorshipInput>
      get copyWith => CopyWith$Input$CreateSponsorshipInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateSponsorshipInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$amount = amount;
    final lOther$amount = other.amount;
    if (_$data.containsKey('amount') != other._$data.containsKey('amount')) {
      return false;
    }
    if (l$amount != lOther$amount) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$isRecurring = isRecurring;
    final lOther$isRecurring = other.isRecurring;
    if (_$data.containsKey('isRecurring') !=
        other._$data.containsKey('isRecurring')) {
      return false;
    }
    if (l$isRecurring != lOther$isRecurring) {
      return false;
    }
    final l$privacyLevel = privacyLevel;
    final lOther$privacyLevel = other.privacyLevel;
    if (_$data.containsKey('privacyLevel') !=
        other._$data.containsKey('privacyLevel')) {
      return false;
    }
    if (l$privacyLevel != lOther$privacyLevel) {
      return false;
    }
    final l$receiveEmails = receiveEmails;
    final lOther$receiveEmails = other.receiveEmails;
    if (_$data.containsKey('receiveEmails') !=
        other._$data.containsKey('receiveEmails')) {
      return false;
    }
    if (l$receiveEmails != lOther$receiveEmails) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    final l$tierId = tierId;
    final lOther$tierId = other.tierId;
    if (_$data.containsKey('tierId') != other._$data.containsKey('tierId')) {
      return false;
    }
    if (l$tierId != lOther$tierId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$amount = amount;
    final l$clientMutationId = clientMutationId;
    final l$isRecurring = isRecurring;
    final l$privacyLevel = privacyLevel;
    final l$receiveEmails = receiveEmails;
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    final l$tierId = tierId;
    return Object.hashAll([
      _$data.containsKey('amount') ? l$amount : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('isRecurring') ? l$isRecurring : const {},
      _$data.containsKey('privacyLevel') ? l$privacyLevel : const {},
      _$data.containsKey('receiveEmails') ? l$receiveEmails : const {},
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
      _$data.containsKey('tierId') ? l$tierId : const {},
    ]);
  }
}

abstract class CopyWith$Input$CreateSponsorshipInput<TRes> {
  factory CopyWith$Input$CreateSponsorshipInput(
    Input$CreateSponsorshipInput instance,
    TRes Function(Input$CreateSponsorshipInput) then,
  ) = _CopyWithImpl$Input$CreateSponsorshipInput;

  factory CopyWith$Input$CreateSponsorshipInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateSponsorshipInput;

  TRes call({
    int? amount,
    String? clientMutationId,
    bool? isRecurring,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? receiveEmails,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
  });
}

class _CopyWithImpl$Input$CreateSponsorshipInput<TRes>
    implements CopyWith$Input$CreateSponsorshipInput<TRes> {
  _CopyWithImpl$Input$CreateSponsorshipInput(
    this._instance,
    this._then,
  );

  final Input$CreateSponsorshipInput _instance;

  final TRes Function(Input$CreateSponsorshipInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? amount = _undefined,
    Object? clientMutationId = _undefined,
    Object? isRecurring = _undefined,
    Object? privacyLevel = _undefined,
    Object? receiveEmails = _undefined,
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
    Object? tierId = _undefined,
  }) =>
      _then(Input$CreateSponsorshipInput._({
        ..._instance._$data,
        if (amount != _undefined) 'amount': (amount as int?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (isRecurring != _undefined) 'isRecurring': (isRecurring as bool?),
        if (privacyLevel != _undefined)
          'privacyLevel': (privacyLevel as Enum$SponsorshipPrivacy?),
        if (receiveEmails != _undefined)
          'receiveEmails': (receiveEmails as bool?),
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
        if (tierId != _undefined) 'tierId': (tierId as String?),
      }));
}

class _CopyWithStubImpl$Input$CreateSponsorshipInput<TRes>
    implements CopyWith$Input$CreateSponsorshipInput<TRes> {
  _CopyWithStubImpl$Input$CreateSponsorshipInput(this._res);

  TRes _res;

  call({
    int? amount,
    String? clientMutationId,
    bool? isRecurring,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? receiveEmails,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
    String? tierId,
  }) =>
      _res;
}

class Input$CreateTeamDiscussionCommentInput {
  factory Input$CreateTeamDiscussionCommentInput({
    required String body,
    String? clientMutationId,
    required String discussionId,
  }) =>
      Input$CreateTeamDiscussionCommentInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
      });

  Input$CreateTeamDiscussionCommentInput._(this._$data);

  factory Input$CreateTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    return Input$CreateTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get discussionId => (_$data['discussionId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    return result$data;
  }

  CopyWith$Input$CreateTeamDiscussionCommentInput<
          Input$CreateTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$CreateTeamDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateTeamDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
    ]);
  }
}

abstract class CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$CreateTeamDiscussionCommentInput(
    Input$CreateTeamDiscussionCommentInput instance,
    TRes Function(Input$CreateTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$CreateTeamDiscussionCommentInput;

  factory CopyWith$Input$CreateTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? discussionId,
  });
}

class _CopyWithImpl$Input$CreateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$CreateTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$CreateTeamDiscussionCommentInput _instance;

  final TRes Function(Input$CreateTeamDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
  }) =>
      _then(Input$CreateTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
      }));
}

class _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$CreateTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? discussionId,
  }) =>
      _res;
}

class Input$CreateTeamDiscussionInput {
  factory Input$CreateTeamDiscussionInput({
    required String body,
    String? clientMutationId,
    bool? private,
    required String teamId,
    required String title,
  }) =>
      Input$CreateTeamDiscussionInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (private != null) r'private': private,
        r'teamId': teamId,
        r'title': title,
      });

  Input$CreateTeamDiscussionInput._(this._$data);

  factory Input$CreateTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('private')) {
      final l$private = data['private'];
      result$data['private'] = (l$private as bool?);
    }
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    final l$title = data['title'];
    result$data['title'] = (l$title as String);
    return Input$CreateTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get private => (_$data['private'] as bool?);
  String get teamId => (_$data['teamId'] as String);
  String get title => (_$data['title'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('private')) {
      final l$private = private;
      result$data['private'] = l$private;
    }
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    final l$title = title;
    result$data['title'] = l$title;
    return result$data;
  }

  CopyWith$Input$CreateTeamDiscussionInput<Input$CreateTeamDiscussionInput>
      get copyWith => CopyWith$Input$CreateTeamDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CreateTeamDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$private = private;
    final lOther$private = other.private;
    if (_$data.containsKey('private') != other._$data.containsKey('private')) {
      return false;
    }
    if (l$private != lOther$private) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$private = private;
    final l$teamId = teamId;
    final l$title = title;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('private') ? l$private : const {},
      l$teamId,
      l$title,
    ]);
  }
}

abstract class CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  factory CopyWith$Input$CreateTeamDiscussionInput(
    Input$CreateTeamDiscussionInput instance,
    TRes Function(Input$CreateTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$CreateTeamDiscussionInput;

  factory CopyWith$Input$CreateTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CreateTeamDiscussionInput;

  TRes call({
    String? body,
    String? clientMutationId,
    bool? private,
    String? teamId,
    String? title,
  });
}

class _CopyWithImpl$Input$CreateTeamDiscussionInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$CreateTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$CreateTeamDiscussionInput _instance;

  final TRes Function(Input$CreateTeamDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? private = _undefined,
    Object? teamId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$CreateTeamDiscussionInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (private != _undefined) 'private': (private as bool?),
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
        if (title != _undefined && title != null) 'title': (title as String),
      }));
}

class _CopyWithStubImpl$Input$CreateTeamDiscussionInput<TRes>
    implements CopyWith$Input$CreateTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$CreateTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    bool? private,
    String? teamId,
    String? title,
  }) =>
      _res;
}

class Input$DeclineTopicSuggestionInput {
  factory Input$DeclineTopicSuggestionInput({
    String? clientMutationId,
    required String name,
    required Enum$TopicSuggestionDeclineReason reason,
    required String repositoryId,
  }) =>
      Input$DeclineTopicSuggestionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'reason': reason,
        r'repositoryId': repositoryId,
      });

  Input$DeclineTopicSuggestionInput._(this._$data);

  factory Input$DeclineTopicSuggestionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$reason = data['reason'];
    result$data['reason'] =
        fromJson$Enum$TopicSuggestionDeclineReason((l$reason as String));
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$DeclineTopicSuggestionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  Enum$TopicSuggestionDeclineReason get reason =>
      (_$data['reason'] as Enum$TopicSuggestionDeclineReason);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$reason = reason;
    result$data['reason'] = toJson$Enum$TopicSuggestionDeclineReason(l$reason);
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$DeclineTopicSuggestionInput<Input$DeclineTopicSuggestionInput>
      get copyWith => CopyWith$Input$DeclineTopicSuggestionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeclineTopicSuggestionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$reason = reason;
    final lOther$reason = other.reason;
    if (l$reason != lOther$reason) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$reason = reason;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$reason,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  factory CopyWith$Input$DeclineTopicSuggestionInput(
    Input$DeclineTopicSuggestionInput instance,
    TRes Function(Input$DeclineTopicSuggestionInput) then,
  ) = _CopyWithImpl$Input$DeclineTopicSuggestionInput;

  factory CopyWith$Input$DeclineTopicSuggestionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeclineTopicSuggestionInput;

  TRes call({
    String? clientMutationId,
    String? name,
    Enum$TopicSuggestionDeclineReason? reason,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$DeclineTopicSuggestionInput<TRes>
    implements CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  _CopyWithImpl$Input$DeclineTopicSuggestionInput(
    this._instance,
    this._then,
  );

  final Input$DeclineTopicSuggestionInput _instance;

  final TRes Function(Input$DeclineTopicSuggestionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? reason = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$DeclineTopicSuggestionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (reason != _undefined && reason != null)
          'reason': (reason as Enum$TopicSuggestionDeclineReason),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$DeclineTopicSuggestionInput<TRes>
    implements CopyWith$Input$DeclineTopicSuggestionInput<TRes> {
  _CopyWithStubImpl$Input$DeclineTopicSuggestionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    Enum$TopicSuggestionDeclineReason? reason,
    String? repositoryId,
  }) =>
      _res;
}

class Input$DeleteBranchProtectionRuleInput {
  factory Input$DeleteBranchProtectionRuleInput({
    required String branchProtectionRuleId,
    String? clientMutationId,
  }) =>
      Input$DeleteBranchProtectionRuleInput._({
        r'branchProtectionRuleId': branchProtectionRuleId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteBranchProtectionRuleInput._(this._$data);

  factory Input$DeleteBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$branchProtectionRuleId = data['branchProtectionRuleId'];
    result$data['branchProtectionRuleId'] =
        (l$branchProtectionRuleId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get branchProtectionRuleId =>
      (_$data['branchProtectionRuleId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$branchProtectionRuleId = branchProtectionRuleId;
    result$data['branchProtectionRuleId'] = l$branchProtectionRuleId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteBranchProtectionRuleInput<
          Input$DeleteBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$DeleteBranchProtectionRuleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteBranchProtectionRuleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final lOther$branchProtectionRuleId = other.branchProtectionRuleId;
    if (l$branchProtectionRuleId != lOther$branchProtectionRuleId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$branchProtectionRuleId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$DeleteBranchProtectionRuleInput(
    Input$DeleteBranchProtectionRuleInput instance,
    TRes Function(Input$DeleteBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$DeleteBranchProtectionRuleInput;

  factory CopyWith$Input$DeleteBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput;

  TRes call({
    String? branchProtectionRuleId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$DeleteBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$DeleteBranchProtectionRuleInput _instance;

  final TRes Function(Input$DeleteBranchProtectionRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? branchProtectionRuleId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteBranchProtectionRuleInput._({
        ..._instance._$data,
        if (branchProtectionRuleId != _undefined &&
            branchProtectionRuleId != null)
          'branchProtectionRuleId': (branchProtectionRuleId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$DeleteBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$DeleteBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    String? branchProtectionRuleId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteDeploymentInput {
  factory Input$DeleteDeploymentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteDeploymentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteDeploymentInput._(this._$data);

  factory Input$DeleteDeploymentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteDeploymentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteDeploymentInput<Input$DeleteDeploymentInput>
      get copyWith => CopyWith$Input$DeleteDeploymentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteDeploymentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteDeploymentInput<TRes> {
  factory CopyWith$Input$DeleteDeploymentInput(
    Input$DeleteDeploymentInput instance,
    TRes Function(Input$DeleteDeploymentInput) then,
  ) = _CopyWithImpl$Input$DeleteDeploymentInput;

  factory CopyWith$Input$DeleteDeploymentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDeploymentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteDeploymentInput<TRes>
    implements CopyWith$Input$DeleteDeploymentInput<TRes> {
  _CopyWithImpl$Input$DeleteDeploymentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDeploymentInput _instance;

  final TRes Function(Input$DeleteDeploymentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteDeploymentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteDeploymentInput<TRes>
    implements CopyWith$Input$DeleteDeploymentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDeploymentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteDiscussionCommentInput {
  factory Input$DeleteDiscussionCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteDiscussionCommentInput._(this._$data);

  factory Input$DeleteDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteDiscussionCommentInput<
          Input$DeleteDiscussionCommentInput>
      get copyWith => CopyWith$Input$DeleteDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  factory CopyWith$Input$DeleteDiscussionCommentInput(
    Input$DeleteDiscussionCommentInput instance,
    TRes Function(Input$DeleteDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteDiscussionCommentInput;

  factory CopyWith$Input$DeleteDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDiscussionCommentInput _instance;

  final TRes Function(Input$DeleteDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteDiscussionInput {
  factory Input$DeleteDiscussionInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteDiscussionInput._(this._$data);

  factory Input$DeleteDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteDiscussionInput<Input$DeleteDiscussionInput>
      get copyWith => CopyWith$Input$DeleteDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteDiscussionInput<TRes> {
  factory CopyWith$Input$DeleteDiscussionInput(
    Input$DeleteDiscussionInput instance,
    TRes Function(Input$DeleteDiscussionInput) then,
  ) = _CopyWithImpl$Input$DeleteDiscussionInput;

  factory CopyWith$Input$DeleteDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteDiscussionInput<TRes>
    implements CopyWith$Input$DeleteDiscussionInput<TRes> {
  _CopyWithImpl$Input$DeleteDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$DeleteDiscussionInput _instance;

  final TRes Function(Input$DeleteDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteDiscussionInput<TRes>
    implements CopyWith$Input$DeleteDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$DeleteDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteEnvironmentInput {
  factory Input$DeleteEnvironmentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteEnvironmentInput._(this._$data);

  factory Input$DeleteEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteEnvironmentInput<Input$DeleteEnvironmentInput>
      get copyWith => CopyWith$Input$DeleteEnvironmentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteEnvironmentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteEnvironmentInput<TRes> {
  factory CopyWith$Input$DeleteEnvironmentInput(
    Input$DeleteEnvironmentInput instance,
    TRes Function(Input$DeleteEnvironmentInput) then,
  ) = _CopyWithImpl$Input$DeleteEnvironmentInput;

  factory CopyWith$Input$DeleteEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteEnvironmentInput<TRes>
    implements CopyWith$Input$DeleteEnvironmentInput<TRes> {
  _CopyWithImpl$Input$DeleteEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteEnvironmentInput _instance;

  final TRes Function(Input$DeleteEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteEnvironmentInput<TRes>
    implements CopyWith$Input$DeleteEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteIpAllowListEntryInput {
  factory Input$DeleteIpAllowListEntryInput({
    String? clientMutationId,
    required String ipAllowListEntryId,
  }) =>
      Input$DeleteIpAllowListEntryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ipAllowListEntryId': ipAllowListEntryId,
      });

  Input$DeleteIpAllowListEntryInput._(this._$data);

  factory Input$DeleteIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ipAllowListEntryId = data['ipAllowListEntryId'];
    result$data['ipAllowListEntryId'] = (l$ipAllowListEntryId as String);
    return Input$DeleteIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ipAllowListEntryId => (_$data['ipAllowListEntryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    result$data['ipAllowListEntryId'] = l$ipAllowListEntryId;
    return result$data;
  }

  CopyWith$Input$DeleteIpAllowListEntryInput<Input$DeleteIpAllowListEntryInput>
      get copyWith => CopyWith$Input$DeleteIpAllowListEntryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteIpAllowListEntryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final lOther$ipAllowListEntryId = other.ipAllowListEntryId;
    if (l$ipAllowListEntryId != lOther$ipAllowListEntryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ipAllowListEntryId = ipAllowListEntryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ipAllowListEntryId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$DeleteIpAllowListEntryInput(
    Input$DeleteIpAllowListEntryInput instance,
    TRes Function(Input$DeleteIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$DeleteIpAllowListEntryInput;

  factory CopyWith$Input$DeleteIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput;

  TRes call({
    String? clientMutationId,
    String? ipAllowListEntryId,
  });
}

class _CopyWithImpl$Input$DeleteIpAllowListEntryInput<TRes>
    implements CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$DeleteIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIpAllowListEntryInput _instance;

  final TRes Function(Input$DeleteIpAllowListEntryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ipAllowListEntryId = _undefined,
  }) =>
      _then(Input$DeleteIpAllowListEntryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ipAllowListEntryId != _undefined && ipAllowListEntryId != null)
          'ipAllowListEntryId': (ipAllowListEntryId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput<TRes>
    implements CopyWith$Input$DeleteIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ipAllowListEntryId,
  }) =>
      _res;
}

class Input$DeleteIssueCommentInput {
  factory Input$DeleteIssueCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteIssueCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteIssueCommentInput._(this._$data);

  factory Input$DeleteIssueCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteIssueCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteIssueCommentInput<Input$DeleteIssueCommentInput>
      get copyWith => CopyWith$Input$DeleteIssueCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteIssueCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteIssueCommentInput<TRes> {
  factory CopyWith$Input$DeleteIssueCommentInput(
    Input$DeleteIssueCommentInput instance,
    TRes Function(Input$DeleteIssueCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteIssueCommentInput;

  factory CopyWith$Input$DeleteIssueCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIssueCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteIssueCommentInput<TRes>
    implements CopyWith$Input$DeleteIssueCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteIssueCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIssueCommentInput _instance;

  final TRes Function(Input$DeleteIssueCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteIssueCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteIssueCommentInput<TRes>
    implements CopyWith$Input$DeleteIssueCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIssueCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteIssueInput {
  factory Input$DeleteIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$DeleteIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$DeleteIssueInput._(this._$data);

  factory Input$DeleteIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$DeleteIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get issueId => (_$data['issueId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$DeleteIssueInput<Input$DeleteIssueInput> get copyWith =>
      CopyWith$Input$DeleteIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteIssueInput<TRes> {
  factory CopyWith$Input$DeleteIssueInput(
    Input$DeleteIssueInput instance,
    TRes Function(Input$DeleteIssueInput) then,
  ) = _CopyWithImpl$Input$DeleteIssueInput;

  factory CopyWith$Input$DeleteIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$DeleteIssueInput<TRes>
    implements CopyWith$Input$DeleteIssueInput<TRes> {
  _CopyWithImpl$Input$DeleteIssueInput(
    this._instance,
    this._then,
  );

  final Input$DeleteIssueInput _instance;

  final TRes Function(Input$DeleteIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$DeleteIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteIssueInput<TRes>
    implements CopyWith$Input$DeleteIssueInput<TRes> {
  _CopyWithStubImpl$Input$DeleteIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$DeleteLabelInput {
  factory Input$DeleteLabelInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteLabelInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteLabelInput._(this._$data);

  factory Input$DeleteLabelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteLabelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteLabelInput<Input$DeleteLabelInput> get copyWith =>
      CopyWith$Input$DeleteLabelInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteLabelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteLabelInput<TRes> {
  factory CopyWith$Input$DeleteLabelInput(
    Input$DeleteLabelInput instance,
    TRes Function(Input$DeleteLabelInput) then,
  ) = _CopyWithImpl$Input$DeleteLabelInput;

  factory CopyWith$Input$DeleteLabelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteLabelInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteLabelInput<TRes>
    implements CopyWith$Input$DeleteLabelInput<TRes> {
  _CopyWithImpl$Input$DeleteLabelInput(
    this._instance,
    this._then,
  );

  final Input$DeleteLabelInput _instance;

  final TRes Function(Input$DeleteLabelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteLabelInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteLabelInput<TRes>
    implements CopyWith$Input$DeleteLabelInput<TRes> {
  _CopyWithStubImpl$Input$DeleteLabelInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteLinkedBranchInput {
  factory Input$DeleteLinkedBranchInput({
    String? clientMutationId,
    required String linkedBranchId,
  }) =>
      Input$DeleteLinkedBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'linkedBranchId': linkedBranchId,
      });

  Input$DeleteLinkedBranchInput._(this._$data);

  factory Input$DeleteLinkedBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$linkedBranchId = data['linkedBranchId'];
    result$data['linkedBranchId'] = (l$linkedBranchId as String);
    return Input$DeleteLinkedBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get linkedBranchId => (_$data['linkedBranchId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$linkedBranchId = linkedBranchId;
    result$data['linkedBranchId'] = l$linkedBranchId;
    return result$data;
  }

  CopyWith$Input$DeleteLinkedBranchInput<Input$DeleteLinkedBranchInput>
      get copyWith => CopyWith$Input$DeleteLinkedBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteLinkedBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$linkedBranchId = linkedBranchId;
    final lOther$linkedBranchId = other.linkedBranchId;
    if (l$linkedBranchId != lOther$linkedBranchId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$linkedBranchId = linkedBranchId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$linkedBranchId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  factory CopyWith$Input$DeleteLinkedBranchInput(
    Input$DeleteLinkedBranchInput instance,
    TRes Function(Input$DeleteLinkedBranchInput) then,
  ) = _CopyWithImpl$Input$DeleteLinkedBranchInput;

  factory CopyWith$Input$DeleteLinkedBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteLinkedBranchInput;

  TRes call({
    String? clientMutationId,
    String? linkedBranchId,
  });
}

class _CopyWithImpl$Input$DeleteLinkedBranchInput<TRes>
    implements CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  _CopyWithImpl$Input$DeleteLinkedBranchInput(
    this._instance,
    this._then,
  );

  final Input$DeleteLinkedBranchInput _instance;

  final TRes Function(Input$DeleteLinkedBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? linkedBranchId = _undefined,
  }) =>
      _then(Input$DeleteLinkedBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (linkedBranchId != _undefined && linkedBranchId != null)
          'linkedBranchId': (linkedBranchId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteLinkedBranchInput<TRes>
    implements CopyWith$Input$DeleteLinkedBranchInput<TRes> {
  _CopyWithStubImpl$Input$DeleteLinkedBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? linkedBranchId,
  }) =>
      _res;
}

class Input$DeletePackageVersionInput {
  factory Input$DeletePackageVersionInput({
    String? clientMutationId,
    required String packageVersionId,
  }) =>
      Input$DeletePackageVersionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'packageVersionId': packageVersionId,
      });

  Input$DeletePackageVersionInput._(this._$data);

  factory Input$DeletePackageVersionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$packageVersionId = data['packageVersionId'];
    result$data['packageVersionId'] = (l$packageVersionId as String);
    return Input$DeletePackageVersionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get packageVersionId => (_$data['packageVersionId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$packageVersionId = packageVersionId;
    result$data['packageVersionId'] = l$packageVersionId;
    return result$data;
  }

  CopyWith$Input$DeletePackageVersionInput<Input$DeletePackageVersionInput>
      get copyWith => CopyWith$Input$DeletePackageVersionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeletePackageVersionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$packageVersionId = packageVersionId;
    final lOther$packageVersionId = other.packageVersionId;
    if (l$packageVersionId != lOther$packageVersionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$packageVersionId = packageVersionId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$packageVersionId,
    ]);
  }
}

abstract class CopyWith$Input$DeletePackageVersionInput<TRes> {
  factory CopyWith$Input$DeletePackageVersionInput(
    Input$DeletePackageVersionInput instance,
    TRes Function(Input$DeletePackageVersionInput) then,
  ) = _CopyWithImpl$Input$DeletePackageVersionInput;

  factory CopyWith$Input$DeletePackageVersionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePackageVersionInput;

  TRes call({
    String? clientMutationId,
    String? packageVersionId,
  });
}

class _CopyWithImpl$Input$DeletePackageVersionInput<TRes>
    implements CopyWith$Input$DeletePackageVersionInput<TRes> {
  _CopyWithImpl$Input$DeletePackageVersionInput(
    this._instance,
    this._then,
  );

  final Input$DeletePackageVersionInput _instance;

  final TRes Function(Input$DeletePackageVersionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? packageVersionId = _undefined,
  }) =>
      _then(Input$DeletePackageVersionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (packageVersionId != _undefined && packageVersionId != null)
          'packageVersionId': (packageVersionId as String),
      }));
}

class _CopyWithStubImpl$Input$DeletePackageVersionInput<TRes>
    implements CopyWith$Input$DeletePackageVersionInput<TRes> {
  _CopyWithStubImpl$Input$DeletePackageVersionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? packageVersionId,
  }) =>
      _res;
}

class Input$DeleteProjectCardInput {
  factory Input$DeleteProjectCardInput({
    required String cardId,
    String? clientMutationId,
  }) =>
      Input$DeleteProjectCardInput._({
        r'cardId': cardId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$DeleteProjectCardInput._(this._$data);

  factory Input$DeleteProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$cardId = data['cardId'];
    result$data['cardId'] = (l$cardId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$DeleteProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get cardId => (_$data['cardId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$cardId = cardId;
    result$data['cardId'] = l$cardId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$DeleteProjectCardInput<Input$DeleteProjectCardInput>
      get copyWith => CopyWith$Input$DeleteProjectCardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$cardId = cardId;
    final lOther$cardId = other.cardId;
    if (l$cardId != lOther$cardId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$cardId = cardId;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$cardId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectCardInput<TRes> {
  factory CopyWith$Input$DeleteProjectCardInput(
    Input$DeleteProjectCardInput instance,
    TRes Function(Input$DeleteProjectCardInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectCardInput;

  factory CopyWith$Input$DeleteProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectCardInput;

  TRes call({
    String? cardId,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$DeleteProjectCardInput<TRes>
    implements CopyWith$Input$DeleteProjectCardInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectCardInput _instance;

  final TRes Function(Input$DeleteProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? cardId = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$DeleteProjectCardInput._({
        ..._instance._$data,
        if (cardId != _undefined && cardId != null)
          'cardId': (cardId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectCardInput<TRes>
    implements CopyWith$Input$DeleteProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectCardInput(this._res);

  TRes _res;

  call({
    String? cardId,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$DeleteProjectColumnInput {
  factory Input$DeleteProjectColumnInput({
    String? clientMutationId,
    required String columnId,
  }) =>
      Input$DeleteProjectColumnInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'columnId': columnId,
      });

  Input$DeleteProjectColumnInput._(this._$data);

  factory Input$DeleteProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    return Input$DeleteProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get columnId => (_$data['columnId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectColumnInput<Input$DeleteProjectColumnInput>
      get copyWith => CopyWith$Input$DeleteProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$columnId = columnId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$columnId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectColumnInput<TRes> {
  factory CopyWith$Input$DeleteProjectColumnInput(
    Input$DeleteProjectColumnInput instance,
    TRes Function(Input$DeleteProjectColumnInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectColumnInput;

  factory CopyWith$Input$DeleteProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectColumnInput;

  TRes call({
    String? clientMutationId,
    String? columnId,
  });
}

class _CopyWithImpl$Input$DeleteProjectColumnInput<TRes>
    implements CopyWith$Input$DeleteProjectColumnInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectColumnInput _instance;

  final TRes Function(Input$DeleteProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? columnId = _undefined,
  }) =>
      _then(Input$DeleteProjectColumnInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectColumnInput<TRes>
    implements CopyWith$Input$DeleteProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectColumnInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? columnId,
  }) =>
      _res;
}

class Input$DeleteProjectInput {
  factory Input$DeleteProjectInput({
    String? clientMutationId,
    required String projectId,
  }) =>
      Input$DeleteProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
      });

  Input$DeleteProjectInput._(this._$data);

  factory Input$DeleteProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$DeleteProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectInput<Input$DeleteProjectInput> get copyWith =>
      CopyWith$Input$DeleteProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectInput<TRes> {
  factory CopyWith$Input$DeleteProjectInput(
    Input$DeleteProjectInput instance,
    TRes Function(Input$DeleteProjectInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectInput;

  factory CopyWith$Input$DeleteProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$DeleteProjectInput<TRes>
    implements CopyWith$Input$DeleteProjectInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectInput _instance;

  final TRes Function(Input$DeleteProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$DeleteProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectInput<TRes>
    implements CopyWith$Input$DeleteProjectInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
  }) =>
      _res;
}

class Input$DeleteProjectV2FieldInput {
  factory Input$DeleteProjectV2FieldInput({
    String? clientMutationId,
    required String fieldId,
  }) =>
      Input$DeleteProjectV2FieldInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fieldId': fieldId,
      });

  Input$DeleteProjectV2FieldInput._(this._$data);

  factory Input$DeleteProjectV2FieldInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    return Input$DeleteProjectV2FieldInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fieldId => (_$data['fieldId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2FieldInput<Input$DeleteProjectV2FieldInput>
      get copyWith => CopyWith$Input$DeleteProjectV2FieldInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectV2FieldInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fieldId = fieldId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fieldId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2FieldInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2FieldInput(
    Input$DeleteProjectV2FieldInput instance,
    TRes Function(Input$DeleteProjectV2FieldInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2FieldInput;

  factory CopyWith$Input$DeleteProjectV2FieldInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2FieldInput;

  TRes call({
    String? clientMutationId,
    String? fieldId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2FieldInput<TRes>
    implements CopyWith$Input$DeleteProjectV2FieldInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2FieldInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2FieldInput _instance;

  final TRes Function(Input$DeleteProjectV2FieldInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fieldId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2FieldInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2FieldInput<TRes>
    implements CopyWith$Input$DeleteProjectV2FieldInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2FieldInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fieldId,
  }) =>
      _res;
}

class Input$DeleteProjectV2Input {
  factory Input$DeleteProjectV2Input({
    String? clientMutationId,
    required String projectId,
  }) =>
      Input$DeleteProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
      });

  Input$DeleteProjectV2Input._(this._$data);

  factory Input$DeleteProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$DeleteProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2Input<Input$DeleteProjectV2Input>
      get copyWith => CopyWith$Input$DeleteProjectV2Input(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectV2Input) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2Input<TRes> {
  factory CopyWith$Input$DeleteProjectV2Input(
    Input$DeleteProjectV2Input instance,
    TRes Function(Input$DeleteProjectV2Input) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2Input;

  factory CopyWith$Input$DeleteProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2Input;

  TRes call({
    String? clientMutationId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2Input<TRes>
    implements CopyWith$Input$DeleteProjectV2Input<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2Input _instance;

  final TRes Function(Input$DeleteProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2Input<TRes>
    implements CopyWith$Input$DeleteProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
  }) =>
      _res;
}

class Input$DeleteProjectV2ItemInput {
  factory Input$DeleteProjectV2ItemInput({
    String? clientMutationId,
    required String itemId,
    required String projectId,
  }) =>
      Input$DeleteProjectV2ItemInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'itemId': itemId,
        r'projectId': projectId,
      });

  Input$DeleteProjectV2ItemInput._(this._$data);

  factory Input$DeleteProjectV2ItemInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$DeleteProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get itemId => (_$data['itemId'] as String);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2ItemInput<Input$DeleteProjectV2ItemInput>
      get copyWith => CopyWith$Input$DeleteProjectV2ItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectV2ItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$itemId = itemId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$itemId,
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2ItemInput(
    Input$DeleteProjectV2ItemInput instance,
    TRes Function(Input$DeleteProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2ItemInput;

  factory CopyWith$Input$DeleteProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2ItemInput;

  TRes call({
    String? clientMutationId,
    String? itemId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2ItemInput<TRes>
    implements CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2ItemInput _instance;

  final TRes Function(Input$DeleteProjectV2ItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? itemId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2ItemInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2ItemInput<TRes>
    implements CopyWith$Input$DeleteProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? itemId,
    String? projectId,
  }) =>
      _res;
}

class Input$DeleteProjectV2WorkflowInput {
  factory Input$DeleteProjectV2WorkflowInput({
    String? clientMutationId,
    required String workflowId,
  }) =>
      Input$DeleteProjectV2WorkflowInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'workflowId': workflowId,
      });

  Input$DeleteProjectV2WorkflowInput._(this._$data);

  factory Input$DeleteProjectV2WorkflowInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$workflowId = data['workflowId'];
    result$data['workflowId'] = (l$workflowId as String);
    return Input$DeleteProjectV2WorkflowInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get workflowId => (_$data['workflowId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$workflowId = workflowId;
    result$data['workflowId'] = l$workflowId;
    return result$data;
  }

  CopyWith$Input$DeleteProjectV2WorkflowInput<
          Input$DeleteProjectV2WorkflowInput>
      get copyWith => CopyWith$Input$DeleteProjectV2WorkflowInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteProjectV2WorkflowInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$workflowId = workflowId;
    final lOther$workflowId = other.workflowId;
    if (l$workflowId != lOther$workflowId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$workflowId = workflowId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$workflowId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteProjectV2WorkflowInput<TRes> {
  factory CopyWith$Input$DeleteProjectV2WorkflowInput(
    Input$DeleteProjectV2WorkflowInput instance,
    TRes Function(Input$DeleteProjectV2WorkflowInput) then,
  ) = _CopyWithImpl$Input$DeleteProjectV2WorkflowInput;

  factory CopyWith$Input$DeleteProjectV2WorkflowInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteProjectV2WorkflowInput;

  TRes call({
    String? clientMutationId,
    String? workflowId,
  });
}

class _CopyWithImpl$Input$DeleteProjectV2WorkflowInput<TRes>
    implements CopyWith$Input$DeleteProjectV2WorkflowInput<TRes> {
  _CopyWithImpl$Input$DeleteProjectV2WorkflowInput(
    this._instance,
    this._then,
  );

  final Input$DeleteProjectV2WorkflowInput _instance;

  final TRes Function(Input$DeleteProjectV2WorkflowInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? workflowId = _undefined,
  }) =>
      _then(Input$DeleteProjectV2WorkflowInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (workflowId != _undefined && workflowId != null)
          'workflowId': (workflowId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteProjectV2WorkflowInput<TRes>
    implements CopyWith$Input$DeleteProjectV2WorkflowInput<TRes> {
  _CopyWithStubImpl$Input$DeleteProjectV2WorkflowInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? workflowId,
  }) =>
      _res;
}

class Input$DeletePullRequestReviewCommentInput {
  factory Input$DeletePullRequestReviewCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeletePullRequestReviewCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeletePullRequestReviewCommentInput._(this._$data);

  factory Input$DeletePullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeletePullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeletePullRequestReviewCommentInput<
          Input$DeletePullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$DeletePullRequestReviewCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeletePullRequestReviewCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$DeletePullRequestReviewCommentInput(
    Input$DeletePullRequestReviewCommentInput instance,
    TRes Function(Input$DeletePullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$DeletePullRequestReviewCommentInput;

  factory CopyWith$Input$DeletePullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeletePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$DeletePullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeletePullRequestReviewCommentInput _instance;

  final TRes Function(Input$DeletePullRequestReviewCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeletePullRequestReviewCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeletePullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeletePullRequestReviewInput {
  factory Input$DeletePullRequestReviewInput({
    String? clientMutationId,
    required String pullRequestReviewId,
  }) =>
      Input$DeletePullRequestReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestReviewId': pullRequestReviewId,
      });

  Input$DeletePullRequestReviewInput._(this._$data);

  factory Input$DeletePullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    return Input$DeletePullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    return result$data;
  }

  CopyWith$Input$DeletePullRequestReviewInput<
          Input$DeletePullRequestReviewInput>
      get copyWith => CopyWith$Input$DeletePullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeletePullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewId = pullRequestReviewId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestReviewId,
    ]);
  }
}

abstract class CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  factory CopyWith$Input$DeletePullRequestReviewInput(
    Input$DeletePullRequestReviewInput instance,
    TRes Function(Input$DeletePullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$DeletePullRequestReviewInput;

  factory CopyWith$Input$DeletePullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeletePullRequestReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestReviewId,
  });
}

class _CopyWithImpl$Input$DeletePullRequestReviewInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$DeletePullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$DeletePullRequestReviewInput _instance;

  final TRes Function(Input$DeletePullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewId = _undefined,
  }) =>
      _then(Input$DeletePullRequestReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
      }));
}

class _CopyWithStubImpl$Input$DeletePullRequestReviewInput<TRes>
    implements CopyWith$Input$DeletePullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$DeletePullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestReviewId,
  }) =>
      _res;
}

class Input$DeleteRefInput {
  factory Input$DeleteRefInput({
    String? clientMutationId,
    required String refId,
  }) =>
      Input$DeleteRefInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'refId': refId,
      });

  Input$DeleteRefInput._(this._$data);

  factory Input$DeleteRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    return Input$DeleteRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get refId => (_$data['refId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$refId = refId;
    result$data['refId'] = l$refId;
    return result$data;
  }

  CopyWith$Input$DeleteRefInput<Input$DeleteRefInput> get copyWith =>
      CopyWith$Input$DeleteRefInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteRefInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$refId = refId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$refId,
    ]);
  }
}

abstract class CopyWith$Input$DeleteRefInput<TRes> {
  factory CopyWith$Input$DeleteRefInput(
    Input$DeleteRefInput instance,
    TRes Function(Input$DeleteRefInput) then,
  ) = _CopyWithImpl$Input$DeleteRefInput;

  factory CopyWith$Input$DeleteRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteRefInput;

  TRes call({
    String? clientMutationId,
    String? refId,
  });
}

class _CopyWithImpl$Input$DeleteRefInput<TRes>
    implements CopyWith$Input$DeleteRefInput<TRes> {
  _CopyWithImpl$Input$DeleteRefInput(
    this._instance,
    this._then,
  );

  final Input$DeleteRefInput _instance;

  final TRes Function(Input$DeleteRefInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? refId = _undefined,
  }) =>
      _then(Input$DeleteRefInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (refId != _undefined && refId != null) 'refId': (refId as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteRefInput<TRes>
    implements CopyWith$Input$DeleteRefInput<TRes> {
  _CopyWithStubImpl$Input$DeleteRefInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? refId,
  }) =>
      _res;
}

class Input$DeleteTeamDiscussionCommentInput {
  factory Input$DeleteTeamDiscussionCommentInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteTeamDiscussionCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteTeamDiscussionCommentInput._(this._$data);

  factory Input$DeleteTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteTeamDiscussionCommentInput<
          Input$DeleteTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$DeleteTeamDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteTeamDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$DeleteTeamDiscussionCommentInput(
    Input$DeleteTeamDiscussionCommentInput instance,
    TRes Function(Input$DeleteTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput;

  factory CopyWith$Input$DeleteTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$DeleteTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$DeleteTeamDiscussionCommentInput _instance;

  final TRes Function(Input$DeleteTeamDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$DeleteTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteTeamDiscussionInput {
  factory Input$DeleteTeamDiscussionInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteTeamDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteTeamDiscussionInput._(this._$data);

  factory Input$DeleteTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteTeamDiscussionInput<Input$DeleteTeamDiscussionInput>
      get copyWith => CopyWith$Input$DeleteTeamDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteTeamDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  factory CopyWith$Input$DeleteTeamDiscussionInput(
    Input$DeleteTeamDiscussionInput instance,
    TRes Function(Input$DeleteTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$DeleteTeamDiscussionInput;

  factory CopyWith$Input$DeleteTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteTeamDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteTeamDiscussionInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$DeleteTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$DeleteTeamDiscussionInput _instance;

  final TRes Function(Input$DeleteTeamDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteTeamDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteTeamDiscussionInput<TRes>
    implements CopyWith$Input$DeleteTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$DeleteTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeleteVerifiableDomainInput {
  factory Input$DeleteVerifiableDomainInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$DeleteVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$DeleteVerifiableDomainInput._(this._$data);

  factory Input$DeleteVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$DeleteVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$DeleteVerifiableDomainInput<Input$DeleteVerifiableDomainInput>
      get copyWith => CopyWith$Input$DeleteVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeleteVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  factory CopyWith$Input$DeleteVerifiableDomainInput(
    Input$DeleteVerifiableDomainInput instance,
    TRes Function(Input$DeleteVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$DeleteVerifiableDomainInput;

  factory CopyWith$Input$DeleteVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DeleteVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$DeleteVerifiableDomainInput<TRes>
    implements CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$DeleteVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$DeleteVerifiableDomainInput _instance;

  final TRes Function(Input$DeleteVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$DeleteVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$DeleteVerifiableDomainInput<TRes>
    implements CopyWith$Input$DeleteVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$DeleteVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$DeploymentOrder {
  factory Input$DeploymentOrder({
    required Enum$OrderDirection direction,
    required Enum$DeploymentOrderField field,
  }) =>
      Input$DeploymentOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$DeploymentOrder._(this._$data);

  factory Input$DeploymentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DeploymentOrderField((l$field as String));
    return Input$DeploymentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$DeploymentOrderField get field =>
      (_$data['field'] as Enum$DeploymentOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$DeploymentOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$DeploymentOrder<Input$DeploymentOrder> get copyWith =>
      CopyWith$Input$DeploymentOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DeploymentOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$DeploymentOrder<TRes> {
  factory CopyWith$Input$DeploymentOrder(
    Input$DeploymentOrder instance,
    TRes Function(Input$DeploymentOrder) then,
  ) = _CopyWithImpl$Input$DeploymentOrder;

  factory CopyWith$Input$DeploymentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DeploymentOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$DeploymentOrderField? field,
  });
}

class _CopyWithImpl$Input$DeploymentOrder<TRes>
    implements CopyWith$Input$DeploymentOrder<TRes> {
  _CopyWithImpl$Input$DeploymentOrder(
    this._instance,
    this._then,
  );

  final Input$DeploymentOrder _instance;

  final TRes Function(Input$DeploymentOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$DeploymentOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$DeploymentOrderField),
      }));
}

class _CopyWithStubImpl$Input$DeploymentOrder<TRes>
    implements CopyWith$Input$DeploymentOrder<TRes> {
  _CopyWithStubImpl$Input$DeploymentOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$DeploymentOrderField? field,
  }) =>
      _res;
}

class Input$DisablePullRequestAutoMergeInput {
  factory Input$DisablePullRequestAutoMergeInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$DisablePullRequestAutoMergeInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$DisablePullRequestAutoMergeInput._(this._$data);

  factory Input$DisablePullRequestAutoMergeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$DisablePullRequestAutoMergeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$DisablePullRequestAutoMergeInput<
          Input$DisablePullRequestAutoMergeInput>
      get copyWith => CopyWith$Input$DisablePullRequestAutoMergeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DisablePullRequestAutoMergeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  factory CopyWith$Input$DisablePullRequestAutoMergeInput(
    Input$DisablePullRequestAutoMergeInput instance,
    TRes Function(Input$DisablePullRequestAutoMergeInput) then,
  ) = _CopyWithImpl$Input$DisablePullRequestAutoMergeInput;

  factory CopyWith$Input$DisablePullRequestAutoMergeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$DisablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  _CopyWithImpl$Input$DisablePullRequestAutoMergeInput(
    this._instance,
    this._then,
  );

  final Input$DisablePullRequestAutoMergeInput _instance;

  final TRes Function(Input$DisablePullRequestAutoMergeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$DisablePullRequestAutoMergeInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$DisablePullRequestAutoMergeInput<TRes> {
  _CopyWithStubImpl$Input$DisablePullRequestAutoMergeInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$DiscussionOrder {
  factory Input$DiscussionOrder({
    required Enum$OrderDirection direction,
    required Enum$DiscussionOrderField field,
  }) =>
      Input$DiscussionOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$DiscussionOrder._(this._$data);

  factory Input$DiscussionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DiscussionOrderField((l$field as String));
    return Input$DiscussionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$DiscussionOrderField get field =>
      (_$data['field'] as Enum$DiscussionOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$DiscussionOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$DiscussionOrder<Input$DiscussionOrder> get copyWith =>
      CopyWith$Input$DiscussionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiscussionOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$DiscussionOrder<TRes> {
  factory CopyWith$Input$DiscussionOrder(
    Input$DiscussionOrder instance,
    TRes Function(Input$DiscussionOrder) then,
  ) = _CopyWithImpl$Input$DiscussionOrder;

  factory CopyWith$Input$DiscussionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscussionOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$DiscussionOrderField? field,
  });
}

class _CopyWithImpl$Input$DiscussionOrder<TRes>
    implements CopyWith$Input$DiscussionOrder<TRes> {
  _CopyWithImpl$Input$DiscussionOrder(
    this._instance,
    this._then,
  );

  final Input$DiscussionOrder _instance;

  final TRes Function(Input$DiscussionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$DiscussionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$DiscussionOrderField),
      }));
}

class _CopyWithStubImpl$Input$DiscussionOrder<TRes>
    implements CopyWith$Input$DiscussionOrder<TRes> {
  _CopyWithStubImpl$Input$DiscussionOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$DiscussionOrderField? field,
  }) =>
      _res;
}

class Input$DiscussionPollOptionOrder {
  factory Input$DiscussionPollOptionOrder({
    required Enum$OrderDirection direction,
    required Enum$DiscussionPollOptionOrderField field,
  }) =>
      Input$DiscussionPollOptionOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$DiscussionPollOptionOrder._(this._$data);

  factory Input$DiscussionPollOptionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$DiscussionPollOptionOrderField((l$field as String));
    return Input$DiscussionPollOptionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$DiscussionPollOptionOrderField get field =>
      (_$data['field'] as Enum$DiscussionPollOptionOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$DiscussionPollOptionOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$DiscussionPollOptionOrder<Input$DiscussionPollOptionOrder>
      get copyWith => CopyWith$Input$DiscussionPollOptionOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DiscussionPollOptionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  factory CopyWith$Input$DiscussionPollOptionOrder(
    Input$DiscussionPollOptionOrder instance,
    TRes Function(Input$DiscussionPollOptionOrder) then,
  ) = _CopyWithImpl$Input$DiscussionPollOptionOrder;

  factory CopyWith$Input$DiscussionPollOptionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$DiscussionPollOptionOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$DiscussionPollOptionOrderField? field,
  });
}

class _CopyWithImpl$Input$DiscussionPollOptionOrder<TRes>
    implements CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  _CopyWithImpl$Input$DiscussionPollOptionOrder(
    this._instance,
    this._then,
  );

  final Input$DiscussionPollOptionOrder _instance;

  final TRes Function(Input$DiscussionPollOptionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$DiscussionPollOptionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$DiscussionPollOptionOrderField),
      }));
}

class _CopyWithStubImpl$Input$DiscussionPollOptionOrder<TRes>
    implements CopyWith$Input$DiscussionPollOptionOrder<TRes> {
  _CopyWithStubImpl$Input$DiscussionPollOptionOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$DiscussionPollOptionOrderField? field,
  }) =>
      _res;
}

class Input$DismissPullRequestReviewInput {
  factory Input$DismissPullRequestReviewInput({
    String? clientMutationId,
    required String message,
    required String pullRequestReviewId,
  }) =>
      Input$DismissPullRequestReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'message': message,
        r'pullRequestReviewId': pullRequestReviewId,
      });

  Input$DismissPullRequestReviewInput._(this._$data);

  factory Input$DismissPullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$message = data['message'];
    result$data['message'] = (l$message as String);
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    return Input$DismissPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get message => (_$data['message'] as String);
  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$message = message;
    result$data['message'] = l$message;
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    return result$data;
  }

  CopyWith$Input$DismissPullRequestReviewInput<
          Input$DismissPullRequestReviewInput>
      get copyWith => CopyWith$Input$DismissPullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DismissPullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$message = message;
    final lOther$message = other.message;
    if (l$message != lOther$message) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$message = message;
    final l$pullRequestReviewId = pullRequestReviewId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$message,
      l$pullRequestReviewId,
    ]);
  }
}

abstract class CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  factory CopyWith$Input$DismissPullRequestReviewInput(
    Input$DismissPullRequestReviewInput instance,
    TRes Function(Input$DismissPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$DismissPullRequestReviewInput;

  factory CopyWith$Input$DismissPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DismissPullRequestReviewInput;

  TRes call({
    String? clientMutationId,
    String? message,
    String? pullRequestReviewId,
  });
}

class _CopyWithImpl$Input$DismissPullRequestReviewInput<TRes>
    implements CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$DismissPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$DismissPullRequestReviewInput _instance;

  final TRes Function(Input$DismissPullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? message = _undefined,
    Object? pullRequestReviewId = _undefined,
  }) =>
      _then(Input$DismissPullRequestReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (message != _undefined && message != null)
          'message': (message as String),
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
      }));
}

class _CopyWithStubImpl$Input$DismissPullRequestReviewInput<TRes>
    implements CopyWith$Input$DismissPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$DismissPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? message,
    String? pullRequestReviewId,
  }) =>
      _res;
}

class Input$DismissRepositoryVulnerabilityAlertInput {
  factory Input$DismissRepositoryVulnerabilityAlertInput({
    String? clientMutationId,
    required Enum$DismissReason dismissReason,
    required String repositoryVulnerabilityAlertId,
  }) =>
      Input$DismissRepositoryVulnerabilityAlertInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'dismissReason': dismissReason,
        r'repositoryVulnerabilityAlertId': repositoryVulnerabilityAlertId,
      });

  Input$DismissRepositoryVulnerabilityAlertInput._(this._$data);

  factory Input$DismissRepositoryVulnerabilityAlertInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$dismissReason = data['dismissReason'];
    result$data['dismissReason'] =
        fromJson$Enum$DismissReason((l$dismissReason as String));
    final l$repositoryVulnerabilityAlertId =
        data['repositoryVulnerabilityAlertId'];
    result$data['repositoryVulnerabilityAlertId'] =
        (l$repositoryVulnerabilityAlertId as String);
    return Input$DismissRepositoryVulnerabilityAlertInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$DismissReason get dismissReason =>
      (_$data['dismissReason'] as Enum$DismissReason);
  String get repositoryVulnerabilityAlertId =>
      (_$data['repositoryVulnerabilityAlertId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$dismissReason = dismissReason;
    result$data['dismissReason'] = toJson$Enum$DismissReason(l$dismissReason);
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    result$data['repositoryVulnerabilityAlertId'] =
        l$repositoryVulnerabilityAlertId;
    return result$data;
  }

  CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<
          Input$DismissRepositoryVulnerabilityAlertInput>
      get copyWith => CopyWith$Input$DismissRepositoryVulnerabilityAlertInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DismissRepositoryVulnerabilityAlertInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$dismissReason = dismissReason;
    final lOther$dismissReason = other.dismissReason;
    if (l$dismissReason != lOther$dismissReason) {
      return false;
    }
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    final lOther$repositoryVulnerabilityAlertId =
        other.repositoryVulnerabilityAlertId;
    if (l$repositoryVulnerabilityAlertId !=
        lOther$repositoryVulnerabilityAlertId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$dismissReason = dismissReason;
    final l$repositoryVulnerabilityAlertId = repositoryVulnerabilityAlertId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$dismissReason,
      l$repositoryVulnerabilityAlertId,
    ]);
  }
}

abstract class CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  factory CopyWith$Input$DismissRepositoryVulnerabilityAlertInput(
    Input$DismissRepositoryVulnerabilityAlertInput instance,
    TRes Function(Input$DismissRepositoryVulnerabilityAlertInput) then,
  ) = _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput;

  factory CopyWith$Input$DismissRepositoryVulnerabilityAlertInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput;

  TRes call({
    String? clientMutationId,
    Enum$DismissReason? dismissReason,
    String? repositoryVulnerabilityAlertId,
  });
}

class _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput<TRes>
    implements CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  _CopyWithImpl$Input$DismissRepositoryVulnerabilityAlertInput(
    this._instance,
    this._then,
  );

  final Input$DismissRepositoryVulnerabilityAlertInput _instance;

  final TRes Function(Input$DismissRepositoryVulnerabilityAlertInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? dismissReason = _undefined,
    Object? repositoryVulnerabilityAlertId = _undefined,
  }) =>
      _then(Input$DismissRepositoryVulnerabilityAlertInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (dismissReason != _undefined && dismissReason != null)
          'dismissReason': (dismissReason as Enum$DismissReason),
        if (repositoryVulnerabilityAlertId != _undefined &&
            repositoryVulnerabilityAlertId != null)
          'repositoryVulnerabilityAlertId':
              (repositoryVulnerabilityAlertId as String),
      }));
}

class _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput<TRes>
    implements CopyWith$Input$DismissRepositoryVulnerabilityAlertInput<TRes> {
  _CopyWithStubImpl$Input$DismissRepositoryVulnerabilityAlertInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$DismissReason? dismissReason,
    String? repositoryVulnerabilityAlertId,
  }) =>
      _res;
}

class Input$DraftPullRequestReviewComment {
  factory Input$DraftPullRequestReviewComment({
    required String body,
    required String path,
    required int position,
  }) =>
      Input$DraftPullRequestReviewComment._({
        r'body': body,
        r'path': path,
        r'position': position,
      });

  Input$DraftPullRequestReviewComment._(this._$data);

  factory Input$DraftPullRequestReviewComment.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$position = data['position'];
    result$data['position'] = (l$position as int);
    return Input$DraftPullRequestReviewComment._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String get path => (_$data['path'] as String);
  int get position => (_$data['position'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    final l$path = path;
    result$data['path'] = l$path;
    final l$position = position;
    result$data['position'] = l$position;
    return result$data;
  }

  CopyWith$Input$DraftPullRequestReviewComment<
          Input$DraftPullRequestReviewComment>
      get copyWith => CopyWith$Input$DraftPullRequestReviewComment(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DraftPullRequestReviewComment) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$path = path;
    final l$position = position;
    return Object.hashAll([
      l$body,
      l$path,
      l$position,
    ]);
  }
}

abstract class CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  factory CopyWith$Input$DraftPullRequestReviewComment(
    Input$DraftPullRequestReviewComment instance,
    TRes Function(Input$DraftPullRequestReviewComment) then,
  ) = _CopyWithImpl$Input$DraftPullRequestReviewComment;

  factory CopyWith$Input$DraftPullRequestReviewComment.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftPullRequestReviewComment;

  TRes call({
    String? body,
    String? path,
    int? position,
  });
}

class _CopyWithImpl$Input$DraftPullRequestReviewComment<TRes>
    implements CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  _CopyWithImpl$Input$DraftPullRequestReviewComment(
    this._instance,
    this._then,
  );

  final Input$DraftPullRequestReviewComment _instance;

  final TRes Function(Input$DraftPullRequestReviewComment) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? path = _undefined,
    Object? position = _undefined,
  }) =>
      _then(Input$DraftPullRequestReviewComment._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (path != _undefined && path != null) 'path': (path as String),
        if (position != _undefined && position != null)
          'position': (position as int),
      }));
}

class _CopyWithStubImpl$Input$DraftPullRequestReviewComment<TRes>
    implements CopyWith$Input$DraftPullRequestReviewComment<TRes> {
  _CopyWithStubImpl$Input$DraftPullRequestReviewComment(this._res);

  TRes _res;

  call({
    String? body,
    String? path,
    int? position,
  }) =>
      _res;
}

class Input$DraftPullRequestReviewThread {
  factory Input$DraftPullRequestReviewThread({
    required String body,
    required int line,
    required String path,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
  }) =>
      Input$DraftPullRequestReviewThread._({
        r'body': body,
        r'line': line,
        r'path': path,
        if (side != null) r'side': side,
        if (startLine != null) r'startLine': startLine,
        if (startSide != null) r'startSide': startSide,
      });

  Input$DraftPullRequestReviewThread._(this._$data);

  factory Input$DraftPullRequestReviewThread.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    final l$line = data['line'];
    result$data['line'] = (l$line as int);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    if (data.containsKey('side')) {
      final l$side = data['side'];
      result$data['side'] =
          l$side == null ? null : fromJson$Enum$DiffSide((l$side as String));
    }
    if (data.containsKey('startLine')) {
      final l$startLine = data['startLine'];
      result$data['startLine'] = (l$startLine as int?);
    }
    if (data.containsKey('startSide')) {
      final l$startSide = data['startSide'];
      result$data['startSide'] = l$startSide == null
          ? null
          : fromJson$Enum$DiffSide((l$startSide as String));
    }
    return Input$DraftPullRequestReviewThread._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  int get line => (_$data['line'] as int);
  String get path => (_$data['path'] as String);
  Enum$DiffSide? get side => (_$data['side'] as Enum$DiffSide?);
  int? get startLine => (_$data['startLine'] as int?);
  Enum$DiffSide? get startSide => (_$data['startSide'] as Enum$DiffSide?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    final l$line = line;
    result$data['line'] = l$line;
    final l$path = path;
    result$data['path'] = l$path;
    if (_$data.containsKey('side')) {
      final l$side = side;
      result$data['side'] =
          l$side == null ? null : toJson$Enum$DiffSide(l$side);
    }
    if (_$data.containsKey('startLine')) {
      final l$startLine = startLine;
      result$data['startLine'] = l$startLine;
    }
    if (_$data.containsKey('startSide')) {
      final l$startSide = startSide;
      result$data['startSide'] =
          l$startSide == null ? null : toJson$Enum$DiffSide(l$startSide);
    }
    return result$data;
  }

  CopyWith$Input$DraftPullRequestReviewThread<
          Input$DraftPullRequestReviewThread>
      get copyWith => CopyWith$Input$DraftPullRequestReviewThread(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DraftPullRequestReviewThread) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$line = line;
    final lOther$line = other.line;
    if (l$line != lOther$line) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$side = side;
    final lOther$side = other.side;
    if (_$data.containsKey('side') != other._$data.containsKey('side')) {
      return false;
    }
    if (l$side != lOther$side) {
      return false;
    }
    final l$startLine = startLine;
    final lOther$startLine = other.startLine;
    if (_$data.containsKey('startLine') !=
        other._$data.containsKey('startLine')) {
      return false;
    }
    if (l$startLine != lOther$startLine) {
      return false;
    }
    final l$startSide = startSide;
    final lOther$startSide = other.startSide;
    if (_$data.containsKey('startSide') !=
        other._$data.containsKey('startSide')) {
      return false;
    }
    if (l$startSide != lOther$startSide) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$line = line;
    final l$path = path;
    final l$side = side;
    final l$startLine = startLine;
    final l$startSide = startSide;
    return Object.hashAll([
      l$body,
      l$line,
      l$path,
      _$data.containsKey('side') ? l$side : const {},
      _$data.containsKey('startLine') ? l$startLine : const {},
      _$data.containsKey('startSide') ? l$startSide : const {},
    ]);
  }
}

abstract class CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  factory CopyWith$Input$DraftPullRequestReviewThread(
    Input$DraftPullRequestReviewThread instance,
    TRes Function(Input$DraftPullRequestReviewThread) then,
  ) = _CopyWithImpl$Input$DraftPullRequestReviewThread;

  factory CopyWith$Input$DraftPullRequestReviewThread.stub(TRes res) =
      _CopyWithStubImpl$Input$DraftPullRequestReviewThread;

  TRes call({
    String? body,
    int? line,
    String? path,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
  });
}

class _CopyWithImpl$Input$DraftPullRequestReviewThread<TRes>
    implements CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  _CopyWithImpl$Input$DraftPullRequestReviewThread(
    this._instance,
    this._then,
  );

  final Input$DraftPullRequestReviewThread _instance;

  final TRes Function(Input$DraftPullRequestReviewThread) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? line = _undefined,
    Object? path = _undefined,
    Object? side = _undefined,
    Object? startLine = _undefined,
    Object? startSide = _undefined,
  }) =>
      _then(Input$DraftPullRequestReviewThread._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (line != _undefined && line != null) 'line': (line as int),
        if (path != _undefined && path != null) 'path': (path as String),
        if (side != _undefined) 'side': (side as Enum$DiffSide?),
        if (startLine != _undefined) 'startLine': (startLine as int?),
        if (startSide != _undefined) 'startSide': (startSide as Enum$DiffSide?),
      }));
}

class _CopyWithStubImpl$Input$DraftPullRequestReviewThread<TRes>
    implements CopyWith$Input$DraftPullRequestReviewThread<TRes> {
  _CopyWithStubImpl$Input$DraftPullRequestReviewThread(this._res);

  TRes _res;

  call({
    String? body,
    int? line,
    String? path,
    Enum$DiffSide? side,
    int? startLine,
    Enum$DiffSide? startSide,
  }) =>
      _res;
}

class Input$EnablePullRequestAutoMergeInput {
  factory Input$EnablePullRequestAutoMergeInput({
    String? authorEmail,
    String? clientMutationId,
    String? commitBody,
    String? commitHeadline,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    required String pullRequestId,
  }) =>
      Input$EnablePullRequestAutoMergeInput._({
        if (authorEmail != null) r'authorEmail': authorEmail,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (commitBody != null) r'commitBody': commitBody,
        if (commitHeadline != null) r'commitHeadline': commitHeadline,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
        if (mergeMethod != null) r'mergeMethod': mergeMethod,
        r'pullRequestId': pullRequestId,
      });

  Input$EnablePullRequestAutoMergeInput._(this._$data);

  factory Input$EnablePullRequestAutoMergeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('commitBody')) {
      final l$commitBody = data['commitBody'];
      result$data['commitBody'] = (l$commitBody as String?);
    }
    if (data.containsKey('commitHeadline')) {
      final l$commitHeadline = data['commitHeadline'];
      result$data['commitHeadline'] = (l$commitHeadline as String?);
    }
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    if (data.containsKey('mergeMethod')) {
      final l$mergeMethod = data['mergeMethod'];
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : fromJson$Enum$PullRequestMergeMethod((l$mergeMethod as String));
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$EnablePullRequestAutoMergeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get authorEmail => (_$data['authorEmail'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get commitBody => (_$data['commitBody'] as String?);
  String? get commitHeadline => (_$data['commitHeadline'] as String?);
  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);
  Enum$PullRequestMergeMethod? get mergeMethod =>
      (_$data['mergeMethod'] as Enum$PullRequestMergeMethod?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('commitBody')) {
      final l$commitBody = commitBody;
      result$data['commitBody'] = l$commitBody;
    }
    if (_$data.containsKey('commitHeadline')) {
      final l$commitHeadline = commitHeadline;
      result$data['commitHeadline'] = l$commitHeadline;
    }
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    if (_$data.containsKey('mergeMethod')) {
      final l$mergeMethod = mergeMethod;
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : toJson$Enum$PullRequestMergeMethod(l$mergeMethod);
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$EnablePullRequestAutoMergeInput<
          Input$EnablePullRequestAutoMergeInput>
      get copyWith => CopyWith$Input$EnablePullRequestAutoMergeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnablePullRequestAutoMergeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$commitBody = commitBody;
    final lOther$commitBody = other.commitBody;
    if (_$data.containsKey('commitBody') !=
        other._$data.containsKey('commitBody')) {
      return false;
    }
    if (l$commitBody != lOther$commitBody) {
      return false;
    }
    final l$commitHeadline = commitHeadline;
    final lOther$commitHeadline = other.commitHeadline;
    if (_$data.containsKey('commitHeadline') !=
        other._$data.containsKey('commitHeadline')) {
      return false;
    }
    if (l$commitHeadline != lOther$commitHeadline) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$mergeMethod = mergeMethod;
    final lOther$mergeMethod = other.mergeMethod;
    if (_$data.containsKey('mergeMethod') !=
        other._$data.containsKey('mergeMethod')) {
      return false;
    }
    if (l$mergeMethod != lOther$mergeMethod) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$authorEmail = authorEmail;
    final l$clientMutationId = clientMutationId;
    final l$commitBody = commitBody;
    final l$commitHeadline = commitHeadline;
    final l$expectedHeadOid = expectedHeadOid;
    final l$mergeMethod = mergeMethod;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('commitBody') ? l$commitBody : const {},
      _$data.containsKey('commitHeadline') ? l$commitHeadline : const {},
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
      _$data.containsKey('mergeMethod') ? l$mergeMethod : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  factory CopyWith$Input$EnablePullRequestAutoMergeInput(
    Input$EnablePullRequestAutoMergeInput instance,
    TRes Function(Input$EnablePullRequestAutoMergeInput) then,
  ) = _CopyWithImpl$Input$EnablePullRequestAutoMergeInput;

  factory CopyWith$Input$EnablePullRequestAutoMergeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput;

  TRes call({
    String? authorEmail,
    String? clientMutationId,
    String? commitBody,
    String? commitHeadline,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$EnablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  _CopyWithImpl$Input$EnablePullRequestAutoMergeInput(
    this._instance,
    this._then,
  );

  final Input$EnablePullRequestAutoMergeInput _instance;

  final TRes Function(Input$EnablePullRequestAutoMergeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? authorEmail = _undefined,
    Object? clientMutationId = _undefined,
    Object? commitBody = _undefined,
    Object? commitHeadline = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? mergeMethod = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$EnablePullRequestAutoMergeInput._({
        ..._instance._$data,
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (commitBody != _undefined) 'commitBody': (commitBody as String?),
        if (commitHeadline != _undefined)
          'commitHeadline': (commitHeadline as String?),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
        if (mergeMethod != _undefined)
          'mergeMethod': (mergeMethod as Enum$PullRequestMergeMethod?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput<TRes>
    implements CopyWith$Input$EnablePullRequestAutoMergeInput<TRes> {
  _CopyWithStubImpl$Input$EnablePullRequestAutoMergeInput(this._res);

  TRes _res;

  call({
    String? authorEmail,
    String? clientMutationId,
    String? commitBody,
    String? commitHeadline,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$EnterpriseAdministratorInvitationOrder {
  factory Input$EnterpriseAdministratorInvitationOrder({
    required Enum$OrderDirection direction,
    required Enum$EnterpriseAdministratorInvitationOrderField field,
  }) =>
      Input$EnterpriseAdministratorInvitationOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$EnterpriseAdministratorInvitationOrder._(this._$data);

  factory Input$EnterpriseAdministratorInvitationOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseAdministratorInvitationOrderField(
            (l$field as String));
    return Input$EnterpriseAdministratorInvitationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$EnterpriseAdministratorInvitationOrderField get field =>
      (_$data['field'] as Enum$EnterpriseAdministratorInvitationOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseAdministratorInvitationOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$EnterpriseAdministratorInvitationOrder<
          Input$EnterpriseAdministratorInvitationOrder>
      get copyWith => CopyWith$Input$EnterpriseAdministratorInvitationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseAdministratorInvitationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  factory CopyWith$Input$EnterpriseAdministratorInvitationOrder(
    Input$EnterpriseAdministratorInvitationOrder instance,
    TRes Function(Input$EnterpriseAdministratorInvitationOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder;

  factory CopyWith$Input$EnterpriseAdministratorInvitationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseAdministratorInvitationOrderField? field,
  });
}

class _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseAdministratorInvitationOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseAdministratorInvitationOrder _instance;

  final TRes Function(Input$EnterpriseAdministratorInvitationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EnterpriseAdministratorInvitationOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseAdministratorInvitationOrderField),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder<TRes>
    implements CopyWith$Input$EnterpriseAdministratorInvitationOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseAdministratorInvitationOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseAdministratorInvitationOrderField? field,
  }) =>
      _res;
}

class Input$EnterpriseMemberOrder {
  factory Input$EnterpriseMemberOrder({
    required Enum$OrderDirection direction,
    required Enum$EnterpriseMemberOrderField field,
  }) =>
      Input$EnterpriseMemberOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$EnterpriseMemberOrder._(this._$data);

  factory Input$EnterpriseMemberOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseMemberOrderField((l$field as String));
    return Input$EnterpriseMemberOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$EnterpriseMemberOrderField get field =>
      (_$data['field'] as Enum$EnterpriseMemberOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$EnterpriseMemberOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$EnterpriseMemberOrder<Input$EnterpriseMemberOrder>
      get copyWith => CopyWith$Input$EnterpriseMemberOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseMemberOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseMemberOrder<TRes> {
  factory CopyWith$Input$EnterpriseMemberOrder(
    Input$EnterpriseMemberOrder instance,
    TRes Function(Input$EnterpriseMemberOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseMemberOrder;

  factory CopyWith$Input$EnterpriseMemberOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseMemberOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseMemberOrderField? field,
  });
}

class _CopyWithImpl$Input$EnterpriseMemberOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseMemberOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseMemberOrder _instance;

  final TRes Function(Input$EnterpriseMemberOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EnterpriseMemberOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseMemberOrderField),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseMemberOrder<TRes>
    implements CopyWith$Input$EnterpriseMemberOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseMemberOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseMemberOrderField? field,
  }) =>
      _res;
}

class Input$EnterpriseServerInstallationOrder {
  factory Input$EnterpriseServerInstallationOrder({
    required Enum$OrderDirection direction,
    required Enum$EnterpriseServerInstallationOrderField field,
  }) =>
      Input$EnterpriseServerInstallationOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$EnterpriseServerInstallationOrder._(this._$data);

  factory Input$EnterpriseServerInstallationOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$EnterpriseServerInstallationOrderField(
        (l$field as String));
    return Input$EnterpriseServerInstallationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$EnterpriseServerInstallationOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerInstallationOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerInstallationOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerInstallationOrder<
          Input$EnterpriseServerInstallationOrder>
      get copyWith => CopyWith$Input$EnterpriseServerInstallationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerInstallationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerInstallationOrder(
    Input$EnterpriseServerInstallationOrder instance,
    TRes Function(Input$EnterpriseServerInstallationOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerInstallationOrder;

  factory CopyWith$Input$EnterpriseServerInstallationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerInstallationOrderField? field,
  });
}

class _CopyWithImpl$Input$EnterpriseServerInstallationOrder<TRes>
    implements CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerInstallationOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerInstallationOrder _instance;

  final TRes Function(Input$EnterpriseServerInstallationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EnterpriseServerInstallationOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerInstallationOrderField),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder<TRes>
    implements CopyWith$Input$EnterpriseServerInstallationOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerInstallationOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerInstallationOrderField? field,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountEmailOrder {
  factory Input$EnterpriseServerUserAccountEmailOrder({
    required Enum$OrderDirection direction,
    required Enum$EnterpriseServerUserAccountEmailOrderField field,
  }) =>
      Input$EnterpriseServerUserAccountEmailOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$EnterpriseServerUserAccountEmailOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountEmailOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseServerUserAccountEmailOrderField(
            (l$field as String));
    return Input$EnterpriseServerUserAccountEmailOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$EnterpriseServerUserAccountEmailOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountEmailOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountEmailOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountEmailOrder<
          Input$EnterpriseServerUserAccountEmailOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountEmailOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerUserAccountEmailOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountEmailOrder(
    Input$EnterpriseServerUserAccountEmailOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountEmailOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountEmailOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerUserAccountEmailOrderField? field,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountEmailOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountEmailOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountEmailOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountEmailOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountEmailOrderField),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountEmailOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountEmailOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerUserAccountEmailOrderField? field,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountOrder {
  factory Input$EnterpriseServerUserAccountOrder({
    required Enum$OrderDirection direction,
    required Enum$EnterpriseServerUserAccountOrderField field,
  }) =>
      Input$EnterpriseServerUserAccountOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$EnterpriseServerUserAccountOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$EnterpriseServerUserAccountOrderField(
        (l$field as String));
    return Input$EnterpriseServerUserAccountOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$EnterpriseServerUserAccountOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountOrder<
          Input$EnterpriseServerUserAccountOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerUserAccountOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountOrder(
    Input$EnterpriseServerUserAccountOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerUserAccountOrderField? field,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountOrderField),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerUserAccountOrderField? field,
  }) =>
      _res;
}

class Input$EnterpriseServerUserAccountsUploadOrder {
  factory Input$EnterpriseServerUserAccountsUploadOrder({
    required Enum$OrderDirection direction,
    required Enum$EnterpriseServerUserAccountsUploadOrderField field,
  }) =>
      Input$EnterpriseServerUserAccountsUploadOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$EnterpriseServerUserAccountsUploadOrder._(this._$data);

  factory Input$EnterpriseServerUserAccountsUploadOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$EnterpriseServerUserAccountsUploadOrderField(
            (l$field as String));
    return Input$EnterpriseServerUserAccountsUploadOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$EnterpriseServerUserAccountsUploadOrderField get field =>
      (_$data['field'] as Enum$EnterpriseServerUserAccountsUploadOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] =
        toJson$Enum$EnterpriseServerUserAccountsUploadOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<
          Input$EnterpriseServerUserAccountsUploadOrder>
      get copyWith => CopyWith$Input$EnterpriseServerUserAccountsUploadOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$EnterpriseServerUserAccountsUploadOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  factory CopyWith$Input$EnterpriseServerUserAccountsUploadOrder(
    Input$EnterpriseServerUserAccountsUploadOrder instance,
    TRes Function(Input$EnterpriseServerUserAccountsUploadOrder) then,
  ) = _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder;

  factory CopyWith$Input$EnterpriseServerUserAccountsUploadOrder.stub(
          TRes res) =
      _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerUserAccountsUploadOrderField? field,
  });
}

class _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  _CopyWithImpl$Input$EnterpriseServerUserAccountsUploadOrder(
    this._instance,
    this._then,
  );

  final Input$EnterpriseServerUserAccountsUploadOrder _instance;

  final TRes Function(Input$EnterpriseServerUserAccountsUploadOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$EnterpriseServerUserAccountsUploadOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$EnterpriseServerUserAccountsUploadOrderField),
      }));
}

class _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder<TRes>
    implements CopyWith$Input$EnterpriseServerUserAccountsUploadOrder<TRes> {
  _CopyWithStubImpl$Input$EnterpriseServerUserAccountsUploadOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$EnterpriseServerUserAccountsUploadOrderField? field,
  }) =>
      _res;
}

class Input$FileAddition {
  factory Input$FileAddition({
    required String contents,
    required String path,
  }) =>
      Input$FileAddition._({
        r'contents': contents,
        r'path': path,
      });

  Input$FileAddition._(this._$data);

  factory Input$FileAddition.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$contents = data['contents'];
    result$data['contents'] = (l$contents as String);
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    return Input$FileAddition._(result$data);
  }

  Map<String, dynamic> _$data;

  String get contents => (_$data['contents'] as String);
  String get path => (_$data['path'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$contents = contents;
    result$data['contents'] = l$contents;
    final l$path = path;
    result$data['path'] = l$path;
    return result$data;
  }

  CopyWith$Input$FileAddition<Input$FileAddition> get copyWith =>
      CopyWith$Input$FileAddition(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FileAddition) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$contents = contents;
    final lOther$contents = other.contents;
    if (l$contents != lOther$contents) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$contents = contents;
    final l$path = path;
    return Object.hashAll([
      l$contents,
      l$path,
    ]);
  }
}

abstract class CopyWith$Input$FileAddition<TRes> {
  factory CopyWith$Input$FileAddition(
    Input$FileAddition instance,
    TRes Function(Input$FileAddition) then,
  ) = _CopyWithImpl$Input$FileAddition;

  factory CopyWith$Input$FileAddition.stub(TRes res) =
      _CopyWithStubImpl$Input$FileAddition;

  TRes call({
    String? contents,
    String? path,
  });
}

class _CopyWithImpl$Input$FileAddition<TRes>
    implements CopyWith$Input$FileAddition<TRes> {
  _CopyWithImpl$Input$FileAddition(
    this._instance,
    this._then,
  );

  final Input$FileAddition _instance;

  final TRes Function(Input$FileAddition) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? contents = _undefined,
    Object? path = _undefined,
  }) =>
      _then(Input$FileAddition._({
        ..._instance._$data,
        if (contents != _undefined && contents != null)
          'contents': (contents as String),
        if (path != _undefined && path != null) 'path': (path as String),
      }));
}

class _CopyWithStubImpl$Input$FileAddition<TRes>
    implements CopyWith$Input$FileAddition<TRes> {
  _CopyWithStubImpl$Input$FileAddition(this._res);

  TRes _res;

  call({
    String? contents,
    String? path,
  }) =>
      _res;
}

class Input$FileChanges {
  factory Input$FileChanges({
    List<Input$FileAddition>? additions,
    List<Input$FileDeletion>? deletions,
  }) =>
      Input$FileChanges._({
        if (additions != null) r'additions': additions,
        if (deletions != null) r'deletions': deletions,
      });

  Input$FileChanges._(this._$data);

  factory Input$FileChanges.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('additions')) {
      final l$additions = data['additions'];
      result$data['additions'] = (l$additions as List<dynamic>?)
          ?.map((e) => Input$FileAddition.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deletions')) {
      final l$deletions = data['deletions'];
      result$data['deletions'] = (l$deletions as List<dynamic>?)
          ?.map((e) => Input$FileDeletion.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    return Input$FileChanges._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$FileAddition>? get additions =>
      (_$data['additions'] as List<Input$FileAddition>?);
  List<Input$FileDeletion>? get deletions =>
      (_$data['deletions'] as List<Input$FileDeletion>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('additions')) {
      final l$additions = additions;
      result$data['additions'] = l$additions?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deletions')) {
      final l$deletions = deletions;
      result$data['deletions'] = l$deletions?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$FileChanges<Input$FileChanges> get copyWith =>
      CopyWith$Input$FileChanges(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FileChanges) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$additions = additions;
    final lOther$additions = other.additions;
    if (_$data.containsKey('additions') !=
        other._$data.containsKey('additions')) {
      return false;
    }
    if (l$additions != null && lOther$additions != null) {
      if (l$additions.length != lOther$additions.length) {
        return false;
      }
      for (int i = 0; i < l$additions.length; i++) {
        final l$additions$entry = l$additions[i];
        final lOther$additions$entry = lOther$additions[i];
        if (l$additions$entry != lOther$additions$entry) {
          return false;
        }
      }
    } else if (l$additions != lOther$additions) {
      return false;
    }
    final l$deletions = deletions;
    final lOther$deletions = other.deletions;
    if (_$data.containsKey('deletions') !=
        other._$data.containsKey('deletions')) {
      return false;
    }
    if (l$deletions != null && lOther$deletions != null) {
      if (l$deletions.length != lOther$deletions.length) {
        return false;
      }
      for (int i = 0; i < l$deletions.length; i++) {
        final l$deletions$entry = l$deletions[i];
        final lOther$deletions$entry = lOther$deletions[i];
        if (l$deletions$entry != lOther$deletions$entry) {
          return false;
        }
      }
    } else if (l$deletions != lOther$deletions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$additions = additions;
    final l$deletions = deletions;
    return Object.hashAll([
      _$data.containsKey('additions')
          ? l$additions == null
              ? null
              : Object.hashAll(l$additions.map((v) => v))
          : const {},
      _$data.containsKey('deletions')
          ? l$deletions == null
              ? null
              : Object.hashAll(l$deletions.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$FileChanges<TRes> {
  factory CopyWith$Input$FileChanges(
    Input$FileChanges instance,
    TRes Function(Input$FileChanges) then,
  ) = _CopyWithImpl$Input$FileChanges;

  factory CopyWith$Input$FileChanges.stub(TRes res) =
      _CopyWithStubImpl$Input$FileChanges;

  TRes call({
    List<Input$FileAddition>? additions,
    List<Input$FileDeletion>? deletions,
  });
  TRes additions(
      Iterable<Input$FileAddition>? Function(
              Iterable<CopyWith$Input$FileAddition<Input$FileAddition>>?)
          _fn);
  TRes deletions(
      Iterable<Input$FileDeletion>? Function(
              Iterable<CopyWith$Input$FileDeletion<Input$FileDeletion>>?)
          _fn);
}

class _CopyWithImpl$Input$FileChanges<TRes>
    implements CopyWith$Input$FileChanges<TRes> {
  _CopyWithImpl$Input$FileChanges(
    this._instance,
    this._then,
  );

  final Input$FileChanges _instance;

  final TRes Function(Input$FileChanges) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? additions = _undefined,
    Object? deletions = _undefined,
  }) =>
      _then(Input$FileChanges._({
        ..._instance._$data,
        if (additions != _undefined)
          'additions': (additions as List<Input$FileAddition>?),
        if (deletions != _undefined)
          'deletions': (deletions as List<Input$FileDeletion>?),
      }));
  TRes additions(
          Iterable<Input$FileAddition>? Function(
                  Iterable<CopyWith$Input$FileAddition<Input$FileAddition>>?)
              _fn) =>
      call(
          additions:
              _fn(_instance.additions?.map((e) => CopyWith$Input$FileAddition(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes deletions(
          Iterable<Input$FileDeletion>? Function(
                  Iterable<CopyWith$Input$FileDeletion<Input$FileDeletion>>?)
              _fn) =>
      call(
          deletions:
              _fn(_instance.deletions?.map((e) => CopyWith$Input$FileDeletion(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$FileChanges<TRes>
    implements CopyWith$Input$FileChanges<TRes> {
  _CopyWithStubImpl$Input$FileChanges(this._res);

  TRes _res;

  call({
    List<Input$FileAddition>? additions,
    List<Input$FileDeletion>? deletions,
  }) =>
      _res;
  additions(_fn) => _res;
  deletions(_fn) => _res;
}

class Input$FileDeletion {
  factory Input$FileDeletion({required String path}) => Input$FileDeletion._({
        r'path': path,
      });

  Input$FileDeletion._(this._$data);

  factory Input$FileDeletion.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    return Input$FileDeletion._(result$data);
  }

  Map<String, dynamic> _$data;

  String get path => (_$data['path'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$path = path;
    result$data['path'] = l$path;
    return result$data;
  }

  CopyWith$Input$FileDeletion<Input$FileDeletion> get copyWith =>
      CopyWith$Input$FileDeletion(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FileDeletion) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$path = path;
    return Object.hashAll([l$path]);
  }
}

abstract class CopyWith$Input$FileDeletion<TRes> {
  factory CopyWith$Input$FileDeletion(
    Input$FileDeletion instance,
    TRes Function(Input$FileDeletion) then,
  ) = _CopyWithImpl$Input$FileDeletion;

  factory CopyWith$Input$FileDeletion.stub(TRes res) =
      _CopyWithStubImpl$Input$FileDeletion;

  TRes call({String? path});
}

class _CopyWithImpl$Input$FileDeletion<TRes>
    implements CopyWith$Input$FileDeletion<TRes> {
  _CopyWithImpl$Input$FileDeletion(
    this._instance,
    this._then,
  );

  final Input$FileDeletion _instance;

  final TRes Function(Input$FileDeletion) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? path = _undefined}) => _then(Input$FileDeletion._({
        ..._instance._$data,
        if (path != _undefined && path != null) 'path': (path as String),
      }));
}

class _CopyWithStubImpl$Input$FileDeletion<TRes>
    implements CopyWith$Input$FileDeletion<TRes> {
  _CopyWithStubImpl$Input$FileDeletion(this._res);

  TRes _res;

  call({String? path}) => _res;
}

class Input$FollowOrganizationInput {
  factory Input$FollowOrganizationInput({
    String? clientMutationId,
    required String organizationId,
  }) =>
      Input$FollowOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
      });

  Input$FollowOrganizationInput._(this._$data);

  factory Input$FollowOrganizationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$FollowOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$FollowOrganizationInput<Input$FollowOrganizationInput>
      get copyWith => CopyWith$Input$FollowOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FollowOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$FollowOrganizationInput<TRes> {
  factory CopyWith$Input$FollowOrganizationInput(
    Input$FollowOrganizationInput instance,
    TRes Function(Input$FollowOrganizationInput) then,
  ) = _CopyWithImpl$Input$FollowOrganizationInput;

  factory CopyWith$Input$FollowOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FollowOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$FollowOrganizationInput<TRes>
    implements CopyWith$Input$FollowOrganizationInput<TRes> {
  _CopyWithImpl$Input$FollowOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$FollowOrganizationInput _instance;

  final TRes Function(Input$FollowOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$FollowOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$FollowOrganizationInput<TRes>
    implements CopyWith$Input$FollowOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$FollowOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
  }) =>
      _res;
}

class Input$FollowUserInput {
  factory Input$FollowUserInput({
    String? clientMutationId,
    required String userId,
  }) =>
      Input$FollowUserInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'userId': userId,
      });

  Input$FollowUserInput._(this._$data);

  factory Input$FollowUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$FollowUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get userId => (_$data['userId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$FollowUserInput<Input$FollowUserInput> get copyWith =>
      CopyWith$Input$FollowUserInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FollowUserInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$FollowUserInput<TRes> {
  factory CopyWith$Input$FollowUserInput(
    Input$FollowUserInput instance,
    TRes Function(Input$FollowUserInput) then,
  ) = _CopyWithImpl$Input$FollowUserInput;

  factory CopyWith$Input$FollowUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FollowUserInput;

  TRes call({
    String? clientMutationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$FollowUserInput<TRes>
    implements CopyWith$Input$FollowUserInput<TRes> {
  _CopyWithImpl$Input$FollowUserInput(
    this._instance,
    this._then,
  );

  final Input$FollowUserInput _instance;

  final TRes Function(Input$FollowUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$FollowUserInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$FollowUserInput<TRes>
    implements CopyWith$Input$FollowUserInput<TRes> {
  _CopyWithStubImpl$Input$FollowUserInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? userId,
  }) =>
      _res;
}

class Input$GistOrder {
  factory Input$GistOrder({
    required Enum$OrderDirection direction,
    required Enum$GistOrderField field,
  }) =>
      Input$GistOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$GistOrder._(this._$data);

  factory Input$GistOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$GistOrderField((l$field as String));
    return Input$GistOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$GistOrderField get field => (_$data['field'] as Enum$GistOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$GistOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$GistOrder<Input$GistOrder> get copyWith =>
      CopyWith$Input$GistOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GistOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$GistOrder<TRes> {
  factory CopyWith$Input$GistOrder(
    Input$GistOrder instance,
    TRes Function(Input$GistOrder) then,
  ) = _CopyWithImpl$Input$GistOrder;

  factory CopyWith$Input$GistOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$GistOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$GistOrderField? field,
  });
}

class _CopyWithImpl$Input$GistOrder<TRes>
    implements CopyWith$Input$GistOrder<TRes> {
  _CopyWithImpl$Input$GistOrder(
    this._instance,
    this._then,
  );

  final Input$GistOrder _instance;

  final TRes Function(Input$GistOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$GistOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$GistOrderField),
      }));
}

class _CopyWithStubImpl$Input$GistOrder<TRes>
    implements CopyWith$Input$GistOrder<TRes> {
  _CopyWithStubImpl$Input$GistOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$GistOrderField? field,
  }) =>
      _res;
}

class Input$GrantEnterpriseOrganizationsMigratorRoleInput {
  factory Input$GrantEnterpriseOrganizationsMigratorRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$GrantEnterpriseOrganizationsMigratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$GrantEnterpriseOrganizationsMigratorRoleInput._(this._$data);

  factory Input$GrantEnterpriseOrganizationsMigratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$GrantEnterpriseOrganizationsMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
          Input$GrantEnterpriseOrganizationsMigratorRoleInput>
      get copyWith =>
          CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GrantEnterpriseOrganizationsMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
    TRes> {
  factory CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
    Input$GrantEnterpriseOrganizationsMigratorRoleInput instance,
    TRes Function(Input$GrantEnterpriseOrganizationsMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput;

  factory CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes>
    implements
        CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$GrantEnterpriseOrganizationsMigratorRoleInput _instance;

  final TRes Function(Input$GrantEnterpriseOrganizationsMigratorRoleInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$GrantEnterpriseOrganizationsMigratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput<
        TRes>
    implements
        CopyWith$Input$GrantEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$GrantEnterpriseOrganizationsMigratorRoleInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$GrantMigratorRoleInput {
  factory Input$GrantMigratorRoleInput({
    required String actor,
    required Enum$ActorType actorType,
    String? clientMutationId,
    required String organizationId,
  }) =>
      Input$GrantMigratorRoleInput._({
        r'actor': actor,
        r'actorType': actorType,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
      });

  Input$GrantMigratorRoleInput._(this._$data);

  factory Input$GrantMigratorRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$actor = data['actor'];
    result$data['actor'] = (l$actor as String);
    final l$actorType = data['actorType'];
    result$data['actorType'] = fromJson$Enum$ActorType((l$actorType as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$GrantMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get actor => (_$data['actor'] as String);
  Enum$ActorType get actorType => (_$data['actorType'] as Enum$ActorType);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$actor = actor;
    result$data['actor'] = l$actor;
    final l$actorType = actorType;
    result$data['actorType'] = toJson$Enum$ActorType(l$actorType);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$GrantMigratorRoleInput<Input$GrantMigratorRoleInput>
      get copyWith => CopyWith$Input$GrantMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$GrantMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$actor = actor;
    final lOther$actor = other.actor;
    if (l$actor != lOther$actor) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (l$actorType != lOther$actorType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$actor = actor;
    final l$actorType = actorType;
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      l$actor,
      l$actorType,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$GrantMigratorRoleInput<TRes> {
  factory CopyWith$Input$GrantMigratorRoleInput(
    Input$GrantMigratorRoleInput instance,
    TRes Function(Input$GrantMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$GrantMigratorRoleInput;

  factory CopyWith$Input$GrantMigratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$GrantMigratorRoleInput;

  TRes call({
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$GrantMigratorRoleInput<TRes>
    implements CopyWith$Input$GrantMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$GrantMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$GrantMigratorRoleInput _instance;

  final TRes Function(Input$GrantMigratorRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? actor = _undefined,
    Object? actorType = _undefined,
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$GrantMigratorRoleInput._({
        ..._instance._$data,
        if (actor != _undefined && actor != null) 'actor': (actor as String),
        if (actorType != _undefined && actorType != null)
          'actorType': (actorType as Enum$ActorType),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$GrantMigratorRoleInput<TRes>
    implements CopyWith$Input$GrantMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$GrantMigratorRoleInput(this._res);

  TRes _res;

  call({
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
    String? organizationId,
  }) =>
      _res;
}

class Input$ImportProjectInput {
  factory Input$ImportProjectInput({
    String? body,
    String? clientMutationId,
    required List<Input$ProjectColumnImport> columnImports,
    required String name,
    required String ownerName,
    bool? public,
  }) =>
      Input$ImportProjectInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'columnImports': columnImports,
        r'name': name,
        r'ownerName': ownerName,
        if (public != null) r'public': public,
      });

  Input$ImportProjectInput._(this._$data);

  factory Input$ImportProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$columnImports = data['columnImports'];
    result$data['columnImports'] = (l$columnImports as List<dynamic>)
        .map((e) =>
            Input$ProjectColumnImport.fromJson((e as Map<String, dynamic>)))
        .toList();
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$ownerName = data['ownerName'];
    result$data['ownerName'] = (l$ownerName as String);
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    return Input$ImportProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<Input$ProjectColumnImport> get columnImports =>
      (_$data['columnImports'] as List<Input$ProjectColumnImport>);
  String get name => (_$data['name'] as String);
  String get ownerName => (_$data['ownerName'] as String);
  bool? get public => (_$data['public'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$columnImports = columnImports;
    result$data['columnImports'] =
        l$columnImports.map((e) => e.toJson()).toList();
    final l$name = name;
    result$data['name'] = l$name;
    final l$ownerName = ownerName;
    result$data['ownerName'] = l$ownerName;
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    return result$data;
  }

  CopyWith$Input$ImportProjectInput<Input$ImportProjectInput> get copyWith =>
      CopyWith$Input$ImportProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ImportProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$columnImports = columnImports;
    final lOther$columnImports = other.columnImports;
    if (l$columnImports.length != lOther$columnImports.length) {
      return false;
    }
    for (int i = 0; i < l$columnImports.length; i++) {
      final l$columnImports$entry = l$columnImports[i];
      final lOther$columnImports$entry = lOther$columnImports[i];
      if (l$columnImports$entry != lOther$columnImports$entry) {
        return false;
      }
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$ownerName = ownerName;
    final lOther$ownerName = other.ownerName;
    if (l$ownerName != lOther$ownerName) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$columnImports = columnImports;
    final l$name = name;
    final l$ownerName = ownerName;
    final l$public = public;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$columnImports.map((v) => v)),
      l$name,
      l$ownerName,
      _$data.containsKey('public') ? l$public : const {},
    ]);
  }
}

abstract class CopyWith$Input$ImportProjectInput<TRes> {
  factory CopyWith$Input$ImportProjectInput(
    Input$ImportProjectInput instance,
    TRes Function(Input$ImportProjectInput) then,
  ) = _CopyWithImpl$Input$ImportProjectInput;

  factory CopyWith$Input$ImportProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ImportProjectInput;

  TRes call({
    String? body,
    String? clientMutationId,
    List<Input$ProjectColumnImport>? columnImports,
    String? name,
    String? ownerName,
    bool? public,
  });
  TRes columnImports(
      Iterable<Input$ProjectColumnImport> Function(
              Iterable<
                  CopyWith$Input$ProjectColumnImport<
                      Input$ProjectColumnImport>>)
          _fn);
}

class _CopyWithImpl$Input$ImportProjectInput<TRes>
    implements CopyWith$Input$ImportProjectInput<TRes> {
  _CopyWithImpl$Input$ImportProjectInput(
    this._instance,
    this._then,
  );

  final Input$ImportProjectInput _instance;

  final TRes Function(Input$ImportProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? columnImports = _undefined,
    Object? name = _undefined,
    Object? ownerName = _undefined,
    Object? public = _undefined,
  }) =>
      _then(Input$ImportProjectInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (columnImports != _undefined && columnImports != null)
          'columnImports': (columnImports as List<Input$ProjectColumnImport>),
        if (name != _undefined && name != null) 'name': (name as String),
        if (ownerName != _undefined && ownerName != null)
          'ownerName': (ownerName as String),
        if (public != _undefined) 'public': (public as bool?),
      }));
  TRes columnImports(
          Iterable<Input$ProjectColumnImport> Function(
                  Iterable<
                      CopyWith$Input$ProjectColumnImport<
                          Input$ProjectColumnImport>>)
              _fn) =>
      call(
          columnImports: _fn(_instance.columnImports
              .map((e) => CopyWith$Input$ProjectColumnImport(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$ImportProjectInput<TRes>
    implements CopyWith$Input$ImportProjectInput<TRes> {
  _CopyWithStubImpl$Input$ImportProjectInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    List<Input$ProjectColumnImport>? columnImports,
    String? name,
    String? ownerName,
    bool? public,
  }) =>
      _res;
  columnImports(_fn) => _res;
}

class Input$InviteEnterpriseAdminInput {
  factory Input$InviteEnterpriseAdminInput({
    String? clientMutationId,
    String? email,
    required String enterpriseId,
    String? invitee,
    Enum$EnterpriseAdministratorRole? role,
  }) =>
      Input$InviteEnterpriseAdminInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (email != null) r'email': email,
        r'enterpriseId': enterpriseId,
        if (invitee != null) r'invitee': invitee,
        if (role != null) r'role': role,
      });

  Input$InviteEnterpriseAdminInput._(this._$data);

  factory Input$InviteEnterpriseAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('email')) {
      final l$email = data['email'];
      result$data['email'] = (l$email as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('invitee')) {
      final l$invitee = data['invitee'];
      result$data['invitee'] = (l$invitee as String?);
    }
    if (data.containsKey('role')) {
      final l$role = data['role'];
      result$data['role'] = l$role == null
          ? null
          : fromJson$Enum$EnterpriseAdministratorRole((l$role as String));
    }
    return Input$InviteEnterpriseAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get email => (_$data['email'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String? get invitee => (_$data['invitee'] as String?);
  Enum$EnterpriseAdministratorRole? get role =>
      (_$data['role'] as Enum$EnterpriseAdministratorRole?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('email')) {
      final l$email = email;
      result$data['email'] = l$email;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('invitee')) {
      final l$invitee = invitee;
      result$data['invitee'] = l$invitee;
    }
    if (_$data.containsKey('role')) {
      final l$role = role;
      result$data['role'] = l$role == null
          ? null
          : toJson$Enum$EnterpriseAdministratorRole(l$role);
    }
    return result$data;
  }

  CopyWith$Input$InviteEnterpriseAdminInput<Input$InviteEnterpriseAdminInput>
      get copyWith => CopyWith$Input$InviteEnterpriseAdminInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$InviteEnterpriseAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$email = email;
    final lOther$email = other.email;
    if (_$data.containsKey('email') != other._$data.containsKey('email')) {
      return false;
    }
    if (l$email != lOther$email) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$invitee = invitee;
    final lOther$invitee = other.invitee;
    if (_$data.containsKey('invitee') != other._$data.containsKey('invitee')) {
      return false;
    }
    if (l$invitee != lOther$invitee) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (_$data.containsKey('role') != other._$data.containsKey('role')) {
      return false;
    }
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$email = email;
    final l$enterpriseId = enterpriseId;
    final l$invitee = invitee;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('email') ? l$email : const {},
      l$enterpriseId,
      _$data.containsKey('invitee') ? l$invitee : const {},
      _$data.containsKey('role') ? l$role : const {},
    ]);
  }
}

abstract class CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  factory CopyWith$Input$InviteEnterpriseAdminInput(
    Input$InviteEnterpriseAdminInput instance,
    TRes Function(Input$InviteEnterpriseAdminInput) then,
  ) = _CopyWithImpl$Input$InviteEnterpriseAdminInput;

  factory CopyWith$Input$InviteEnterpriseAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$InviteEnterpriseAdminInput;

  TRes call({
    String? clientMutationId,
    String? email,
    String? enterpriseId,
    String? invitee,
    Enum$EnterpriseAdministratorRole? role,
  });
}

class _CopyWithImpl$Input$InviteEnterpriseAdminInput<TRes>
    implements CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  _CopyWithImpl$Input$InviteEnterpriseAdminInput(
    this._instance,
    this._then,
  );

  final Input$InviteEnterpriseAdminInput _instance;

  final TRes Function(Input$InviteEnterpriseAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? email = _undefined,
    Object? enterpriseId = _undefined,
    Object? invitee = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$InviteEnterpriseAdminInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (email != _undefined) 'email': (email as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (invitee != _undefined) 'invitee': (invitee as String?),
        if (role != _undefined)
          'role': (role as Enum$EnterpriseAdministratorRole?),
      }));
}

class _CopyWithStubImpl$Input$InviteEnterpriseAdminInput<TRes>
    implements CopyWith$Input$InviteEnterpriseAdminInput<TRes> {
  _CopyWithStubImpl$Input$InviteEnterpriseAdminInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? email,
    String? enterpriseId,
    String? invitee,
    Enum$EnterpriseAdministratorRole? role,
  }) =>
      _res;
}

class Input$IpAllowListEntryOrder {
  factory Input$IpAllowListEntryOrder({
    required Enum$OrderDirection direction,
    required Enum$IpAllowListEntryOrderField field,
  }) =>
      Input$IpAllowListEntryOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$IpAllowListEntryOrder._(this._$data);

  factory Input$IpAllowListEntryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IpAllowListEntryOrderField((l$field as String));
    return Input$IpAllowListEntryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$IpAllowListEntryOrderField get field =>
      (_$data['field'] as Enum$IpAllowListEntryOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$IpAllowListEntryOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$IpAllowListEntryOrder<Input$IpAllowListEntryOrder>
      get copyWith => CopyWith$Input$IpAllowListEntryOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IpAllowListEntryOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$IpAllowListEntryOrder<TRes> {
  factory CopyWith$Input$IpAllowListEntryOrder(
    Input$IpAllowListEntryOrder instance,
    TRes Function(Input$IpAllowListEntryOrder) then,
  ) = _CopyWithImpl$Input$IpAllowListEntryOrder;

  factory CopyWith$Input$IpAllowListEntryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IpAllowListEntryOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$IpAllowListEntryOrderField? field,
  });
}

class _CopyWithImpl$Input$IpAllowListEntryOrder<TRes>
    implements CopyWith$Input$IpAllowListEntryOrder<TRes> {
  _CopyWithImpl$Input$IpAllowListEntryOrder(
    this._instance,
    this._then,
  );

  final Input$IpAllowListEntryOrder _instance;

  final TRes Function(Input$IpAllowListEntryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$IpAllowListEntryOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$IpAllowListEntryOrderField),
      }));
}

class _CopyWithStubImpl$Input$IpAllowListEntryOrder<TRes>
    implements CopyWith$Input$IpAllowListEntryOrder<TRes> {
  _CopyWithStubImpl$Input$IpAllowListEntryOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$IpAllowListEntryOrderField? field,
  }) =>
      _res;
}

class Input$IssueCommentOrder {
  factory Input$IssueCommentOrder({
    required Enum$OrderDirection direction,
    required Enum$IssueCommentOrderField field,
  }) =>
      Input$IssueCommentOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$IssueCommentOrder._(this._$data);

  factory Input$IssueCommentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$IssueCommentOrderField((l$field as String));
    return Input$IssueCommentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$IssueCommentOrderField get field =>
      (_$data['field'] as Enum$IssueCommentOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueCommentOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$IssueCommentOrder<Input$IssueCommentOrder> get copyWith =>
      CopyWith$Input$IssueCommentOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueCommentOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$IssueCommentOrder<TRes> {
  factory CopyWith$Input$IssueCommentOrder(
    Input$IssueCommentOrder instance,
    TRes Function(Input$IssueCommentOrder) then,
  ) = _CopyWithImpl$Input$IssueCommentOrder;

  factory CopyWith$Input$IssueCommentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueCommentOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$IssueCommentOrderField? field,
  });
}

class _CopyWithImpl$Input$IssueCommentOrder<TRes>
    implements CopyWith$Input$IssueCommentOrder<TRes> {
  _CopyWithImpl$Input$IssueCommentOrder(
    this._instance,
    this._then,
  );

  final Input$IssueCommentOrder _instance;

  final TRes Function(Input$IssueCommentOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$IssueCommentOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueCommentOrderField),
      }));
}

class _CopyWithStubImpl$Input$IssueCommentOrder<TRes>
    implements CopyWith$Input$IssueCommentOrder<TRes> {
  _CopyWithStubImpl$Input$IssueCommentOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$IssueCommentOrderField? field,
  }) =>
      _res;
}

class Input$IssueFilters {
  factory Input$IssueFilters({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    DateTime? since,
    List<Enum$IssueState>? states,
    bool? viewerSubscribed,
  }) =>
      Input$IssueFilters._({
        if (assignee != null) r'assignee': assignee,
        if (createdBy != null) r'createdBy': createdBy,
        if (labels != null) r'labels': labels,
        if (mentioned != null) r'mentioned': mentioned,
        if (milestone != null) r'milestone': milestone,
        if (milestoneNumber != null) r'milestoneNumber': milestoneNumber,
        if (since != null) r'since': since,
        if (states != null) r'states': states,
        if (viewerSubscribed != null) r'viewerSubscribed': viewerSubscribed,
      });

  Input$IssueFilters._(this._$data);

  factory Input$IssueFilters.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assignee')) {
      final l$assignee = data['assignee'];
      result$data['assignee'] = (l$assignee as String?);
    }
    if (data.containsKey('createdBy')) {
      final l$createdBy = data['createdBy'];
      result$data['createdBy'] = (l$createdBy as String?);
    }
    if (data.containsKey('labels')) {
      final l$labels = data['labels'];
      result$data['labels'] =
          (l$labels as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('mentioned')) {
      final l$mentioned = data['mentioned'];
      result$data['mentioned'] = (l$mentioned as String?);
    }
    if (data.containsKey('milestone')) {
      final l$milestone = data['milestone'];
      result$data['milestone'] = (l$milestone as String?);
    }
    if (data.containsKey('milestoneNumber')) {
      final l$milestoneNumber = data['milestoneNumber'];
      result$data['milestoneNumber'] = (l$milestoneNumber as String?);
    }
    if (data.containsKey('since')) {
      final l$since = data['since'];
      result$data['since'] =
          l$since == null ? null : DateTime.parse((l$since as String));
    }
    if (data.containsKey('states')) {
      final l$states = data['states'];
      result$data['states'] = (l$states as List<dynamic>?)
          ?.map((e) => fromJson$Enum$IssueState((e as String)))
          .toList();
    }
    if (data.containsKey('viewerSubscribed')) {
      final l$viewerSubscribed = data['viewerSubscribed'];
      result$data['viewerSubscribed'] = (l$viewerSubscribed as bool?);
    }
    return Input$IssueFilters._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get assignee => (_$data['assignee'] as String?);
  String? get createdBy => (_$data['createdBy'] as String?);
  List<String>? get labels => (_$data['labels'] as List<String>?);
  String? get mentioned => (_$data['mentioned'] as String?);
  String? get milestone => (_$data['milestone'] as String?);
  String? get milestoneNumber => (_$data['milestoneNumber'] as String?);
  DateTime? get since => (_$data['since'] as DateTime?);
  List<Enum$IssueState>? get states =>
      (_$data['states'] as List<Enum$IssueState>?);
  bool? get viewerSubscribed => (_$data['viewerSubscribed'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assignee')) {
      final l$assignee = assignee;
      result$data['assignee'] = l$assignee;
    }
    if (_$data.containsKey('createdBy')) {
      final l$createdBy = createdBy;
      result$data['createdBy'] = l$createdBy;
    }
    if (_$data.containsKey('labels')) {
      final l$labels = labels;
      result$data['labels'] = l$labels?.map((e) => e).toList();
    }
    if (_$data.containsKey('mentioned')) {
      final l$mentioned = mentioned;
      result$data['mentioned'] = l$mentioned;
    }
    if (_$data.containsKey('milestone')) {
      final l$milestone = milestone;
      result$data['milestone'] = l$milestone;
    }
    if (_$data.containsKey('milestoneNumber')) {
      final l$milestoneNumber = milestoneNumber;
      result$data['milestoneNumber'] = l$milestoneNumber;
    }
    if (_$data.containsKey('since')) {
      final l$since = since;
      result$data['since'] = l$since?.toIso8601String();
    }
    if (_$data.containsKey('states')) {
      final l$states = states;
      result$data['states'] =
          l$states?.map((e) => toJson$Enum$IssueState(e)).toList();
    }
    if (_$data.containsKey('viewerSubscribed')) {
      final l$viewerSubscribed = viewerSubscribed;
      result$data['viewerSubscribed'] = l$viewerSubscribed;
    }
    return result$data;
  }

  CopyWith$Input$IssueFilters<Input$IssueFilters> get copyWith =>
      CopyWith$Input$IssueFilters(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueFilters) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$assignee = assignee;
    final lOther$assignee = other.assignee;
    if (_$data.containsKey('assignee') !=
        other._$data.containsKey('assignee')) {
      return false;
    }
    if (l$assignee != lOther$assignee) {
      return false;
    }
    final l$createdBy = createdBy;
    final lOther$createdBy = other.createdBy;
    if (_$data.containsKey('createdBy') !=
        other._$data.containsKey('createdBy')) {
      return false;
    }
    if (l$createdBy != lOther$createdBy) {
      return false;
    }
    final l$labels = labels;
    final lOther$labels = other.labels;
    if (_$data.containsKey('labels') != other._$data.containsKey('labels')) {
      return false;
    }
    if (l$labels != null && lOther$labels != null) {
      if (l$labels.length != lOther$labels.length) {
        return false;
      }
      for (int i = 0; i < l$labels.length; i++) {
        final l$labels$entry = l$labels[i];
        final lOther$labels$entry = lOther$labels[i];
        if (l$labels$entry != lOther$labels$entry) {
          return false;
        }
      }
    } else if (l$labels != lOther$labels) {
      return false;
    }
    final l$mentioned = mentioned;
    final lOther$mentioned = other.mentioned;
    if (_$data.containsKey('mentioned') !=
        other._$data.containsKey('mentioned')) {
      return false;
    }
    if (l$mentioned != lOther$mentioned) {
      return false;
    }
    final l$milestone = milestone;
    final lOther$milestone = other.milestone;
    if (_$data.containsKey('milestone') !=
        other._$data.containsKey('milestone')) {
      return false;
    }
    if (l$milestone != lOther$milestone) {
      return false;
    }
    final l$milestoneNumber = milestoneNumber;
    final lOther$milestoneNumber = other.milestoneNumber;
    if (_$data.containsKey('milestoneNumber') !=
        other._$data.containsKey('milestoneNumber')) {
      return false;
    }
    if (l$milestoneNumber != lOther$milestoneNumber) {
      return false;
    }
    final l$since = since;
    final lOther$since = other.since;
    if (_$data.containsKey('since') != other._$data.containsKey('since')) {
      return false;
    }
    if (l$since != lOther$since) {
      return false;
    }
    final l$states = states;
    final lOther$states = other.states;
    if (_$data.containsKey('states') != other._$data.containsKey('states')) {
      return false;
    }
    if (l$states != null && lOther$states != null) {
      if (l$states.length != lOther$states.length) {
        return false;
      }
      for (int i = 0; i < l$states.length; i++) {
        final l$states$entry = l$states[i];
        final lOther$states$entry = lOther$states[i];
        if (l$states$entry != lOther$states$entry) {
          return false;
        }
      }
    } else if (l$states != lOther$states) {
      return false;
    }
    final l$viewerSubscribed = viewerSubscribed;
    final lOther$viewerSubscribed = other.viewerSubscribed;
    if (_$data.containsKey('viewerSubscribed') !=
        other._$data.containsKey('viewerSubscribed')) {
      return false;
    }
    if (l$viewerSubscribed != lOther$viewerSubscribed) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assignee = assignee;
    final l$createdBy = createdBy;
    final l$labels = labels;
    final l$mentioned = mentioned;
    final l$milestone = milestone;
    final l$milestoneNumber = milestoneNumber;
    final l$since = since;
    final l$states = states;
    final l$viewerSubscribed = viewerSubscribed;
    return Object.hashAll([
      _$data.containsKey('assignee') ? l$assignee : const {},
      _$data.containsKey('createdBy') ? l$createdBy : const {},
      _$data.containsKey('labels')
          ? l$labels == null
              ? null
              : Object.hashAll(l$labels.map((v) => v))
          : const {},
      _$data.containsKey('mentioned') ? l$mentioned : const {},
      _$data.containsKey('milestone') ? l$milestone : const {},
      _$data.containsKey('milestoneNumber') ? l$milestoneNumber : const {},
      _$data.containsKey('since') ? l$since : const {},
      _$data.containsKey('states')
          ? l$states == null
              ? null
              : Object.hashAll(l$states.map((v) => v))
          : const {},
      _$data.containsKey('viewerSubscribed') ? l$viewerSubscribed : const {},
    ]);
  }
}

abstract class CopyWith$Input$IssueFilters<TRes> {
  factory CopyWith$Input$IssueFilters(
    Input$IssueFilters instance,
    TRes Function(Input$IssueFilters) then,
  ) = _CopyWithImpl$Input$IssueFilters;

  factory CopyWith$Input$IssueFilters.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueFilters;

  TRes call({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    DateTime? since,
    List<Enum$IssueState>? states,
    bool? viewerSubscribed,
  });
}

class _CopyWithImpl$Input$IssueFilters<TRes>
    implements CopyWith$Input$IssueFilters<TRes> {
  _CopyWithImpl$Input$IssueFilters(
    this._instance,
    this._then,
  );

  final Input$IssueFilters _instance;

  final TRes Function(Input$IssueFilters) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assignee = _undefined,
    Object? createdBy = _undefined,
    Object? labels = _undefined,
    Object? mentioned = _undefined,
    Object? milestone = _undefined,
    Object? milestoneNumber = _undefined,
    Object? since = _undefined,
    Object? states = _undefined,
    Object? viewerSubscribed = _undefined,
  }) =>
      _then(Input$IssueFilters._({
        ..._instance._$data,
        if (assignee != _undefined) 'assignee': (assignee as String?),
        if (createdBy != _undefined) 'createdBy': (createdBy as String?),
        if (labels != _undefined) 'labels': (labels as List<String>?),
        if (mentioned != _undefined) 'mentioned': (mentioned as String?),
        if (milestone != _undefined) 'milestone': (milestone as String?),
        if (milestoneNumber != _undefined)
          'milestoneNumber': (milestoneNumber as String?),
        if (since != _undefined) 'since': (since as DateTime?),
        if (states != _undefined) 'states': (states as List<Enum$IssueState>?),
        if (viewerSubscribed != _undefined)
          'viewerSubscribed': (viewerSubscribed as bool?),
      }));
}

class _CopyWithStubImpl$Input$IssueFilters<TRes>
    implements CopyWith$Input$IssueFilters<TRes> {
  _CopyWithStubImpl$Input$IssueFilters(this._res);

  TRes _res;

  call({
    String? assignee,
    String? createdBy,
    List<String>? labels,
    String? mentioned,
    String? milestone,
    String? milestoneNumber,
    DateTime? since,
    List<Enum$IssueState>? states,
    bool? viewerSubscribed,
  }) =>
      _res;
}

class Input$IssueOrder {
  factory Input$IssueOrder({
    required Enum$OrderDirection direction,
    required Enum$IssueOrderField field,
  }) =>
      Input$IssueOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$IssueOrder._(this._$data);

  factory Input$IssueOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$IssueOrderField((l$field as String));
    return Input$IssueOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$IssueOrderField get field => (_$data['field'] as Enum$IssueOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$IssueOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$IssueOrder<Input$IssueOrder> get copyWith =>
      CopyWith$Input$IssueOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IssueOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$IssueOrder<TRes> {
  factory CopyWith$Input$IssueOrder(
    Input$IssueOrder instance,
    TRes Function(Input$IssueOrder) then,
  ) = _CopyWithImpl$Input$IssueOrder;

  factory CopyWith$Input$IssueOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$IssueOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$IssueOrderField? field,
  });
}

class _CopyWithImpl$Input$IssueOrder<TRes>
    implements CopyWith$Input$IssueOrder<TRes> {
  _CopyWithImpl$Input$IssueOrder(
    this._instance,
    this._then,
  );

  final Input$IssueOrder _instance;

  final TRes Function(Input$IssueOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$IssueOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$IssueOrderField),
      }));
}

class _CopyWithStubImpl$Input$IssueOrder<TRes>
    implements CopyWith$Input$IssueOrder<TRes> {
  _CopyWithStubImpl$Input$IssueOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$IssueOrderField? field,
  }) =>
      _res;
}

class Input$LabelOrder {
  factory Input$LabelOrder({
    required Enum$OrderDirection direction,
    required Enum$LabelOrderField field,
  }) =>
      Input$LabelOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$LabelOrder._(this._$data);

  factory Input$LabelOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$LabelOrderField((l$field as String));
    return Input$LabelOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$LabelOrderField get field => (_$data['field'] as Enum$LabelOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$LabelOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$LabelOrder<Input$LabelOrder> get copyWith =>
      CopyWith$Input$LabelOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LabelOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$LabelOrder<TRes> {
  factory CopyWith$Input$LabelOrder(
    Input$LabelOrder instance,
    TRes Function(Input$LabelOrder) then,
  ) = _CopyWithImpl$Input$LabelOrder;

  factory CopyWith$Input$LabelOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$LabelOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$LabelOrderField? field,
  });
}

class _CopyWithImpl$Input$LabelOrder<TRes>
    implements CopyWith$Input$LabelOrder<TRes> {
  _CopyWithImpl$Input$LabelOrder(
    this._instance,
    this._then,
  );

  final Input$LabelOrder _instance;

  final TRes Function(Input$LabelOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$LabelOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$LabelOrderField),
      }));
}

class _CopyWithStubImpl$Input$LabelOrder<TRes>
    implements CopyWith$Input$LabelOrder<TRes> {
  _CopyWithStubImpl$Input$LabelOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$LabelOrderField? field,
  }) =>
      _res;
}

class Input$LanguageOrder {
  factory Input$LanguageOrder({
    required Enum$OrderDirection direction,
    required Enum$LanguageOrderField field,
  }) =>
      Input$LanguageOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$LanguageOrder._(this._$data);

  factory Input$LanguageOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$LanguageOrderField((l$field as String));
    return Input$LanguageOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$LanguageOrderField get field =>
      (_$data['field'] as Enum$LanguageOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$LanguageOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$LanguageOrder<Input$LanguageOrder> get copyWith =>
      CopyWith$Input$LanguageOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LanguageOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$LanguageOrder<TRes> {
  factory CopyWith$Input$LanguageOrder(
    Input$LanguageOrder instance,
    TRes Function(Input$LanguageOrder) then,
  ) = _CopyWithImpl$Input$LanguageOrder;

  factory CopyWith$Input$LanguageOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$LanguageOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$LanguageOrderField? field,
  });
}

class _CopyWithImpl$Input$LanguageOrder<TRes>
    implements CopyWith$Input$LanguageOrder<TRes> {
  _CopyWithImpl$Input$LanguageOrder(
    this._instance,
    this._then,
  );

  final Input$LanguageOrder _instance;

  final TRes Function(Input$LanguageOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$LanguageOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$LanguageOrderField),
      }));
}

class _CopyWithStubImpl$Input$LanguageOrder<TRes>
    implements CopyWith$Input$LanguageOrder<TRes> {
  _CopyWithStubImpl$Input$LanguageOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$LanguageOrderField? field,
  }) =>
      _res;
}

class Input$LinkProjectV2ToRepositoryInput {
  factory Input$LinkProjectV2ToRepositoryInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$LinkProjectV2ToRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$LinkProjectV2ToRepositoryInput._(this._$data);

  factory Input$LinkProjectV2ToRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$LinkProjectV2ToRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$LinkProjectV2ToRepositoryInput<
          Input$LinkProjectV2ToRepositoryInput>
      get copyWith => CopyWith$Input$LinkProjectV2ToRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LinkProjectV2ToRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  factory CopyWith$Input$LinkProjectV2ToRepositoryInput(
    Input$LinkProjectV2ToRepositoryInput instance,
    TRes Function(Input$LinkProjectV2ToRepositoryInput) then,
  ) = _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput;

  factory CopyWith$Input$LinkProjectV2ToRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  _CopyWithImpl$Input$LinkProjectV2ToRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$LinkProjectV2ToRepositoryInput _instance;

  final TRes Function(Input$LinkProjectV2ToRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$LinkProjectV2ToRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$LinkProjectV2ToRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$LinkProjectV2ToTeamInput {
  factory Input$LinkProjectV2ToTeamInput({
    String? clientMutationId,
    required String projectId,
    required String teamId,
  }) =>
      Input$LinkProjectV2ToTeamInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'teamId': teamId,
      });

  Input$LinkProjectV2ToTeamInput._(this._$data);

  factory Input$LinkProjectV2ToTeamInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    return Input$LinkProjectV2ToTeamInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String get teamId => (_$data['teamId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    return result$data;
  }

  CopyWith$Input$LinkProjectV2ToTeamInput<Input$LinkProjectV2ToTeamInput>
      get copyWith => CopyWith$Input$LinkProjectV2ToTeamInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LinkProjectV2ToTeamInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$teamId = teamId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$teamId,
    ]);
  }
}

abstract class CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  factory CopyWith$Input$LinkProjectV2ToTeamInput(
    Input$LinkProjectV2ToTeamInput instance,
    TRes Function(Input$LinkProjectV2ToTeamInput) then,
  ) = _CopyWithImpl$Input$LinkProjectV2ToTeamInput;

  factory CopyWith$Input$LinkProjectV2ToTeamInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  });
}

class _CopyWithImpl$Input$LinkProjectV2ToTeamInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  _CopyWithImpl$Input$LinkProjectV2ToTeamInput(
    this._instance,
    this._then,
  );

  final Input$LinkProjectV2ToTeamInput _instance;

  final TRes Function(Input$LinkProjectV2ToTeamInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? teamId = _undefined,
  }) =>
      _then(Input$LinkProjectV2ToTeamInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
      }));
}

class _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput<TRes>
    implements CopyWith$Input$LinkProjectV2ToTeamInput<TRes> {
  _CopyWithStubImpl$Input$LinkProjectV2ToTeamInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  }) =>
      _res;
}

class Input$LinkRepositoryToProjectInput {
  factory Input$LinkRepositoryToProjectInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$LinkRepositoryToProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$LinkRepositoryToProjectInput._(this._$data);

  factory Input$LinkRepositoryToProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$LinkRepositoryToProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$LinkRepositoryToProjectInput<
          Input$LinkRepositoryToProjectInput>
      get copyWith => CopyWith$Input$LinkRepositoryToProjectInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LinkRepositoryToProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  factory CopyWith$Input$LinkRepositoryToProjectInput(
    Input$LinkRepositoryToProjectInput instance,
    TRes Function(Input$LinkRepositoryToProjectInput) then,
  ) = _CopyWithImpl$Input$LinkRepositoryToProjectInput;

  factory CopyWith$Input$LinkRepositoryToProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LinkRepositoryToProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$LinkRepositoryToProjectInput<TRes>
    implements CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  _CopyWithImpl$Input$LinkRepositoryToProjectInput(
    this._instance,
    this._then,
  );

  final Input$LinkRepositoryToProjectInput _instance;

  final TRes Function(Input$LinkRepositoryToProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$LinkRepositoryToProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$LinkRepositoryToProjectInput<TRes>
    implements CopyWith$Input$LinkRepositoryToProjectInput<TRes> {
  _CopyWithStubImpl$Input$LinkRepositoryToProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$LockLockableInput {
  factory Input$LockLockableInput({
    String? clientMutationId,
    Enum$LockReason? lockReason,
    required String lockableId,
  }) =>
      Input$LockLockableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (lockReason != null) r'lockReason': lockReason,
        r'lockableId': lockableId,
      });

  Input$LockLockableInput._(this._$data);

  factory Input$LockLockableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('lockReason')) {
      final l$lockReason = data['lockReason'];
      result$data['lockReason'] = l$lockReason == null
          ? null
          : fromJson$Enum$LockReason((l$lockReason as String));
    }
    final l$lockableId = data['lockableId'];
    result$data['lockableId'] = (l$lockableId as String);
    return Input$LockLockableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$LockReason? get lockReason => (_$data['lockReason'] as Enum$LockReason?);
  String get lockableId => (_$data['lockableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('lockReason')) {
      final l$lockReason = lockReason;
      result$data['lockReason'] =
          l$lockReason == null ? null : toJson$Enum$LockReason(l$lockReason);
    }
    final l$lockableId = lockableId;
    result$data['lockableId'] = l$lockableId;
    return result$data;
  }

  CopyWith$Input$LockLockableInput<Input$LockLockableInput> get copyWith =>
      CopyWith$Input$LockLockableInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$LockLockableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$lockReason = lockReason;
    final lOther$lockReason = other.lockReason;
    if (_$data.containsKey('lockReason') !=
        other._$data.containsKey('lockReason')) {
      return false;
    }
    if (l$lockReason != lOther$lockReason) {
      return false;
    }
    final l$lockableId = lockableId;
    final lOther$lockableId = other.lockableId;
    if (l$lockableId != lOther$lockableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$lockReason = lockReason;
    final l$lockableId = lockableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('lockReason') ? l$lockReason : const {},
      l$lockableId,
    ]);
  }
}

abstract class CopyWith$Input$LockLockableInput<TRes> {
  factory CopyWith$Input$LockLockableInput(
    Input$LockLockableInput instance,
    TRes Function(Input$LockLockableInput) then,
  ) = _CopyWithImpl$Input$LockLockableInput;

  factory CopyWith$Input$LockLockableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$LockLockableInput;

  TRes call({
    String? clientMutationId,
    Enum$LockReason? lockReason,
    String? lockableId,
  });
}

class _CopyWithImpl$Input$LockLockableInput<TRes>
    implements CopyWith$Input$LockLockableInput<TRes> {
  _CopyWithImpl$Input$LockLockableInput(
    this._instance,
    this._then,
  );

  final Input$LockLockableInput _instance;

  final TRes Function(Input$LockLockableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? lockReason = _undefined,
    Object? lockableId = _undefined,
  }) =>
      _then(Input$LockLockableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (lockReason != _undefined)
          'lockReason': (lockReason as Enum$LockReason?),
        if (lockableId != _undefined && lockableId != null)
          'lockableId': (lockableId as String),
      }));
}

class _CopyWithStubImpl$Input$LockLockableInput<TRes>
    implements CopyWith$Input$LockLockableInput<TRes> {
  _CopyWithStubImpl$Input$LockLockableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$LockReason? lockReason,
    String? lockableId,
  }) =>
      _res;
}

class Input$MannequinOrder {
  factory Input$MannequinOrder({
    required Enum$OrderDirection direction,
    required Enum$MannequinOrderField field,
  }) =>
      Input$MannequinOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$MannequinOrder._(this._$data);

  factory Input$MannequinOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$MannequinOrderField((l$field as String));
    return Input$MannequinOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$MannequinOrderField get field =>
      (_$data['field'] as Enum$MannequinOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$MannequinOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$MannequinOrder<Input$MannequinOrder> get copyWith =>
      CopyWith$Input$MannequinOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MannequinOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$MannequinOrder<TRes> {
  factory CopyWith$Input$MannequinOrder(
    Input$MannequinOrder instance,
    TRes Function(Input$MannequinOrder) then,
  ) = _CopyWithImpl$Input$MannequinOrder;

  factory CopyWith$Input$MannequinOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$MannequinOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$MannequinOrderField? field,
  });
}

class _CopyWithImpl$Input$MannequinOrder<TRes>
    implements CopyWith$Input$MannequinOrder<TRes> {
  _CopyWithImpl$Input$MannequinOrder(
    this._instance,
    this._then,
  );

  final Input$MannequinOrder _instance;

  final TRes Function(Input$MannequinOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$MannequinOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$MannequinOrderField),
      }));
}

class _CopyWithStubImpl$Input$MannequinOrder<TRes>
    implements CopyWith$Input$MannequinOrder<TRes> {
  _CopyWithStubImpl$Input$MannequinOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$MannequinOrderField? field,
  }) =>
      _res;
}

class Input$MarkDiscussionCommentAsAnswerInput {
  factory Input$MarkDiscussionCommentAsAnswerInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$MarkDiscussionCommentAsAnswerInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$MarkDiscussionCommentAsAnswerInput._(this._$data);

  factory Input$MarkDiscussionCommentAsAnswerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$MarkDiscussionCommentAsAnswerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$MarkDiscussionCommentAsAnswerInput<
          Input$MarkDiscussionCommentAsAnswerInput>
      get copyWith => CopyWith$Input$MarkDiscussionCommentAsAnswerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkDiscussionCommentAsAnswerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  factory CopyWith$Input$MarkDiscussionCommentAsAnswerInput(
    Input$MarkDiscussionCommentAsAnswerInput instance,
    TRes Function(Input$MarkDiscussionCommentAsAnswerInput) then,
  ) = _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput;

  factory CopyWith$Input$MarkDiscussionCommentAsAnswerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithImpl$Input$MarkDiscussionCommentAsAnswerInput(
    this._instance,
    this._then,
  );

  final Input$MarkDiscussionCommentAsAnswerInput _instance;

  final TRes Function(Input$MarkDiscussionCommentAsAnswerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$MarkDiscussionCommentAsAnswerInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$MarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithStubImpl$Input$MarkDiscussionCommentAsAnswerInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$MarkFileAsViewedInput {
  factory Input$MarkFileAsViewedInput({
    String? clientMutationId,
    required String path,
    required String pullRequestId,
  }) =>
      Input$MarkFileAsViewedInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'path': path,
        r'pullRequestId': pullRequestId,
      });

  Input$MarkFileAsViewedInput._(this._$data);

  factory Input$MarkFileAsViewedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$MarkFileAsViewedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get path => (_$data['path'] as String);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$path = path;
    result$data['path'] = l$path;
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$MarkFileAsViewedInput<Input$MarkFileAsViewedInput>
      get copyWith => CopyWith$Input$MarkFileAsViewedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkFileAsViewedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$path = path;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$path,
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$MarkFileAsViewedInput<TRes> {
  factory CopyWith$Input$MarkFileAsViewedInput(
    Input$MarkFileAsViewedInput instance,
    TRes Function(Input$MarkFileAsViewedInput) then,
  ) = _CopyWithImpl$Input$MarkFileAsViewedInput;

  factory CopyWith$Input$MarkFileAsViewedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkFileAsViewedInput;

  TRes call({
    String? clientMutationId,
    String? path,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$MarkFileAsViewedInput<TRes>
    implements CopyWith$Input$MarkFileAsViewedInput<TRes> {
  _CopyWithImpl$Input$MarkFileAsViewedInput(
    this._instance,
    this._then,
  );

  final Input$MarkFileAsViewedInput _instance;

  final TRes Function(Input$MarkFileAsViewedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? path = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$MarkFileAsViewedInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (path != _undefined && path != null) 'path': (path as String),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$MarkFileAsViewedInput<TRes>
    implements CopyWith$Input$MarkFileAsViewedInput<TRes> {
  _CopyWithStubImpl$Input$MarkFileAsViewedInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? path,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$MarkPullRequestReadyForReviewInput {
  factory Input$MarkPullRequestReadyForReviewInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$MarkPullRequestReadyForReviewInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$MarkPullRequestReadyForReviewInput._(this._$data);

  factory Input$MarkPullRequestReadyForReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$MarkPullRequestReadyForReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$MarkPullRequestReadyForReviewInput<
          Input$MarkPullRequestReadyForReviewInput>
      get copyWith => CopyWith$Input$MarkPullRequestReadyForReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MarkPullRequestReadyForReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  factory CopyWith$Input$MarkPullRequestReadyForReviewInput(
    Input$MarkPullRequestReadyForReviewInput instance,
    TRes Function(Input$MarkPullRequestReadyForReviewInput) then,
  ) = _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput;

  factory CopyWith$Input$MarkPullRequestReadyForReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput<TRes>
    implements CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  _CopyWithImpl$Input$MarkPullRequestReadyForReviewInput(
    this._instance,
    this._then,
  );

  final Input$MarkPullRequestReadyForReviewInput _instance;

  final TRes Function(Input$MarkPullRequestReadyForReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$MarkPullRequestReadyForReviewInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput<TRes>
    implements CopyWith$Input$MarkPullRequestReadyForReviewInput<TRes> {
  _CopyWithStubImpl$Input$MarkPullRequestReadyForReviewInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$MergeBranchInput {
  factory Input$MergeBranchInput({
    String? authorEmail,
    required String base,
    String? clientMutationId,
    String? commitMessage,
    required String head,
    required String repositoryId,
  }) =>
      Input$MergeBranchInput._({
        if (authorEmail != null) r'authorEmail': authorEmail,
        r'base': base,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (commitMessage != null) r'commitMessage': commitMessage,
        r'head': head,
        r'repositoryId': repositoryId,
      });

  Input$MergeBranchInput._(this._$data);

  factory Input$MergeBranchInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    final l$base = data['base'];
    result$data['base'] = (l$base as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('commitMessage')) {
      final l$commitMessage = data['commitMessage'];
      result$data['commitMessage'] = (l$commitMessage as String?);
    }
    final l$head = data['head'];
    result$data['head'] = (l$head as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$MergeBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get authorEmail => (_$data['authorEmail'] as String?);
  String get base => (_$data['base'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get commitMessage => (_$data['commitMessage'] as String?);
  String get head => (_$data['head'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    final l$base = base;
    result$data['base'] = l$base;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('commitMessage')) {
      final l$commitMessage = commitMessage;
      result$data['commitMessage'] = l$commitMessage;
    }
    final l$head = head;
    result$data['head'] = l$head;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$MergeBranchInput<Input$MergeBranchInput> get copyWith =>
      CopyWith$Input$MergeBranchInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergeBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    final l$base = base;
    final lOther$base = other.base;
    if (l$base != lOther$base) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$commitMessage = commitMessage;
    final lOther$commitMessage = other.commitMessage;
    if (_$data.containsKey('commitMessage') !=
        other._$data.containsKey('commitMessage')) {
      return false;
    }
    if (l$commitMessage != lOther$commitMessage) {
      return false;
    }
    final l$head = head;
    final lOther$head = other.head;
    if (l$head != lOther$head) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$authorEmail = authorEmail;
    final l$base = base;
    final l$clientMutationId = clientMutationId;
    final l$commitMessage = commitMessage;
    final l$head = head;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
      l$base,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('commitMessage') ? l$commitMessage : const {},
      l$head,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$MergeBranchInput<TRes> {
  factory CopyWith$Input$MergeBranchInput(
    Input$MergeBranchInput instance,
    TRes Function(Input$MergeBranchInput) then,
  ) = _CopyWithImpl$Input$MergeBranchInput;

  factory CopyWith$Input$MergeBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergeBranchInput;

  TRes call({
    String? authorEmail,
    String? base,
    String? clientMutationId,
    String? commitMessage,
    String? head,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$MergeBranchInput<TRes>
    implements CopyWith$Input$MergeBranchInput<TRes> {
  _CopyWithImpl$Input$MergeBranchInput(
    this._instance,
    this._then,
  );

  final Input$MergeBranchInput _instance;

  final TRes Function(Input$MergeBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? authorEmail = _undefined,
    Object? base = _undefined,
    Object? clientMutationId = _undefined,
    Object? commitMessage = _undefined,
    Object? head = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$MergeBranchInput._({
        ..._instance._$data,
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
        if (base != _undefined && base != null) 'base': (base as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (commitMessage != _undefined)
          'commitMessage': (commitMessage as String?),
        if (head != _undefined && head != null) 'head': (head as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$MergeBranchInput<TRes>
    implements CopyWith$Input$MergeBranchInput<TRes> {
  _CopyWithStubImpl$Input$MergeBranchInput(this._res);

  TRes _res;

  call({
    String? authorEmail,
    String? base,
    String? clientMutationId,
    String? commitMessage,
    String? head,
    String? repositoryId,
  }) =>
      _res;
}

class Input$MergePullRequestInput {
  factory Input$MergePullRequestInput({
    String? authorEmail,
    String? clientMutationId,
    String? commitBody,
    String? commitHeadline,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    required String pullRequestId,
  }) =>
      Input$MergePullRequestInput._({
        if (authorEmail != null) r'authorEmail': authorEmail,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (commitBody != null) r'commitBody': commitBody,
        if (commitHeadline != null) r'commitHeadline': commitHeadline,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
        if (mergeMethod != null) r'mergeMethod': mergeMethod,
        r'pullRequestId': pullRequestId,
      });

  Input$MergePullRequestInput._(this._$data);

  factory Input$MergePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('authorEmail')) {
      final l$authorEmail = data['authorEmail'];
      result$data['authorEmail'] = (l$authorEmail as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('commitBody')) {
      final l$commitBody = data['commitBody'];
      result$data['commitBody'] = (l$commitBody as String?);
    }
    if (data.containsKey('commitHeadline')) {
      final l$commitHeadline = data['commitHeadline'];
      result$data['commitHeadline'] = (l$commitHeadline as String?);
    }
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    if (data.containsKey('mergeMethod')) {
      final l$mergeMethod = data['mergeMethod'];
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : fromJson$Enum$PullRequestMergeMethod((l$mergeMethod as String));
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$MergePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get authorEmail => (_$data['authorEmail'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get commitBody => (_$data['commitBody'] as String?);
  String? get commitHeadline => (_$data['commitHeadline'] as String?);
  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);
  Enum$PullRequestMergeMethod? get mergeMethod =>
      (_$data['mergeMethod'] as Enum$PullRequestMergeMethod?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('authorEmail')) {
      final l$authorEmail = authorEmail;
      result$data['authorEmail'] = l$authorEmail;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('commitBody')) {
      final l$commitBody = commitBody;
      result$data['commitBody'] = l$commitBody;
    }
    if (_$data.containsKey('commitHeadline')) {
      final l$commitHeadline = commitHeadline;
      result$data['commitHeadline'] = l$commitHeadline;
    }
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    if (_$data.containsKey('mergeMethod')) {
      final l$mergeMethod = mergeMethod;
      result$data['mergeMethod'] = l$mergeMethod == null
          ? null
          : toJson$Enum$PullRequestMergeMethod(l$mergeMethod);
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$MergePullRequestInput<Input$MergePullRequestInput>
      get copyWith => CopyWith$Input$MergePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MergePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$authorEmail = authorEmail;
    final lOther$authorEmail = other.authorEmail;
    if (_$data.containsKey('authorEmail') !=
        other._$data.containsKey('authorEmail')) {
      return false;
    }
    if (l$authorEmail != lOther$authorEmail) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$commitBody = commitBody;
    final lOther$commitBody = other.commitBody;
    if (_$data.containsKey('commitBody') !=
        other._$data.containsKey('commitBody')) {
      return false;
    }
    if (l$commitBody != lOther$commitBody) {
      return false;
    }
    final l$commitHeadline = commitHeadline;
    final lOther$commitHeadline = other.commitHeadline;
    if (_$data.containsKey('commitHeadline') !=
        other._$data.containsKey('commitHeadline')) {
      return false;
    }
    if (l$commitHeadline != lOther$commitHeadline) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$mergeMethod = mergeMethod;
    final lOther$mergeMethod = other.mergeMethod;
    if (_$data.containsKey('mergeMethod') !=
        other._$data.containsKey('mergeMethod')) {
      return false;
    }
    if (l$mergeMethod != lOther$mergeMethod) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$authorEmail = authorEmail;
    final l$clientMutationId = clientMutationId;
    final l$commitBody = commitBody;
    final l$commitHeadline = commitHeadline;
    final l$expectedHeadOid = expectedHeadOid;
    final l$mergeMethod = mergeMethod;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('authorEmail') ? l$authorEmail : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('commitBody') ? l$commitBody : const {},
      _$data.containsKey('commitHeadline') ? l$commitHeadline : const {},
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
      _$data.containsKey('mergeMethod') ? l$mergeMethod : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$MergePullRequestInput<TRes> {
  factory CopyWith$Input$MergePullRequestInput(
    Input$MergePullRequestInput instance,
    TRes Function(Input$MergePullRequestInput) then,
  ) = _CopyWithImpl$Input$MergePullRequestInput;

  factory CopyWith$Input$MergePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MergePullRequestInput;

  TRes call({
    String? authorEmail,
    String? clientMutationId,
    String? commitBody,
    String? commitHeadline,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$MergePullRequestInput<TRes>
    implements CopyWith$Input$MergePullRequestInput<TRes> {
  _CopyWithImpl$Input$MergePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$MergePullRequestInput _instance;

  final TRes Function(Input$MergePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? authorEmail = _undefined,
    Object? clientMutationId = _undefined,
    Object? commitBody = _undefined,
    Object? commitHeadline = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? mergeMethod = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$MergePullRequestInput._({
        ..._instance._$data,
        if (authorEmail != _undefined) 'authorEmail': (authorEmail as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (commitBody != _undefined) 'commitBody': (commitBody as String?),
        if (commitHeadline != _undefined)
          'commitHeadline': (commitHeadline as String?),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
        if (mergeMethod != _undefined)
          'mergeMethod': (mergeMethod as Enum$PullRequestMergeMethod?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$MergePullRequestInput<TRes>
    implements CopyWith$Input$MergePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$MergePullRequestInput(this._res);

  TRes _res;

  call({
    String? authorEmail,
    String? clientMutationId,
    String? commitBody,
    String? commitHeadline,
    String? expectedHeadOid,
    Enum$PullRequestMergeMethod? mergeMethod,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$MilestoneOrder {
  factory Input$MilestoneOrder({
    required Enum$OrderDirection direction,
    required Enum$MilestoneOrderField field,
  }) =>
      Input$MilestoneOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$MilestoneOrder._(this._$data);

  factory Input$MilestoneOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$MilestoneOrderField((l$field as String));
    return Input$MilestoneOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$MilestoneOrderField get field =>
      (_$data['field'] as Enum$MilestoneOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$MilestoneOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$MilestoneOrder<Input$MilestoneOrder> get copyWith =>
      CopyWith$Input$MilestoneOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MilestoneOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$MilestoneOrder<TRes> {
  factory CopyWith$Input$MilestoneOrder(
    Input$MilestoneOrder instance,
    TRes Function(Input$MilestoneOrder) then,
  ) = _CopyWithImpl$Input$MilestoneOrder;

  factory CopyWith$Input$MilestoneOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$MilestoneOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$MilestoneOrderField? field,
  });
}

class _CopyWithImpl$Input$MilestoneOrder<TRes>
    implements CopyWith$Input$MilestoneOrder<TRes> {
  _CopyWithImpl$Input$MilestoneOrder(
    this._instance,
    this._then,
  );

  final Input$MilestoneOrder _instance;

  final TRes Function(Input$MilestoneOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$MilestoneOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$MilestoneOrderField),
      }));
}

class _CopyWithStubImpl$Input$MilestoneOrder<TRes>
    implements CopyWith$Input$MilestoneOrder<TRes> {
  _CopyWithStubImpl$Input$MilestoneOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$MilestoneOrderField? field,
  }) =>
      _res;
}

class Input$MinimizeCommentInput {
  factory Input$MinimizeCommentInput({
    required Enum$ReportedContentClassifiers classifier,
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$MinimizeCommentInput._({
        r'classifier': classifier,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$MinimizeCommentInput._(this._$data);

  factory Input$MinimizeCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$classifier = data['classifier'];
    result$data['classifier'] =
        fromJson$Enum$ReportedContentClassifiers((l$classifier as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$MinimizeCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ReportedContentClassifiers get classifier =>
      (_$data['classifier'] as Enum$ReportedContentClassifiers);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get subjectId => (_$data['subjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$classifier = classifier;
    result$data['classifier'] =
        toJson$Enum$ReportedContentClassifiers(l$classifier);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$MinimizeCommentInput<Input$MinimizeCommentInput>
      get copyWith => CopyWith$Input$MinimizeCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MinimizeCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$classifier = classifier;
    final lOther$classifier = other.classifier;
    if (l$classifier != lOther$classifier) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$classifier = classifier;
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      l$classifier,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$MinimizeCommentInput<TRes> {
  factory CopyWith$Input$MinimizeCommentInput(
    Input$MinimizeCommentInput instance,
    TRes Function(Input$MinimizeCommentInput) then,
  ) = _CopyWithImpl$Input$MinimizeCommentInput;

  factory CopyWith$Input$MinimizeCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MinimizeCommentInput;

  TRes call({
    Enum$ReportedContentClassifiers? classifier,
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$MinimizeCommentInput<TRes>
    implements CopyWith$Input$MinimizeCommentInput<TRes> {
  _CopyWithImpl$Input$MinimizeCommentInput(
    this._instance,
    this._then,
  );

  final Input$MinimizeCommentInput _instance;

  final TRes Function(Input$MinimizeCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? classifier = _undefined,
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$MinimizeCommentInput._({
        ..._instance._$data,
        if (classifier != _undefined && classifier != null)
          'classifier': (classifier as Enum$ReportedContentClassifiers),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$MinimizeCommentInput<TRes>
    implements CopyWith$Input$MinimizeCommentInput<TRes> {
  _CopyWithStubImpl$Input$MinimizeCommentInput(this._res);

  TRes _res;

  call({
    Enum$ReportedContentClassifiers? classifier,
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$MoveProjectCardInput {
  factory Input$MoveProjectCardInput({
    String? afterCardId,
    required String cardId,
    String? clientMutationId,
    required String columnId,
  }) =>
      Input$MoveProjectCardInput._({
        if (afterCardId != null) r'afterCardId': afterCardId,
        r'cardId': cardId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'columnId': columnId,
      });

  Input$MoveProjectCardInput._(this._$data);

  factory Input$MoveProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('afterCardId')) {
      final l$afterCardId = data['afterCardId'];
      result$data['afterCardId'] = (l$afterCardId as String?);
    }
    final l$cardId = data['cardId'];
    result$data['cardId'] = (l$cardId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    return Input$MoveProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get afterCardId => (_$data['afterCardId'] as String?);
  String get cardId => (_$data['cardId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get columnId => (_$data['columnId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('afterCardId')) {
      final l$afterCardId = afterCardId;
      result$data['afterCardId'] = l$afterCardId;
    }
    final l$cardId = cardId;
    result$data['cardId'] = l$cardId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    return result$data;
  }

  CopyWith$Input$MoveProjectCardInput<Input$MoveProjectCardInput>
      get copyWith => CopyWith$Input$MoveProjectCardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MoveProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$afterCardId = afterCardId;
    final lOther$afterCardId = other.afterCardId;
    if (_$data.containsKey('afterCardId') !=
        other._$data.containsKey('afterCardId')) {
      return false;
    }
    if (l$afterCardId != lOther$afterCardId) {
      return false;
    }
    final l$cardId = cardId;
    final lOther$cardId = other.cardId;
    if (l$cardId != lOther$cardId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$afterCardId = afterCardId;
    final l$cardId = cardId;
    final l$clientMutationId = clientMutationId;
    final l$columnId = columnId;
    return Object.hashAll([
      _$data.containsKey('afterCardId') ? l$afterCardId : const {},
      l$cardId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$columnId,
    ]);
  }
}

abstract class CopyWith$Input$MoveProjectCardInput<TRes> {
  factory CopyWith$Input$MoveProjectCardInput(
    Input$MoveProjectCardInput instance,
    TRes Function(Input$MoveProjectCardInput) then,
  ) = _CopyWithImpl$Input$MoveProjectCardInput;

  factory CopyWith$Input$MoveProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveProjectCardInput;

  TRes call({
    String? afterCardId,
    String? cardId,
    String? clientMutationId,
    String? columnId,
  });
}

class _CopyWithImpl$Input$MoveProjectCardInput<TRes>
    implements CopyWith$Input$MoveProjectCardInput<TRes> {
  _CopyWithImpl$Input$MoveProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$MoveProjectCardInput _instance;

  final TRes Function(Input$MoveProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? afterCardId = _undefined,
    Object? cardId = _undefined,
    Object? clientMutationId = _undefined,
    Object? columnId = _undefined,
  }) =>
      _then(Input$MoveProjectCardInput._({
        ..._instance._$data,
        if (afterCardId != _undefined) 'afterCardId': (afterCardId as String?),
        if (cardId != _undefined && cardId != null)
          'cardId': (cardId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
      }));
}

class _CopyWithStubImpl$Input$MoveProjectCardInput<TRes>
    implements CopyWith$Input$MoveProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$MoveProjectCardInput(this._res);

  TRes _res;

  call({
    String? afterCardId,
    String? cardId,
    String? clientMutationId,
    String? columnId,
  }) =>
      _res;
}

class Input$MoveProjectColumnInput {
  factory Input$MoveProjectColumnInput({
    String? afterColumnId,
    String? clientMutationId,
    required String columnId,
  }) =>
      Input$MoveProjectColumnInput._({
        if (afterColumnId != null) r'afterColumnId': afterColumnId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'columnId': columnId,
      });

  Input$MoveProjectColumnInput._(this._$data);

  factory Input$MoveProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('afterColumnId')) {
      final l$afterColumnId = data['afterColumnId'];
      result$data['afterColumnId'] = (l$afterColumnId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$columnId = data['columnId'];
    result$data['columnId'] = (l$columnId as String);
    return Input$MoveProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get afterColumnId => (_$data['afterColumnId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get columnId => (_$data['columnId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('afterColumnId')) {
      final l$afterColumnId = afterColumnId;
      result$data['afterColumnId'] = l$afterColumnId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$columnId = columnId;
    result$data['columnId'] = l$columnId;
    return result$data;
  }

  CopyWith$Input$MoveProjectColumnInput<Input$MoveProjectColumnInput>
      get copyWith => CopyWith$Input$MoveProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$MoveProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$afterColumnId = afterColumnId;
    final lOther$afterColumnId = other.afterColumnId;
    if (_$data.containsKey('afterColumnId') !=
        other._$data.containsKey('afterColumnId')) {
      return false;
    }
    if (l$afterColumnId != lOther$afterColumnId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$columnId = columnId;
    final lOther$columnId = other.columnId;
    if (l$columnId != lOther$columnId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$afterColumnId = afterColumnId;
    final l$clientMutationId = clientMutationId;
    final l$columnId = columnId;
    return Object.hashAll([
      _$data.containsKey('afterColumnId') ? l$afterColumnId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$columnId,
    ]);
  }
}

abstract class CopyWith$Input$MoveProjectColumnInput<TRes> {
  factory CopyWith$Input$MoveProjectColumnInput(
    Input$MoveProjectColumnInput instance,
    TRes Function(Input$MoveProjectColumnInput) then,
  ) = _CopyWithImpl$Input$MoveProjectColumnInput;

  factory CopyWith$Input$MoveProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$MoveProjectColumnInput;

  TRes call({
    String? afterColumnId,
    String? clientMutationId,
    String? columnId,
  });
}

class _CopyWithImpl$Input$MoveProjectColumnInput<TRes>
    implements CopyWith$Input$MoveProjectColumnInput<TRes> {
  _CopyWithImpl$Input$MoveProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$MoveProjectColumnInput _instance;

  final TRes Function(Input$MoveProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? afterColumnId = _undefined,
    Object? clientMutationId = _undefined,
    Object? columnId = _undefined,
  }) =>
      _then(Input$MoveProjectColumnInput._({
        ..._instance._$data,
        if (afterColumnId != _undefined)
          'afterColumnId': (afterColumnId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (columnId != _undefined && columnId != null)
          'columnId': (columnId as String),
      }));
}

class _CopyWithStubImpl$Input$MoveProjectColumnInput<TRes>
    implements CopyWith$Input$MoveProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$MoveProjectColumnInput(this._res);

  TRes _res;

  call({
    String? afterColumnId,
    String? clientMutationId,
    String? columnId,
  }) =>
      _res;
}

class Input$OrgEnterpriseOwnerOrder {
  factory Input$OrgEnterpriseOwnerOrder({
    required Enum$OrderDirection direction,
    required Enum$OrgEnterpriseOwnerOrderField field,
  }) =>
      Input$OrgEnterpriseOwnerOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$OrgEnterpriseOwnerOrder._(this._$data);

  factory Input$OrgEnterpriseOwnerOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$OrgEnterpriseOwnerOrderField((l$field as String));
    return Input$OrgEnterpriseOwnerOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$OrgEnterpriseOwnerOrderField get field =>
      (_$data['field'] as Enum$OrgEnterpriseOwnerOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$OrgEnterpriseOwnerOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$OrgEnterpriseOwnerOrder<Input$OrgEnterpriseOwnerOrder>
      get copyWith => CopyWith$Input$OrgEnterpriseOwnerOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OrgEnterpriseOwnerOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  factory CopyWith$Input$OrgEnterpriseOwnerOrder(
    Input$OrgEnterpriseOwnerOrder instance,
    TRes Function(Input$OrgEnterpriseOwnerOrder) then,
  ) = _CopyWithImpl$Input$OrgEnterpriseOwnerOrder;

  factory CopyWith$Input$OrgEnterpriseOwnerOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$OrgEnterpriseOwnerOrderField? field,
  });
}

class _CopyWithImpl$Input$OrgEnterpriseOwnerOrder<TRes>
    implements CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  _CopyWithImpl$Input$OrgEnterpriseOwnerOrder(
    this._instance,
    this._then,
  );

  final Input$OrgEnterpriseOwnerOrder _instance;

  final TRes Function(Input$OrgEnterpriseOwnerOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$OrgEnterpriseOwnerOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$OrgEnterpriseOwnerOrderField),
      }));
}

class _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder<TRes>
    implements CopyWith$Input$OrgEnterpriseOwnerOrder<TRes> {
  _CopyWithStubImpl$Input$OrgEnterpriseOwnerOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$OrgEnterpriseOwnerOrderField? field,
  }) =>
      _res;
}

class Input$OrganizationOrder {
  factory Input$OrganizationOrder({
    required Enum$OrderDirection direction,
    required Enum$OrganizationOrderField field,
  }) =>
      Input$OrganizationOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$OrganizationOrder._(this._$data);

  factory Input$OrganizationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$OrganizationOrderField((l$field as String));
    return Input$OrganizationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$OrganizationOrderField get field =>
      (_$data['field'] as Enum$OrganizationOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$OrganizationOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$OrganizationOrder<Input$OrganizationOrder> get copyWith =>
      CopyWith$Input$OrganizationOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$OrganizationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$OrganizationOrder<TRes> {
  factory CopyWith$Input$OrganizationOrder(
    Input$OrganizationOrder instance,
    TRes Function(Input$OrganizationOrder) then,
  ) = _CopyWithImpl$Input$OrganizationOrder;

  factory CopyWith$Input$OrganizationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$OrganizationOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$OrganizationOrderField? field,
  });
}

class _CopyWithImpl$Input$OrganizationOrder<TRes>
    implements CopyWith$Input$OrganizationOrder<TRes> {
  _CopyWithImpl$Input$OrganizationOrder(
    this._instance,
    this._then,
  );

  final Input$OrganizationOrder _instance;

  final TRes Function(Input$OrganizationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$OrganizationOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$OrganizationOrderField),
      }));
}

class _CopyWithStubImpl$Input$OrganizationOrder<TRes>
    implements CopyWith$Input$OrganizationOrder<TRes> {
  _CopyWithStubImpl$Input$OrganizationOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$OrganizationOrderField? field,
  }) =>
      _res;
}

class Input$PackageFileOrder {
  factory Input$PackageFileOrder({
    Enum$OrderDirection? direction,
    Enum$PackageFileOrderField? field,
  }) =>
      Input$PackageFileOrder._({
        if (direction != null) r'direction': direction,
        if (field != null) r'field': field,
      });

  Input$PackageFileOrder._(this._$data);

  factory Input$PackageFileOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageFileOrderField((l$field as String));
    }
    return Input$PackageFileOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Enum$PackageFileOrderField? get field =>
      (_$data['field'] as Enum$PackageFileOrderField?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$PackageFileOrderField(l$field);
    }
    return result$data;
  }

  CopyWith$Input$PackageFileOrder<Input$PackageFileOrder> get copyWith =>
      CopyWith$Input$PackageFileOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PackageFileOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      _$data.containsKey('direction') ? l$direction : const {},
      _$data.containsKey('field') ? l$field : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageFileOrder<TRes> {
  factory CopyWith$Input$PackageFileOrder(
    Input$PackageFileOrder instance,
    TRes Function(Input$PackageFileOrder) then,
  ) = _CopyWithImpl$Input$PackageFileOrder;

  factory CopyWith$Input$PackageFileOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageFileOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PackageFileOrderField? field,
  });
}

class _CopyWithImpl$Input$PackageFileOrder<TRes>
    implements CopyWith$Input$PackageFileOrder<TRes> {
  _CopyWithImpl$Input$PackageFileOrder(
    this._instance,
    this._then,
  );

  final Input$PackageFileOrder _instance;

  final TRes Function(Input$PackageFileOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PackageFileOrder._({
        ..._instance._$data,
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
        if (field != _undefined)
          'field': (field as Enum$PackageFileOrderField?),
      }));
}

class _CopyWithStubImpl$Input$PackageFileOrder<TRes>
    implements CopyWith$Input$PackageFileOrder<TRes> {
  _CopyWithStubImpl$Input$PackageFileOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PackageFileOrderField? field,
  }) =>
      _res;
}

class Input$PackageOrder {
  factory Input$PackageOrder({
    Enum$OrderDirection? direction,
    Enum$PackageOrderField? field,
  }) =>
      Input$PackageOrder._({
        if (direction != null) r'direction': direction,
        if (field != null) r'field': field,
      });

  Input$PackageOrder._(this._$data);

  factory Input$PackageOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageOrderField((l$field as String));
    }
    return Input$PackageOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Enum$PackageOrderField? get field =>
      (_$data['field'] as Enum$PackageOrderField?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] =
          l$field == null ? null : toJson$Enum$PackageOrderField(l$field);
    }
    return result$data;
  }

  CopyWith$Input$PackageOrder<Input$PackageOrder> get copyWith =>
      CopyWith$Input$PackageOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PackageOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      _$data.containsKey('direction') ? l$direction : const {},
      _$data.containsKey('field') ? l$field : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageOrder<TRes> {
  factory CopyWith$Input$PackageOrder(
    Input$PackageOrder instance,
    TRes Function(Input$PackageOrder) then,
  ) = _CopyWithImpl$Input$PackageOrder;

  factory CopyWith$Input$PackageOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PackageOrderField? field,
  });
}

class _CopyWithImpl$Input$PackageOrder<TRes>
    implements CopyWith$Input$PackageOrder<TRes> {
  _CopyWithImpl$Input$PackageOrder(
    this._instance,
    this._then,
  );

  final Input$PackageOrder _instance;

  final TRes Function(Input$PackageOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PackageOrder._({
        ..._instance._$data,
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
        if (field != _undefined) 'field': (field as Enum$PackageOrderField?),
      }));
}

class _CopyWithStubImpl$Input$PackageOrder<TRes>
    implements CopyWith$Input$PackageOrder<TRes> {
  _CopyWithStubImpl$Input$PackageOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PackageOrderField? field,
  }) =>
      _res;
}

class Input$PackageVersionOrder {
  factory Input$PackageVersionOrder({
    Enum$OrderDirection? direction,
    Enum$PackageVersionOrderField? field,
  }) =>
      Input$PackageVersionOrder._({
        if (direction != null) r'direction': direction,
        if (field != null) r'field': field,
      });

  Input$PackageVersionOrder._(this._$data);

  factory Input$PackageVersionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('direction')) {
      final l$direction = data['direction'];
      result$data['direction'] = l$direction == null
          ? null
          : fromJson$Enum$OrderDirection((l$direction as String));
    }
    if (data.containsKey('field')) {
      final l$field = data['field'];
      result$data['field'] = l$field == null
          ? null
          : fromJson$Enum$PackageVersionOrderField((l$field as String));
    }
    return Input$PackageVersionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection? get direction =>
      (_$data['direction'] as Enum$OrderDirection?);
  Enum$PackageVersionOrderField? get field =>
      (_$data['field'] as Enum$PackageVersionOrderField?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('direction')) {
      final l$direction = direction;
      result$data['direction'] =
          l$direction == null ? null : toJson$Enum$OrderDirection(l$direction);
    }
    if (_$data.containsKey('field')) {
      final l$field = field;
      result$data['field'] = l$field == null
          ? null
          : toJson$Enum$PackageVersionOrderField(l$field);
    }
    return result$data;
  }

  CopyWith$Input$PackageVersionOrder<Input$PackageVersionOrder> get copyWith =>
      CopyWith$Input$PackageVersionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PackageVersionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (_$data.containsKey('direction') !=
        other._$data.containsKey('direction')) {
      return false;
    }
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (_$data.containsKey('field') != other._$data.containsKey('field')) {
      return false;
    }
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      _$data.containsKey('direction') ? l$direction : const {},
      _$data.containsKey('field') ? l$field : const {},
    ]);
  }
}

abstract class CopyWith$Input$PackageVersionOrder<TRes> {
  factory CopyWith$Input$PackageVersionOrder(
    Input$PackageVersionOrder instance,
    TRes Function(Input$PackageVersionOrder) then,
  ) = _CopyWithImpl$Input$PackageVersionOrder;

  factory CopyWith$Input$PackageVersionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PackageVersionOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PackageVersionOrderField? field,
  });
}

class _CopyWithImpl$Input$PackageVersionOrder<TRes>
    implements CopyWith$Input$PackageVersionOrder<TRes> {
  _CopyWithImpl$Input$PackageVersionOrder(
    this._instance,
    this._then,
  );

  final Input$PackageVersionOrder _instance;

  final TRes Function(Input$PackageVersionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PackageVersionOrder._({
        ..._instance._$data,
        if (direction != _undefined)
          'direction': (direction as Enum$OrderDirection?),
        if (field != _undefined)
          'field': (field as Enum$PackageVersionOrderField?),
      }));
}

class _CopyWithStubImpl$Input$PackageVersionOrder<TRes>
    implements CopyWith$Input$PackageVersionOrder<TRes> {
  _CopyWithStubImpl$Input$PackageVersionOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PackageVersionOrderField? field,
  }) =>
      _res;
}

class Input$PinIssueInput {
  factory Input$PinIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$PinIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$PinIssueInput._(this._$data);

  factory Input$PinIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$PinIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get issueId => (_$data['issueId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$PinIssueInput<Input$PinIssueInput> get copyWith =>
      CopyWith$Input$PinIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PinIssueInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$PinIssueInput<TRes> {
  factory CopyWith$Input$PinIssueInput(
    Input$PinIssueInput instance,
    TRes Function(Input$PinIssueInput) then,
  ) = _CopyWithImpl$Input$PinIssueInput;

  factory CopyWith$Input$PinIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PinIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$PinIssueInput<TRes>
    implements CopyWith$Input$PinIssueInput<TRes> {
  _CopyWithImpl$Input$PinIssueInput(
    this._instance,
    this._then,
  );

  final Input$PinIssueInput _instance;

  final TRes Function(Input$PinIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$PinIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$PinIssueInput<TRes>
    implements CopyWith$Input$PinIssueInput<TRes> {
  _CopyWithStubImpl$Input$PinIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$ProjectCardImport {
  factory Input$ProjectCardImport({
    required int number,
    required String repository,
  }) =>
      Input$ProjectCardImport._({
        r'number': number,
        r'repository': repository,
      });

  Input$ProjectCardImport._(this._$data);

  factory Input$ProjectCardImport.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$number = data['number'];
    result$data['number'] = (l$number as int);
    final l$repository = data['repository'];
    result$data['repository'] = (l$repository as String);
    return Input$ProjectCardImport._(result$data);
  }

  Map<String, dynamic> _$data;

  int get number => (_$data['number'] as int);
  String get repository => (_$data['repository'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$number = number;
    result$data['number'] = l$number;
    final l$repository = repository;
    result$data['repository'] = l$repository;
    return result$data;
  }

  CopyWith$Input$ProjectCardImport<Input$ProjectCardImport> get copyWith =>
      CopyWith$Input$ProjectCardImport(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectCardImport) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (l$number != lOther$number) {
      return false;
    }
    final l$repository = repository;
    final lOther$repository = other.repository;
    if (l$repository != lOther$repository) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$number = number;
    final l$repository = repository;
    return Object.hashAll([
      l$number,
      l$repository,
    ]);
  }
}

abstract class CopyWith$Input$ProjectCardImport<TRes> {
  factory CopyWith$Input$ProjectCardImport(
    Input$ProjectCardImport instance,
    TRes Function(Input$ProjectCardImport) then,
  ) = _CopyWithImpl$Input$ProjectCardImport;

  factory CopyWith$Input$ProjectCardImport.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectCardImport;

  TRes call({
    int? number,
    String? repository,
  });
}

class _CopyWithImpl$Input$ProjectCardImport<TRes>
    implements CopyWith$Input$ProjectCardImport<TRes> {
  _CopyWithImpl$Input$ProjectCardImport(
    this._instance,
    this._then,
  );

  final Input$ProjectCardImport _instance;

  final TRes Function(Input$ProjectCardImport) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? number = _undefined,
    Object? repository = _undefined,
  }) =>
      _then(Input$ProjectCardImport._({
        ..._instance._$data,
        if (number != _undefined && number != null) 'number': (number as int),
        if (repository != _undefined && repository != null)
          'repository': (repository as String),
      }));
}

class _CopyWithStubImpl$Input$ProjectCardImport<TRes>
    implements CopyWith$Input$ProjectCardImport<TRes> {
  _CopyWithStubImpl$Input$ProjectCardImport(this._res);

  TRes _res;

  call({
    int? number,
    String? repository,
  }) =>
      _res;
}

class Input$ProjectColumnImport {
  factory Input$ProjectColumnImport({
    required String columnName,
    List<Input$ProjectCardImport>? issues,
    required int position,
  }) =>
      Input$ProjectColumnImport._({
        r'columnName': columnName,
        if (issues != null) r'issues': issues,
        r'position': position,
      });

  Input$ProjectColumnImport._(this._$data);

  factory Input$ProjectColumnImport.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$columnName = data['columnName'];
    result$data['columnName'] = (l$columnName as String);
    if (data.containsKey('issues')) {
      final l$issues = data['issues'];
      result$data['issues'] = (l$issues as List<dynamic>?)
          ?.map((e) =>
              Input$ProjectCardImport.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    final l$position = data['position'];
    result$data['position'] = (l$position as int);
    return Input$ProjectColumnImport._(result$data);
  }

  Map<String, dynamic> _$data;

  String get columnName => (_$data['columnName'] as String);
  List<Input$ProjectCardImport>? get issues =>
      (_$data['issues'] as List<Input$ProjectCardImport>?);
  int get position => (_$data['position'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$columnName = columnName;
    result$data['columnName'] = l$columnName;
    if (_$data.containsKey('issues')) {
      final l$issues = issues;
      result$data['issues'] = l$issues?.map((e) => e.toJson()).toList();
    }
    final l$position = position;
    result$data['position'] = l$position;
    return result$data;
  }

  CopyWith$Input$ProjectColumnImport<Input$ProjectColumnImport> get copyWith =>
      CopyWith$Input$ProjectColumnImport(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectColumnImport) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$columnName = columnName;
    final lOther$columnName = other.columnName;
    if (l$columnName != lOther$columnName) {
      return false;
    }
    final l$issues = issues;
    final lOther$issues = other.issues;
    if (_$data.containsKey('issues') != other._$data.containsKey('issues')) {
      return false;
    }
    if (l$issues != null && lOther$issues != null) {
      if (l$issues.length != lOther$issues.length) {
        return false;
      }
      for (int i = 0; i < l$issues.length; i++) {
        final l$issues$entry = l$issues[i];
        final lOther$issues$entry = lOther$issues[i];
        if (l$issues$entry != lOther$issues$entry) {
          return false;
        }
      }
    } else if (l$issues != lOther$issues) {
      return false;
    }
    final l$position = position;
    final lOther$position = other.position;
    if (l$position != lOther$position) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$columnName = columnName;
    final l$issues = issues;
    final l$position = position;
    return Object.hashAll([
      l$columnName,
      _$data.containsKey('issues')
          ? l$issues == null
              ? null
              : Object.hashAll(l$issues.map((v) => v))
          : const {},
      l$position,
    ]);
  }
}

abstract class CopyWith$Input$ProjectColumnImport<TRes> {
  factory CopyWith$Input$ProjectColumnImport(
    Input$ProjectColumnImport instance,
    TRes Function(Input$ProjectColumnImport) then,
  ) = _CopyWithImpl$Input$ProjectColumnImport;

  factory CopyWith$Input$ProjectColumnImport.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectColumnImport;

  TRes call({
    String? columnName,
    List<Input$ProjectCardImport>? issues,
    int? position,
  });
  TRes issues(
      Iterable<Input$ProjectCardImport>? Function(
              Iterable<
                  CopyWith$Input$ProjectCardImport<Input$ProjectCardImport>>?)
          _fn);
}

class _CopyWithImpl$Input$ProjectColumnImport<TRes>
    implements CopyWith$Input$ProjectColumnImport<TRes> {
  _CopyWithImpl$Input$ProjectColumnImport(
    this._instance,
    this._then,
  );

  final Input$ProjectColumnImport _instance;

  final TRes Function(Input$ProjectColumnImport) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? columnName = _undefined,
    Object? issues = _undefined,
    Object? position = _undefined,
  }) =>
      _then(Input$ProjectColumnImport._({
        ..._instance._$data,
        if (columnName != _undefined && columnName != null)
          'columnName': (columnName as String),
        if (issues != _undefined)
          'issues': (issues as List<Input$ProjectCardImport>?),
        if (position != _undefined && position != null)
          'position': (position as int),
      }));
  TRes issues(
          Iterable<Input$ProjectCardImport>? Function(
                  Iterable<
                      CopyWith$Input$ProjectCardImport<
                          Input$ProjectCardImport>>?)
              _fn) =>
      call(
          issues:
              _fn(_instance.issues?.map((e) => CopyWith$Input$ProjectCardImport(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProjectColumnImport<TRes>
    implements CopyWith$Input$ProjectColumnImport<TRes> {
  _CopyWithStubImpl$Input$ProjectColumnImport(this._res);

  TRes _res;

  call({
    String? columnName,
    List<Input$ProjectCardImport>? issues,
    int? position,
  }) =>
      _res;
  issues(_fn) => _res;
}

class Input$ProjectOrder {
  factory Input$ProjectOrder({
    required Enum$OrderDirection direction,
    required Enum$ProjectOrderField field,
  }) =>
      Input$ProjectOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProjectOrder._(this._$data);

  factory Input$ProjectOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$ProjectOrderField((l$field as String));
    return Input$ProjectOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ProjectOrderField get field =>
      (_$data['field'] as Enum$ProjectOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ProjectOrder<Input$ProjectOrder> get copyWith =>
      CopyWith$Input$ProjectOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProjectOrder<TRes> {
  factory CopyWith$Input$ProjectOrder(
    Input$ProjectOrder instance,
    TRes Function(Input$ProjectOrder) then,
  ) = _CopyWithImpl$Input$ProjectOrder;

  factory CopyWith$Input$ProjectOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProjectOrderField? field,
  });
}

class _CopyWithImpl$Input$ProjectOrder<TRes>
    implements CopyWith$Input$ProjectOrder<TRes> {
  _CopyWithImpl$Input$ProjectOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectOrder _instance;

  final TRes Function(Input$ProjectOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProjectOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectOrderField),
      }));
}

class _CopyWithStubImpl$Input$ProjectOrder<TRes>
    implements CopyWith$Input$ProjectOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProjectOrderField? field,
  }) =>
      _res;
}

class Input$ProjectV2FieldOrder {
  factory Input$ProjectV2FieldOrder({
    required Enum$OrderDirection direction,
    required Enum$ProjectV2FieldOrderField field,
  }) =>
      Input$ProjectV2FieldOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProjectV2FieldOrder._(this._$data);

  factory Input$ProjectV2FieldOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2FieldOrderField((l$field as String));
    return Input$ProjectV2FieldOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ProjectV2FieldOrderField get field =>
      (_$data['field'] as Enum$ProjectV2FieldOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2FieldOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ProjectV2FieldOrder<Input$ProjectV2FieldOrder> get copyWith =>
      CopyWith$Input$ProjectV2FieldOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2FieldOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2FieldOrder<TRes> {
  factory CopyWith$Input$ProjectV2FieldOrder(
    Input$ProjectV2FieldOrder instance,
    TRes Function(Input$ProjectV2FieldOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2FieldOrder;

  factory CopyWith$Input$ProjectV2FieldOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2FieldOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2FieldOrderField? field,
  });
}

class _CopyWithImpl$Input$ProjectV2FieldOrder<TRes>
    implements CopyWith$Input$ProjectV2FieldOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2FieldOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2FieldOrder _instance;

  final TRes Function(Input$ProjectV2FieldOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProjectV2FieldOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2FieldOrderField),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2FieldOrder<TRes>
    implements CopyWith$Input$ProjectV2FieldOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2FieldOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2FieldOrderField? field,
  }) =>
      _res;
}

class Input$ProjectV2FieldValue {
  factory Input$ProjectV2FieldValue({
    DateTime? date,
    String? iterationId,
    double? number,
    String? singleSelectOptionId,
    String? text,
  }) =>
      Input$ProjectV2FieldValue._({
        if (date != null) r'date': date,
        if (iterationId != null) r'iterationId': iterationId,
        if (number != null) r'number': number,
        if (singleSelectOptionId != null)
          r'singleSelectOptionId': singleSelectOptionId,
        if (text != null) r'text': text,
      });

  Input$ProjectV2FieldValue._(this._$data);

  factory Input$ProjectV2FieldValue.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] =
          l$date == null ? null : DateTime.parse((l$date as String));
    }
    if (data.containsKey('iterationId')) {
      final l$iterationId = data['iterationId'];
      result$data['iterationId'] = (l$iterationId as String?);
    }
    if (data.containsKey('number')) {
      final l$number = data['number'];
      result$data['number'] = (l$number as num?)?.toDouble();
    }
    if (data.containsKey('singleSelectOptionId')) {
      final l$singleSelectOptionId = data['singleSelectOptionId'];
      result$data['singleSelectOptionId'] = (l$singleSelectOptionId as String?);
    }
    if (data.containsKey('text')) {
      final l$text = data['text'];
      result$data['text'] = (l$text as String?);
    }
    return Input$ProjectV2FieldValue._(result$data);
  }

  Map<String, dynamic> _$data;

  DateTime? get date => (_$data['date'] as DateTime?);
  String? get iterationId => (_$data['iterationId'] as String?);
  double? get number => (_$data['number'] as double?);
  String? get singleSelectOptionId =>
      (_$data['singleSelectOptionId'] as String?);
  String? get text => (_$data['text'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toIso8601String();
    }
    if (_$data.containsKey('iterationId')) {
      final l$iterationId = iterationId;
      result$data['iterationId'] = l$iterationId;
    }
    if (_$data.containsKey('number')) {
      final l$number = number;
      result$data['number'] = l$number;
    }
    if (_$data.containsKey('singleSelectOptionId')) {
      final l$singleSelectOptionId = singleSelectOptionId;
      result$data['singleSelectOptionId'] = l$singleSelectOptionId;
    }
    if (_$data.containsKey('text')) {
      final l$text = text;
      result$data['text'] = l$text;
    }
    return result$data;
  }

  CopyWith$Input$ProjectV2FieldValue<Input$ProjectV2FieldValue> get copyWith =>
      CopyWith$Input$ProjectV2FieldValue(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2FieldValue) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$iterationId = iterationId;
    final lOther$iterationId = other.iterationId;
    if (_$data.containsKey('iterationId') !=
        other._$data.containsKey('iterationId')) {
      return false;
    }
    if (l$iterationId != lOther$iterationId) {
      return false;
    }
    final l$number = number;
    final lOther$number = other.number;
    if (_$data.containsKey('number') != other._$data.containsKey('number')) {
      return false;
    }
    if (l$number != lOther$number) {
      return false;
    }
    final l$singleSelectOptionId = singleSelectOptionId;
    final lOther$singleSelectOptionId = other.singleSelectOptionId;
    if (_$data.containsKey('singleSelectOptionId') !=
        other._$data.containsKey('singleSelectOptionId')) {
      return false;
    }
    if (l$singleSelectOptionId != lOther$singleSelectOptionId) {
      return false;
    }
    final l$text = text;
    final lOther$text = other.text;
    if (_$data.containsKey('text') != other._$data.containsKey('text')) {
      return false;
    }
    if (l$text != lOther$text) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$date = date;
    final l$iterationId = iterationId;
    final l$number = number;
    final l$singleSelectOptionId = singleSelectOptionId;
    final l$text = text;
    return Object.hashAll([
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('iterationId') ? l$iterationId : const {},
      _$data.containsKey('number') ? l$number : const {},
      _$data.containsKey('singleSelectOptionId')
          ? l$singleSelectOptionId
          : const {},
      _$data.containsKey('text') ? l$text : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2FieldValue<TRes> {
  factory CopyWith$Input$ProjectV2FieldValue(
    Input$ProjectV2FieldValue instance,
    TRes Function(Input$ProjectV2FieldValue) then,
  ) = _CopyWithImpl$Input$ProjectV2FieldValue;

  factory CopyWith$Input$ProjectV2FieldValue.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2FieldValue;

  TRes call({
    DateTime? date,
    String? iterationId,
    double? number,
    String? singleSelectOptionId,
    String? text,
  });
}

class _CopyWithImpl$Input$ProjectV2FieldValue<TRes>
    implements CopyWith$Input$ProjectV2FieldValue<TRes> {
  _CopyWithImpl$Input$ProjectV2FieldValue(
    this._instance,
    this._then,
  );

  final Input$ProjectV2FieldValue _instance;

  final TRes Function(Input$ProjectV2FieldValue) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? date = _undefined,
    Object? iterationId = _undefined,
    Object? number = _undefined,
    Object? singleSelectOptionId = _undefined,
    Object? text = _undefined,
  }) =>
      _then(Input$ProjectV2FieldValue._({
        ..._instance._$data,
        if (date != _undefined) 'date': (date as DateTime?),
        if (iterationId != _undefined) 'iterationId': (iterationId as String?),
        if (number != _undefined) 'number': (number as double?),
        if (singleSelectOptionId != _undefined)
          'singleSelectOptionId': (singleSelectOptionId as String?),
        if (text != _undefined) 'text': (text as String?),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2FieldValue<TRes>
    implements CopyWith$Input$ProjectV2FieldValue<TRes> {
  _CopyWithStubImpl$Input$ProjectV2FieldValue(this._res);

  TRes _res;

  call({
    DateTime? date,
    String? iterationId,
    double? number,
    String? singleSelectOptionId,
    String? text,
  }) =>
      _res;
}

class Input$ProjectV2Filters {
  factory Input$ProjectV2Filters({Enum$ProjectV2State? state}) =>
      Input$ProjectV2Filters._({
        if (state != null) r'state': state,
      });

  Input$ProjectV2Filters._(this._$data);

  factory Input$ProjectV2Filters.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$ProjectV2State((l$state as String));
    }
    return Input$ProjectV2Filters._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2State? get state => (_$data['state'] as Enum$ProjectV2State?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$ProjectV2State(l$state);
    }
    return result$data;
  }

  CopyWith$Input$ProjectV2Filters<Input$ProjectV2Filters> get copyWith =>
      CopyWith$Input$ProjectV2Filters(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2Filters) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$state = state;
    return Object.hashAll([_$data.containsKey('state') ? l$state : const {}]);
  }
}

abstract class CopyWith$Input$ProjectV2Filters<TRes> {
  factory CopyWith$Input$ProjectV2Filters(
    Input$ProjectV2Filters instance,
    TRes Function(Input$ProjectV2Filters) then,
  ) = _CopyWithImpl$Input$ProjectV2Filters;

  factory CopyWith$Input$ProjectV2Filters.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Filters;

  TRes call({Enum$ProjectV2State? state});
}

class _CopyWithImpl$Input$ProjectV2Filters<TRes>
    implements CopyWith$Input$ProjectV2Filters<TRes> {
  _CopyWithImpl$Input$ProjectV2Filters(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Filters _instance;

  final TRes Function(Input$ProjectV2Filters) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? state = _undefined}) => _then(Input$ProjectV2Filters._({
        ..._instance._$data,
        if (state != _undefined) 'state': (state as Enum$ProjectV2State?),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Filters<TRes>
    implements CopyWith$Input$ProjectV2Filters<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Filters(this._res);

  TRes _res;

  call({Enum$ProjectV2State? state}) => _res;
}

class Input$ProjectV2ItemFieldValueOrder {
  factory Input$ProjectV2ItemFieldValueOrder({
    required Enum$OrderDirection direction,
    required Enum$ProjectV2ItemFieldValueOrderField field,
  }) =>
      Input$ProjectV2ItemFieldValueOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProjectV2ItemFieldValueOrder._(this._$data);

  factory Input$ProjectV2ItemFieldValueOrder.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ItemFieldValueOrderField((l$field as String));
    return Input$ProjectV2ItemFieldValueOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ProjectV2ItemFieldValueOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ItemFieldValueOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] =
        toJson$Enum$ProjectV2ItemFieldValueOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ProjectV2ItemFieldValueOrder<
          Input$ProjectV2ItemFieldValueOrder>
      get copyWith => CopyWith$Input$ProjectV2ItemFieldValueOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2ItemFieldValueOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  factory CopyWith$Input$ProjectV2ItemFieldValueOrder(
    Input$ProjectV2ItemFieldValueOrder instance,
    TRes Function(Input$ProjectV2ItemFieldValueOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder;

  factory CopyWith$Input$ProjectV2ItemFieldValueOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2ItemFieldValueOrderField? field,
  });
}

class _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ItemFieldValueOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ItemFieldValueOrder _instance;

  final TRes Function(Input$ProjectV2ItemFieldValueOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProjectV2ItemFieldValueOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ItemFieldValueOrderField),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemFieldValueOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ItemFieldValueOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2ItemFieldValueOrderField? field,
  }) =>
      _res;
}

class Input$ProjectV2ItemOrder {
  factory Input$ProjectV2ItemOrder({
    required Enum$OrderDirection direction,
    required Enum$ProjectV2ItemOrderField field,
  }) =>
      Input$ProjectV2ItemOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProjectV2ItemOrder._(this._$data);

  factory Input$ProjectV2ItemOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ItemOrderField((l$field as String));
    return Input$ProjectV2ItemOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ProjectV2ItemOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ItemOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2ItemOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ProjectV2ItemOrder<Input$ProjectV2ItemOrder> get copyWith =>
      CopyWith$Input$ProjectV2ItemOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2ItemOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ItemOrder<TRes> {
  factory CopyWith$Input$ProjectV2ItemOrder(
    Input$ProjectV2ItemOrder instance,
    TRes Function(Input$ProjectV2ItemOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ItemOrder;

  factory CopyWith$Input$ProjectV2ItemOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ItemOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2ItemOrderField? field,
  });
}

class _CopyWithImpl$Input$ProjectV2ItemOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ItemOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ItemOrder _instance;

  final TRes Function(Input$ProjectV2ItemOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProjectV2ItemOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ItemOrderField),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ItemOrder<TRes>
    implements CopyWith$Input$ProjectV2ItemOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ItemOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2ItemOrderField? field,
  }) =>
      _res;
}

class Input$ProjectV2Order {
  factory Input$ProjectV2Order({
    required Enum$OrderDirection direction,
    required Enum$ProjectV2OrderField field,
  }) =>
      Input$ProjectV2Order._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProjectV2Order._(this._$data);

  factory Input$ProjectV2Order.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2OrderField((l$field as String));
    return Input$ProjectV2Order._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ProjectV2OrderField get field =>
      (_$data['field'] as Enum$ProjectV2OrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2OrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ProjectV2Order<Input$ProjectV2Order> get copyWith =>
      CopyWith$Input$ProjectV2Order(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2Order) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2Order<TRes> {
  factory CopyWith$Input$ProjectV2Order(
    Input$ProjectV2Order instance,
    TRes Function(Input$ProjectV2Order) then,
  ) = _CopyWithImpl$Input$ProjectV2Order;

  factory CopyWith$Input$ProjectV2Order.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2Order;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2OrderField? field,
  });
}

class _CopyWithImpl$Input$ProjectV2Order<TRes>
    implements CopyWith$Input$ProjectV2Order<TRes> {
  _CopyWithImpl$Input$ProjectV2Order(
    this._instance,
    this._then,
  );

  final Input$ProjectV2Order _instance;

  final TRes Function(Input$ProjectV2Order) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProjectV2Order._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2OrderField),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2Order<TRes>
    implements CopyWith$Input$ProjectV2Order<TRes> {
  _CopyWithStubImpl$Input$ProjectV2Order(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2OrderField? field,
  }) =>
      _res;
}

class Input$ProjectV2SingleSelectFieldOptionInput {
  factory Input$ProjectV2SingleSelectFieldOptionInput({
    required Enum$ProjectV2SingleSelectFieldOptionColor color,
    required String description,
    required String name,
  }) =>
      Input$ProjectV2SingleSelectFieldOptionInput._({
        r'color': color,
        r'description': description,
        r'name': name,
      });

  Input$ProjectV2SingleSelectFieldOptionInput._(this._$data);

  factory Input$ProjectV2SingleSelectFieldOptionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$color = data['color'];
    result$data['color'] = fromJson$Enum$ProjectV2SingleSelectFieldOptionColor(
        (l$color as String));
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$ProjectV2SingleSelectFieldOptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$ProjectV2SingleSelectFieldOptionColor get color =>
      (_$data['color'] as Enum$ProjectV2SingleSelectFieldOptionColor);
  String get description => (_$data['description'] as String);
  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$color = color;
    result$data['color'] =
        toJson$Enum$ProjectV2SingleSelectFieldOptionColor(l$color);
    final l$description = description;
    result$data['description'] = l$description;
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<
          Input$ProjectV2SingleSelectFieldOptionInput>
      get copyWith => CopyWith$Input$ProjectV2SingleSelectFieldOptionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2SingleSelectFieldOptionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$color = color;
    final l$description = description;
    final l$name = name;
    return Object.hashAll([
      l$color,
      l$description,
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<TRes> {
  factory CopyWith$Input$ProjectV2SingleSelectFieldOptionInput(
    Input$ProjectV2SingleSelectFieldOptionInput instance,
    TRes Function(Input$ProjectV2SingleSelectFieldOptionInput) then,
  ) = _CopyWithImpl$Input$ProjectV2SingleSelectFieldOptionInput;

  factory CopyWith$Input$ProjectV2SingleSelectFieldOptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2SingleSelectFieldOptionInput;

  TRes call({
    Enum$ProjectV2SingleSelectFieldOptionColor? color,
    String? description,
    String? name,
  });
}

class _CopyWithImpl$Input$ProjectV2SingleSelectFieldOptionInput<TRes>
    implements CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<TRes> {
  _CopyWithImpl$Input$ProjectV2SingleSelectFieldOptionInput(
    this._instance,
    this._then,
  );

  final Input$ProjectV2SingleSelectFieldOptionInput _instance;

  final TRes Function(Input$ProjectV2SingleSelectFieldOptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? color = _undefined,
    Object? description = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$ProjectV2SingleSelectFieldOptionInput._({
        ..._instance._$data,
        if (color != _undefined && color != null)
          'color': (color as Enum$ProjectV2SingleSelectFieldOptionColor),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2SingleSelectFieldOptionInput<TRes>
    implements CopyWith$Input$ProjectV2SingleSelectFieldOptionInput<TRes> {
  _CopyWithStubImpl$Input$ProjectV2SingleSelectFieldOptionInput(this._res);

  TRes _res;

  call({
    Enum$ProjectV2SingleSelectFieldOptionColor? color,
    String? description,
    String? name,
  }) =>
      _res;
}

class Input$ProjectV2ViewOrder {
  factory Input$ProjectV2ViewOrder({
    required Enum$OrderDirection direction,
    required Enum$ProjectV2ViewOrderField field,
  }) =>
      Input$ProjectV2ViewOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProjectV2ViewOrder._(this._$data);

  factory Input$ProjectV2ViewOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2ViewOrderField((l$field as String));
    return Input$ProjectV2ViewOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ProjectV2ViewOrderField get field =>
      (_$data['field'] as Enum$ProjectV2ViewOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2ViewOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ProjectV2ViewOrder<Input$ProjectV2ViewOrder> get copyWith =>
      CopyWith$Input$ProjectV2ViewOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2ViewOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2ViewOrder<TRes> {
  factory CopyWith$Input$ProjectV2ViewOrder(
    Input$ProjectV2ViewOrder instance,
    TRes Function(Input$ProjectV2ViewOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2ViewOrder;

  factory CopyWith$Input$ProjectV2ViewOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2ViewOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2ViewOrderField? field,
  });
}

class _CopyWithImpl$Input$ProjectV2ViewOrder<TRes>
    implements CopyWith$Input$ProjectV2ViewOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2ViewOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2ViewOrder _instance;

  final TRes Function(Input$ProjectV2ViewOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProjectV2ViewOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2ViewOrderField),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2ViewOrder<TRes>
    implements CopyWith$Input$ProjectV2ViewOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2ViewOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2ViewOrderField? field,
  }) =>
      _res;
}

class Input$ProjectV2WorkflowOrder {
  factory Input$ProjectV2WorkflowOrder({
    required Enum$OrderDirection direction,
    required Enum$ProjectV2WorkflowsOrderField field,
  }) =>
      Input$ProjectV2WorkflowOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ProjectV2WorkflowOrder._(this._$data);

  factory Input$ProjectV2WorkflowOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ProjectV2WorkflowsOrderField((l$field as String));
    return Input$ProjectV2WorkflowOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ProjectV2WorkflowsOrderField get field =>
      (_$data['field'] as Enum$ProjectV2WorkflowsOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ProjectV2WorkflowsOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ProjectV2WorkflowOrder<Input$ProjectV2WorkflowOrder>
      get copyWith => CopyWith$Input$ProjectV2WorkflowOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProjectV2WorkflowOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ProjectV2WorkflowOrder<TRes> {
  factory CopyWith$Input$ProjectV2WorkflowOrder(
    Input$ProjectV2WorkflowOrder instance,
    TRes Function(Input$ProjectV2WorkflowOrder) then,
  ) = _CopyWithImpl$Input$ProjectV2WorkflowOrder;

  factory CopyWith$Input$ProjectV2WorkflowOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ProjectV2WorkflowOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2WorkflowsOrderField? field,
  });
}

class _CopyWithImpl$Input$ProjectV2WorkflowOrder<TRes>
    implements CopyWith$Input$ProjectV2WorkflowOrder<TRes> {
  _CopyWithImpl$Input$ProjectV2WorkflowOrder(
    this._instance,
    this._then,
  );

  final Input$ProjectV2WorkflowOrder _instance;

  final TRes Function(Input$ProjectV2WorkflowOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ProjectV2WorkflowOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ProjectV2WorkflowsOrderField),
      }));
}

class _CopyWithStubImpl$Input$ProjectV2WorkflowOrder<TRes>
    implements CopyWith$Input$ProjectV2WorkflowOrder<TRes> {
  _CopyWithStubImpl$Input$ProjectV2WorkflowOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ProjectV2WorkflowsOrderField? field,
  }) =>
      _res;
}

class Input$PublishSponsorsTierInput {
  factory Input$PublishSponsorsTierInput({
    String? clientMutationId,
    required String tierId,
  }) =>
      Input$PublishSponsorsTierInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'tierId': tierId,
      });

  Input$PublishSponsorsTierInput._(this._$data);

  factory Input$PublishSponsorsTierInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$tierId = data['tierId'];
    result$data['tierId'] = (l$tierId as String);
    return Input$PublishSponsorsTierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get tierId => (_$data['tierId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$tierId = tierId;
    result$data['tierId'] = l$tierId;
    return result$data;
  }

  CopyWith$Input$PublishSponsorsTierInput<Input$PublishSponsorsTierInput>
      get copyWith => CopyWith$Input$PublishSponsorsTierInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PublishSponsorsTierInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$tierId = tierId;
    final lOther$tierId = other.tierId;
    if (l$tierId != lOther$tierId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$tierId = tierId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$tierId,
    ]);
  }
}

abstract class CopyWith$Input$PublishSponsorsTierInput<TRes> {
  factory CopyWith$Input$PublishSponsorsTierInput(
    Input$PublishSponsorsTierInput instance,
    TRes Function(Input$PublishSponsorsTierInput) then,
  ) = _CopyWithImpl$Input$PublishSponsorsTierInput;

  factory CopyWith$Input$PublishSponsorsTierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PublishSponsorsTierInput;

  TRes call({
    String? clientMutationId,
    String? tierId,
  });
}

class _CopyWithImpl$Input$PublishSponsorsTierInput<TRes>
    implements CopyWith$Input$PublishSponsorsTierInput<TRes> {
  _CopyWithImpl$Input$PublishSponsorsTierInput(
    this._instance,
    this._then,
  );

  final Input$PublishSponsorsTierInput _instance;

  final TRes Function(Input$PublishSponsorsTierInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? tierId = _undefined,
  }) =>
      _then(Input$PublishSponsorsTierInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (tierId != _undefined && tierId != null)
          'tierId': (tierId as String),
      }));
}

class _CopyWithStubImpl$Input$PublishSponsorsTierInput<TRes>
    implements CopyWith$Input$PublishSponsorsTierInput<TRes> {
  _CopyWithStubImpl$Input$PublishSponsorsTierInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? tierId,
  }) =>
      _res;
}

class Input$PullRequestOrder {
  factory Input$PullRequestOrder({
    required Enum$OrderDirection direction,
    required Enum$PullRequestOrderField field,
  }) =>
      Input$PullRequestOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$PullRequestOrder._(this._$data);

  factory Input$PullRequestOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$PullRequestOrderField((l$field as String));
    return Input$PullRequestOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$PullRequestOrderField get field =>
      (_$data['field'] as Enum$PullRequestOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$PullRequestOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$PullRequestOrder<Input$PullRequestOrder> get copyWith =>
      CopyWith$Input$PullRequestOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PullRequestOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$PullRequestOrder<TRes> {
  factory CopyWith$Input$PullRequestOrder(
    Input$PullRequestOrder instance,
    TRes Function(Input$PullRequestOrder) then,
  ) = _CopyWithImpl$Input$PullRequestOrder;

  factory CopyWith$Input$PullRequestOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$PullRequestOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$PullRequestOrderField? field,
  });
}

class _CopyWithImpl$Input$PullRequestOrder<TRes>
    implements CopyWith$Input$PullRequestOrder<TRes> {
  _CopyWithImpl$Input$PullRequestOrder(
    this._instance,
    this._then,
  );

  final Input$PullRequestOrder _instance;

  final TRes Function(Input$PullRequestOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$PullRequestOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$PullRequestOrderField),
      }));
}

class _CopyWithStubImpl$Input$PullRequestOrder<TRes>
    implements CopyWith$Input$PullRequestOrder<TRes> {
  _CopyWithStubImpl$Input$PullRequestOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$PullRequestOrderField? field,
  }) =>
      _res;
}

class Input$ReactionOrder {
  factory Input$ReactionOrder({
    required Enum$OrderDirection direction,
    required Enum$ReactionOrderField field,
  }) =>
      Input$ReactionOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ReactionOrder._(this._$data);

  factory Input$ReactionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$ReactionOrderField((l$field as String));
    return Input$ReactionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ReactionOrderField get field =>
      (_$data['field'] as Enum$ReactionOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ReactionOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ReactionOrder<Input$ReactionOrder> get copyWith =>
      CopyWith$Input$ReactionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReactionOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ReactionOrder<TRes> {
  factory CopyWith$Input$ReactionOrder(
    Input$ReactionOrder instance,
    TRes Function(Input$ReactionOrder) then,
  ) = _CopyWithImpl$Input$ReactionOrder;

  factory CopyWith$Input$ReactionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ReactionOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ReactionOrderField? field,
  });
}

class _CopyWithImpl$Input$ReactionOrder<TRes>
    implements CopyWith$Input$ReactionOrder<TRes> {
  _CopyWithImpl$Input$ReactionOrder(
    this._instance,
    this._then,
  );

  final Input$ReactionOrder _instance;

  final TRes Function(Input$ReactionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ReactionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ReactionOrderField),
      }));
}

class _CopyWithStubImpl$Input$ReactionOrder<TRes>
    implements CopyWith$Input$ReactionOrder<TRes> {
  _CopyWithStubImpl$Input$ReactionOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ReactionOrderField? field,
  }) =>
      _res;
}

class Input$RefOrder {
  factory Input$RefOrder({
    required Enum$OrderDirection direction,
    required Enum$RefOrderField field,
  }) =>
      Input$RefOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$RefOrder._(this._$data);

  factory Input$RefOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$RefOrderField((l$field as String));
    return Input$RefOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$RefOrderField get field => (_$data['field'] as Enum$RefOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$RefOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$RefOrder<Input$RefOrder> get copyWith =>
      CopyWith$Input$RefOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RefOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$RefOrder<TRes> {
  factory CopyWith$Input$RefOrder(
    Input$RefOrder instance,
    TRes Function(Input$RefOrder) then,
  ) = _CopyWithImpl$Input$RefOrder;

  factory CopyWith$Input$RefOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RefOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$RefOrderField? field,
  });
}

class _CopyWithImpl$Input$RefOrder<TRes>
    implements CopyWith$Input$RefOrder<TRes> {
  _CopyWithImpl$Input$RefOrder(
    this._instance,
    this._then,
  );

  final Input$RefOrder _instance;

  final TRes Function(Input$RefOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$RefOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$RefOrderField),
      }));
}

class _CopyWithStubImpl$Input$RefOrder<TRes>
    implements CopyWith$Input$RefOrder<TRes> {
  _CopyWithStubImpl$Input$RefOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$RefOrderField? field,
  }) =>
      _res;
}

class Input$RefUpdate {
  factory Input$RefUpdate({
    required String afterOid,
    String? beforeOid,
    bool? force,
    required String name,
  }) =>
      Input$RefUpdate._({
        r'afterOid': afterOid,
        if (beforeOid != null) r'beforeOid': beforeOid,
        if (force != null) r'force': force,
        r'name': name,
      });

  Input$RefUpdate._(this._$data);

  factory Input$RefUpdate.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$afterOid = data['afterOid'];
    result$data['afterOid'] = (l$afterOid as String);
    if (data.containsKey('beforeOid')) {
      final l$beforeOid = data['beforeOid'];
      result$data['beforeOid'] = (l$beforeOid as String?);
    }
    if (data.containsKey('force')) {
      final l$force = data['force'];
      result$data['force'] = (l$force as bool?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$RefUpdate._(result$data);
  }

  Map<String, dynamic> _$data;

  String get afterOid => (_$data['afterOid'] as String);
  String? get beforeOid => (_$data['beforeOid'] as String?);
  bool? get force => (_$data['force'] as bool?);
  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$afterOid = afterOid;
    result$data['afterOid'] = l$afterOid;
    if (_$data.containsKey('beforeOid')) {
      final l$beforeOid = beforeOid;
      result$data['beforeOid'] = l$beforeOid;
    }
    if (_$data.containsKey('force')) {
      final l$force = force;
      result$data['force'] = l$force;
    }
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$RefUpdate<Input$RefUpdate> get copyWith =>
      CopyWith$Input$RefUpdate(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RefUpdate) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$afterOid = afterOid;
    final lOther$afterOid = other.afterOid;
    if (l$afterOid != lOther$afterOid) {
      return false;
    }
    final l$beforeOid = beforeOid;
    final lOther$beforeOid = other.beforeOid;
    if (_$data.containsKey('beforeOid') !=
        other._$data.containsKey('beforeOid')) {
      return false;
    }
    if (l$beforeOid != lOther$beforeOid) {
      return false;
    }
    final l$force = force;
    final lOther$force = other.force;
    if (_$data.containsKey('force') != other._$data.containsKey('force')) {
      return false;
    }
    if (l$force != lOther$force) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$afterOid = afterOid;
    final l$beforeOid = beforeOid;
    final l$force = force;
    final l$name = name;
    return Object.hashAll([
      l$afterOid,
      _$data.containsKey('beforeOid') ? l$beforeOid : const {},
      _$data.containsKey('force') ? l$force : const {},
      l$name,
    ]);
  }
}

abstract class CopyWith$Input$RefUpdate<TRes> {
  factory CopyWith$Input$RefUpdate(
    Input$RefUpdate instance,
    TRes Function(Input$RefUpdate) then,
  ) = _CopyWithImpl$Input$RefUpdate;

  factory CopyWith$Input$RefUpdate.stub(TRes res) =
      _CopyWithStubImpl$Input$RefUpdate;

  TRes call({
    String? afterOid,
    String? beforeOid,
    bool? force,
    String? name,
  });
}

class _CopyWithImpl$Input$RefUpdate<TRes>
    implements CopyWith$Input$RefUpdate<TRes> {
  _CopyWithImpl$Input$RefUpdate(
    this._instance,
    this._then,
  );

  final Input$RefUpdate _instance;

  final TRes Function(Input$RefUpdate) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? afterOid = _undefined,
    Object? beforeOid = _undefined,
    Object? force = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$RefUpdate._({
        ..._instance._$data,
        if (afterOid != _undefined && afterOid != null)
          'afterOid': (afterOid as String),
        if (beforeOid != _undefined) 'beforeOid': (beforeOid as String?),
        if (force != _undefined) 'force': (force as bool?),
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$RefUpdate<TRes>
    implements CopyWith$Input$RefUpdate<TRes> {
  _CopyWithStubImpl$Input$RefUpdate(this._res);

  TRes _res;

  call({
    String? afterOid,
    String? beforeOid,
    bool? force,
    String? name,
  }) =>
      _res;
}

class Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  factory Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput({
    String? clientMutationId,
    required String enterpriseId,
  }) =>
      Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
      });

  Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._(this._$data);

  factory Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    return Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    return result$data;
  }

  CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
          Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput>
      get copyWith =>
          CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
    ]);
  }
}

abstract class CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
    TRes> {
  factory CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
    Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput instance,
    TRes Function(Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput)
        then,
  ) = _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput;

  factory CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
  });
}

class _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
        TRes>
    implements
        CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
            TRes> {
  _CopyWithImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
    this._instance,
    this._then,
  );

  final Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput _instance;

  final TRes Function(
      Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
  }) =>
      _then(Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
      }));
}

class _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
        TRes>
    implements
        CopyWith$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput<
            TRes> {
  _CopyWithStubImpl$Input$RegenerateEnterpriseIdentityProviderRecoveryCodesInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
  }) =>
      _res;
}

class Input$RegenerateVerifiableDomainTokenInput {
  factory Input$RegenerateVerifiableDomainTokenInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$RegenerateVerifiableDomainTokenInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$RegenerateVerifiableDomainTokenInput._(this._$data);

  factory Input$RegenerateVerifiableDomainTokenInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$RegenerateVerifiableDomainTokenInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$RegenerateVerifiableDomainTokenInput<
          Input$RegenerateVerifiableDomainTokenInput>
      get copyWith => CopyWith$Input$RegenerateVerifiableDomainTokenInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RegenerateVerifiableDomainTokenInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  factory CopyWith$Input$RegenerateVerifiableDomainTokenInput(
    Input$RegenerateVerifiableDomainTokenInput instance,
    TRes Function(Input$RegenerateVerifiableDomainTokenInput) then,
  ) = _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput;

  factory CopyWith$Input$RegenerateVerifiableDomainTokenInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput<TRes>
    implements CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  _CopyWithImpl$Input$RegenerateVerifiableDomainTokenInput(
    this._instance,
    this._then,
  );

  final Input$RegenerateVerifiableDomainTokenInput _instance;

  final TRes Function(Input$RegenerateVerifiableDomainTokenInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$RegenerateVerifiableDomainTokenInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput<TRes>
    implements CopyWith$Input$RegenerateVerifiableDomainTokenInput<TRes> {
  _CopyWithStubImpl$Input$RegenerateVerifiableDomainTokenInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$RejectDeploymentsInput {
  factory Input$RejectDeploymentsInput({
    String? clientMutationId,
    String? comment,
    required List<String> environmentIds,
    required String workflowRunId,
  }) =>
      Input$RejectDeploymentsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (comment != null) r'comment': comment,
        r'environmentIds': environmentIds,
        r'workflowRunId': workflowRunId,
      });

  Input$RejectDeploymentsInput._(this._$data);

  factory Input$RejectDeploymentsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('comment')) {
      final l$comment = data['comment'];
      result$data['comment'] = (l$comment as String?);
    }
    final l$environmentIds = data['environmentIds'];
    result$data['environmentIds'] =
        (l$environmentIds as List<dynamic>).map((e) => (e as String)).toList();
    final l$workflowRunId = data['workflowRunId'];
    result$data['workflowRunId'] = (l$workflowRunId as String);
    return Input$RejectDeploymentsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get comment => (_$data['comment'] as String?);
  List<String> get environmentIds => (_$data['environmentIds'] as List<String>);
  String get workflowRunId => (_$data['workflowRunId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('comment')) {
      final l$comment = comment;
      result$data['comment'] = l$comment;
    }
    final l$environmentIds = environmentIds;
    result$data['environmentIds'] = l$environmentIds.map((e) => e).toList();
    final l$workflowRunId = workflowRunId;
    result$data['workflowRunId'] = l$workflowRunId;
    return result$data;
  }

  CopyWith$Input$RejectDeploymentsInput<Input$RejectDeploymentsInput>
      get copyWith => CopyWith$Input$RejectDeploymentsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RejectDeploymentsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$comment = comment;
    final lOther$comment = other.comment;
    if (_$data.containsKey('comment') != other._$data.containsKey('comment')) {
      return false;
    }
    if (l$comment != lOther$comment) {
      return false;
    }
    final l$environmentIds = environmentIds;
    final lOther$environmentIds = other.environmentIds;
    if (l$environmentIds.length != lOther$environmentIds.length) {
      return false;
    }
    for (int i = 0; i < l$environmentIds.length; i++) {
      final l$environmentIds$entry = l$environmentIds[i];
      final lOther$environmentIds$entry = lOther$environmentIds[i];
      if (l$environmentIds$entry != lOther$environmentIds$entry) {
        return false;
      }
    }
    final l$workflowRunId = workflowRunId;
    final lOther$workflowRunId = other.workflowRunId;
    if (l$workflowRunId != lOther$workflowRunId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$comment = comment;
    final l$environmentIds = environmentIds;
    final l$workflowRunId = workflowRunId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('comment') ? l$comment : const {},
      Object.hashAll(l$environmentIds.map((v) => v)),
      l$workflowRunId,
    ]);
  }
}

abstract class CopyWith$Input$RejectDeploymentsInput<TRes> {
  factory CopyWith$Input$RejectDeploymentsInput(
    Input$RejectDeploymentsInput instance,
    TRes Function(Input$RejectDeploymentsInput) then,
  ) = _CopyWithImpl$Input$RejectDeploymentsInput;

  factory CopyWith$Input$RejectDeploymentsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RejectDeploymentsInput;

  TRes call({
    String? clientMutationId,
    String? comment,
    List<String>? environmentIds,
    String? workflowRunId,
  });
}

class _CopyWithImpl$Input$RejectDeploymentsInput<TRes>
    implements CopyWith$Input$RejectDeploymentsInput<TRes> {
  _CopyWithImpl$Input$RejectDeploymentsInput(
    this._instance,
    this._then,
  );

  final Input$RejectDeploymentsInput _instance;

  final TRes Function(Input$RejectDeploymentsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? comment = _undefined,
    Object? environmentIds = _undefined,
    Object? workflowRunId = _undefined,
  }) =>
      _then(Input$RejectDeploymentsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (comment != _undefined) 'comment': (comment as String?),
        if (environmentIds != _undefined && environmentIds != null)
          'environmentIds': (environmentIds as List<String>),
        if (workflowRunId != _undefined && workflowRunId != null)
          'workflowRunId': (workflowRunId as String),
      }));
}

class _CopyWithStubImpl$Input$RejectDeploymentsInput<TRes>
    implements CopyWith$Input$RejectDeploymentsInput<TRes> {
  _CopyWithStubImpl$Input$RejectDeploymentsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? comment,
    List<String>? environmentIds,
    String? workflowRunId,
  }) =>
      _res;
}

class Input$ReleaseOrder {
  factory Input$ReleaseOrder({
    required Enum$OrderDirection direction,
    required Enum$ReleaseOrderField field,
  }) =>
      Input$ReleaseOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$ReleaseOrder._(this._$data);

  factory Input$ReleaseOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$ReleaseOrderField((l$field as String));
    return Input$ReleaseOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$ReleaseOrderField get field =>
      (_$data['field'] as Enum$ReleaseOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$ReleaseOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$ReleaseOrder<Input$ReleaseOrder> get copyWith =>
      CopyWith$Input$ReleaseOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReleaseOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$ReleaseOrder<TRes> {
  factory CopyWith$Input$ReleaseOrder(
    Input$ReleaseOrder instance,
    TRes Function(Input$ReleaseOrder) then,
  ) = _CopyWithImpl$Input$ReleaseOrder;

  factory CopyWith$Input$ReleaseOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$ReleaseOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$ReleaseOrderField? field,
  });
}

class _CopyWithImpl$Input$ReleaseOrder<TRes>
    implements CopyWith$Input$ReleaseOrder<TRes> {
  _CopyWithImpl$Input$ReleaseOrder(
    this._instance,
    this._then,
  );

  final Input$ReleaseOrder _instance;

  final TRes Function(Input$ReleaseOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$ReleaseOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$ReleaseOrderField),
      }));
}

class _CopyWithStubImpl$Input$ReleaseOrder<TRes>
    implements CopyWith$Input$ReleaseOrder<TRes> {
  _CopyWithStubImpl$Input$ReleaseOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$ReleaseOrderField? field,
  }) =>
      _res;
}

class Input$RemoveAssigneesFromAssignableInput {
  factory Input$RemoveAssigneesFromAssignableInput({
    required String assignableId,
    required List<String> assigneeIds,
    String? clientMutationId,
  }) =>
      Input$RemoveAssigneesFromAssignableInput._({
        r'assignableId': assignableId,
        r'assigneeIds': assigneeIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
      });

  Input$RemoveAssigneesFromAssignableInput._(this._$data);

  factory Input$RemoveAssigneesFromAssignableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$assignableId = data['assignableId'];
    result$data['assignableId'] = (l$assignableId as String);
    final l$assigneeIds = data['assigneeIds'];
    result$data['assigneeIds'] =
        (l$assigneeIds as List<dynamic>).map((e) => (e as String)).toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    return Input$RemoveAssigneesFromAssignableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get assignableId => (_$data['assignableId'] as String);
  List<String> get assigneeIds => (_$data['assigneeIds'] as List<String>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$assignableId = assignableId;
    result$data['assignableId'] = l$assignableId;
    final l$assigneeIds = assigneeIds;
    result$data['assigneeIds'] = l$assigneeIds.map((e) => e).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    return result$data;
  }

  CopyWith$Input$RemoveAssigneesFromAssignableInput<
          Input$RemoveAssigneesFromAssignableInput>
      get copyWith => CopyWith$Input$RemoveAssigneesFromAssignableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveAssigneesFromAssignableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assignableId = assignableId;
    final lOther$assignableId = other.assignableId;
    if (l$assignableId != lOther$assignableId) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (l$assigneeIds.length != lOther$assigneeIds.length) {
      return false;
    }
    for (int i = 0; i < l$assigneeIds.length; i++) {
      final l$assigneeIds$entry = l$assigneeIds[i];
      final lOther$assigneeIds$entry = lOther$assigneeIds[i];
      if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assignableId = assignableId;
    final l$assigneeIds = assigneeIds;
    final l$clientMutationId = clientMutationId;
    return Object.hashAll([
      l$assignableId,
      Object.hashAll(l$assigneeIds.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
    ]);
  }
}

abstract class CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  factory CopyWith$Input$RemoveAssigneesFromAssignableInput(
    Input$RemoveAssigneesFromAssignableInput instance,
    TRes Function(Input$RemoveAssigneesFromAssignableInput) then,
  ) = _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput;

  factory CopyWith$Input$RemoveAssigneesFromAssignableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput;

  TRes call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  });
}

class _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput<TRes>
    implements CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  _CopyWithImpl$Input$RemoveAssigneesFromAssignableInput(
    this._instance,
    this._then,
  );

  final Input$RemoveAssigneesFromAssignableInput _instance;

  final TRes Function(Input$RemoveAssigneesFromAssignableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assignableId = _undefined,
    Object? assigneeIds = _undefined,
    Object? clientMutationId = _undefined,
  }) =>
      _then(Input$RemoveAssigneesFromAssignableInput._({
        ..._instance._$data,
        if (assignableId != _undefined && assignableId != null)
          'assignableId': (assignableId as String),
        if (assigneeIds != _undefined && assigneeIds != null)
          'assigneeIds': (assigneeIds as List<String>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
      }));
}

class _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput<TRes>
    implements CopyWith$Input$RemoveAssigneesFromAssignableInput<TRes> {
  _CopyWithStubImpl$Input$RemoveAssigneesFromAssignableInput(this._res);

  TRes _res;

  call({
    String? assignableId,
    List<String>? assigneeIds,
    String? clientMutationId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseAdminInput {
  factory Input$RemoveEnterpriseAdminInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$RemoveEnterpriseAdminInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$RemoveEnterpriseAdminInput._(this._$data);

  factory Input$RemoveEnterpriseAdminInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$RemoveEnterpriseAdminInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseAdminInput<Input$RemoveEnterpriseAdminInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseAdminInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseAdminInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseAdminInput(
    Input$RemoveEnterpriseAdminInput instance,
    TRes Function(Input$RemoveEnterpriseAdminInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseAdminInput;

  factory CopyWith$Input$RemoveEnterpriseAdminInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseAdminInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseAdminInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseAdminInput _instance;

  final TRes Function(Input$RemoveEnterpriseAdminInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseAdminInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseAdminInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseAdminInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$RemoveEnterpriseIdentityProviderInput {
  factory Input$RemoveEnterpriseIdentityProviderInput({
    String? clientMutationId,
    required String enterpriseId,
  }) =>
      Input$RemoveEnterpriseIdentityProviderInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
      });

  Input$RemoveEnterpriseIdentityProviderInput._(this._$data);

  factory Input$RemoveEnterpriseIdentityProviderInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    return Input$RemoveEnterpriseIdentityProviderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseIdentityProviderInput<
          Input$RemoveEnterpriseIdentityProviderInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseIdentityProviderInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseIdentityProviderInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseIdentityProviderInput(
    Input$RemoveEnterpriseIdentityProviderInput instance,
    TRes Function(Input$RemoveEnterpriseIdentityProviderInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput;

  factory CopyWith$Input$RemoveEnterpriseIdentityProviderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseIdentityProviderInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseIdentityProviderInput _instance;

  final TRes Function(Input$RemoveEnterpriseIdentityProviderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseIdentityProviderInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseIdentityProviderInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseIdentityProviderInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseMemberInput {
  factory Input$RemoveEnterpriseMemberInput({
    String? clientMutationId,
    required String enterpriseId,
    required String userId,
  }) =>
      Input$RemoveEnterpriseMemberInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'userId': userId,
      });

  Input$RemoveEnterpriseMemberInput._(this._$data);

  factory Input$RemoveEnterpriseMemberInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$RemoveEnterpriseMemberInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get userId => (_$data['userId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseMemberInput<Input$RemoveEnterpriseMemberInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseMemberInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseMemberInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseMemberInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseMemberInput(
    Input$RemoveEnterpriseMemberInput instance,
    TRes Function(Input$RemoveEnterpriseMemberInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseMemberInput;

  factory CopyWith$Input$RemoveEnterpriseMemberInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseMemberInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? userId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseMemberInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseMemberInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseMemberInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseMemberInput _instance;

  final TRes Function(Input$RemoveEnterpriseMemberInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseMemberInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseMemberInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseMemberInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseMemberInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? userId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseOrganizationInput {
  factory Input$RemoveEnterpriseOrganizationInput({
    String? clientMutationId,
    required String enterpriseId,
    required String organizationId,
  }) =>
      Input$RemoveEnterpriseOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
      });

  Input$RemoveEnterpriseOrganizationInput._(this._$data);

  factory Input$RemoveEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$RemoveEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseOrganizationInput<
          Input$RemoveEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseOrganizationInput(
    Input$RemoveEnterpriseOrganizationInput instance,
    TRes Function(Input$RemoveEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput;

  factory CopyWith$Input$RemoveEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseOrganizationInput _instance;

  final TRes Function(Input$RemoveEnterpriseOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
  }) =>
      _res;
}

class Input$RemoveEnterpriseSupportEntitlementInput {
  factory Input$RemoveEnterpriseSupportEntitlementInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$RemoveEnterpriseSupportEntitlementInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$RemoveEnterpriseSupportEntitlementInput._(this._$data);

  factory Input$RemoveEnterpriseSupportEntitlementInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$RemoveEnterpriseSupportEntitlementInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<
          Input$RemoveEnterpriseSupportEntitlementInput>
      get copyWith => CopyWith$Input$RemoveEnterpriseSupportEntitlementInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveEnterpriseSupportEntitlementInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  factory CopyWith$Input$RemoveEnterpriseSupportEntitlementInput(
    Input$RemoveEnterpriseSupportEntitlementInput instance,
    TRes Function(Input$RemoveEnterpriseSupportEntitlementInput) then,
  ) = _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput;

  factory CopyWith$Input$RemoveEnterpriseSupportEntitlementInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithImpl$Input$RemoveEnterpriseSupportEntitlementInput(
    this._instance,
    this._then,
  );

  final Input$RemoveEnterpriseSupportEntitlementInput _instance;

  final TRes Function(Input$RemoveEnterpriseSupportEntitlementInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$RemoveEnterpriseSupportEntitlementInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput<TRes>
    implements CopyWith$Input$RemoveEnterpriseSupportEntitlementInput<TRes> {
  _CopyWithStubImpl$Input$RemoveEnterpriseSupportEntitlementInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$RemoveLabelsFromLabelableInput {
  factory Input$RemoveLabelsFromLabelableInput({
    String? clientMutationId,
    required List<String> labelIds,
    required String labelableId,
  }) =>
      Input$RemoveLabelsFromLabelableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'labelIds': labelIds,
        r'labelableId': labelableId,
      });

  Input$RemoveLabelsFromLabelableInput._(this._$data);

  factory Input$RemoveLabelsFromLabelableInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$labelIds = data['labelIds'];
    result$data['labelIds'] =
        (l$labelIds as List<dynamic>).map((e) => (e as String)).toList();
    final l$labelableId = data['labelableId'];
    result$data['labelableId'] = (l$labelableId as String);
    return Input$RemoveLabelsFromLabelableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String> get labelIds => (_$data['labelIds'] as List<String>);
  String get labelableId => (_$data['labelableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$labelIds = labelIds;
    result$data['labelIds'] = l$labelIds.map((e) => e).toList();
    final l$labelableId = labelableId;
    result$data['labelableId'] = l$labelableId;
    return result$data;
  }

  CopyWith$Input$RemoveLabelsFromLabelableInput<
          Input$RemoveLabelsFromLabelableInput>
      get copyWith => CopyWith$Input$RemoveLabelsFromLabelableInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveLabelsFromLabelableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (l$labelIds.length != lOther$labelIds.length) {
      return false;
    }
    for (int i = 0; i < l$labelIds.length; i++) {
      final l$labelIds$entry = l$labelIds[i];
      final lOther$labelIds$entry = lOther$labelIds[i];
      if (l$labelIds$entry != lOther$labelIds$entry) {
        return false;
      }
    }
    final l$labelableId = labelableId;
    final lOther$labelableId = other.labelableId;
    if (l$labelableId != lOther$labelableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$labelIds = labelIds;
    final l$labelableId = labelableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$labelIds.map((v) => v)),
      l$labelableId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  factory CopyWith$Input$RemoveLabelsFromLabelableInput(
    Input$RemoveLabelsFromLabelableInput instance,
    TRes Function(Input$RemoveLabelsFromLabelableInput) then,
  ) = _CopyWithImpl$Input$RemoveLabelsFromLabelableInput;

  factory CopyWith$Input$RemoveLabelsFromLabelableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput;

  TRes call({
    String? clientMutationId,
    List<String>? labelIds,
    String? labelableId,
  });
}

class _CopyWithImpl$Input$RemoveLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  _CopyWithImpl$Input$RemoveLabelsFromLabelableInput(
    this._instance,
    this._then,
  );

  final Input$RemoveLabelsFromLabelableInput _instance;

  final TRes Function(Input$RemoveLabelsFromLabelableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? labelIds = _undefined,
    Object? labelableId = _undefined,
  }) =>
      _then(Input$RemoveLabelsFromLabelableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelIds != _undefined && labelIds != null)
          'labelIds': (labelIds as List<String>),
        if (labelableId != _undefined && labelableId != null)
          'labelableId': (labelableId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput<TRes>
    implements CopyWith$Input$RemoveLabelsFromLabelableInput<TRes> {
  _CopyWithStubImpl$Input$RemoveLabelsFromLabelableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<String>? labelIds,
    String? labelableId,
  }) =>
      _res;
}

class Input$RemoveOutsideCollaboratorInput {
  factory Input$RemoveOutsideCollaboratorInput({
    String? clientMutationId,
    required String organizationId,
    required String userId,
  }) =>
      Input$RemoveOutsideCollaboratorInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'userId': userId,
      });

  Input$RemoveOutsideCollaboratorInput._(this._$data);

  factory Input$RemoveOutsideCollaboratorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$RemoveOutsideCollaboratorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get organizationId => (_$data['organizationId'] as String);
  String get userId => (_$data['userId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$RemoveOutsideCollaboratorInput<
          Input$RemoveOutsideCollaboratorInput>
      get copyWith => CopyWith$Input$RemoveOutsideCollaboratorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveOutsideCollaboratorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  factory CopyWith$Input$RemoveOutsideCollaboratorInput(
    Input$RemoveOutsideCollaboratorInput instance,
    TRes Function(Input$RemoveOutsideCollaboratorInput) then,
  ) = _CopyWithImpl$Input$RemoveOutsideCollaboratorInput;

  factory CopyWith$Input$RemoveOutsideCollaboratorInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$RemoveOutsideCollaboratorInput<TRes>
    implements CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  _CopyWithImpl$Input$RemoveOutsideCollaboratorInput(
    this._instance,
    this._then,
  );

  final Input$RemoveOutsideCollaboratorInput _instance;

  final TRes Function(Input$RemoveOutsideCollaboratorInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$RemoveOutsideCollaboratorInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput<TRes>
    implements CopyWith$Input$RemoveOutsideCollaboratorInput<TRes> {
  _CopyWithStubImpl$Input$RemoveOutsideCollaboratorInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    String? userId,
  }) =>
      _res;
}

class Input$RemoveReactionInput {
  factory Input$RemoveReactionInput({
    String? clientMutationId,
    required Enum$ReactionContent content,
    required String subjectId,
  }) =>
      Input$RemoveReactionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'content': content,
        r'subjectId': subjectId,
      });

  Input$RemoveReactionInput._(this._$data);

  factory Input$RemoveReactionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$content = data['content'];
    result$data['content'] =
        fromJson$Enum$ReactionContent((l$content as String));
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$RemoveReactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$ReactionContent get content =>
      (_$data['content'] as Enum$ReactionContent);
  String get subjectId => (_$data['subjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$content = content;
    result$data['content'] = toJson$Enum$ReactionContent(l$content);
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$RemoveReactionInput<Input$RemoveReactionInput> get copyWith =>
      CopyWith$Input$RemoveReactionInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveReactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$content = content;
    final lOther$content = other.content;
    if (l$content != lOther$content) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$content = content;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$content,
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveReactionInput<TRes> {
  factory CopyWith$Input$RemoveReactionInput(
    Input$RemoveReactionInput instance,
    TRes Function(Input$RemoveReactionInput) then,
  ) = _CopyWithImpl$Input$RemoveReactionInput;

  factory CopyWith$Input$RemoveReactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveReactionInput;

  TRes call({
    String? clientMutationId,
    Enum$ReactionContent? content,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$RemoveReactionInput<TRes>
    implements CopyWith$Input$RemoveReactionInput<TRes> {
  _CopyWithImpl$Input$RemoveReactionInput(
    this._instance,
    this._then,
  );

  final Input$RemoveReactionInput _instance;

  final TRes Function(Input$RemoveReactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? content = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$RemoveReactionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (content != _undefined && content != null)
          'content': (content as Enum$ReactionContent),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveReactionInput<TRes>
    implements CopyWith$Input$RemoveReactionInput<TRes> {
  _CopyWithStubImpl$Input$RemoveReactionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$ReactionContent? content,
    String? subjectId,
  }) =>
      _res;
}

class Input$RemoveStarInput {
  factory Input$RemoveStarInput({
    String? clientMutationId,
    required String starrableId,
  }) =>
      Input$RemoveStarInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'starrableId': starrableId,
      });

  Input$RemoveStarInput._(this._$data);

  factory Input$RemoveStarInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$starrableId = data['starrableId'];
    result$data['starrableId'] = (l$starrableId as String);
    return Input$RemoveStarInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get starrableId => (_$data['starrableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$starrableId = starrableId;
    result$data['starrableId'] = l$starrableId;
    return result$data;
  }

  CopyWith$Input$RemoveStarInput<Input$RemoveStarInput> get copyWith =>
      CopyWith$Input$RemoveStarInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveStarInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$starrableId = starrableId;
    final lOther$starrableId = other.starrableId;
    if (l$starrableId != lOther$starrableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$starrableId = starrableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$starrableId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveStarInput<TRes> {
  factory CopyWith$Input$RemoveStarInput(
    Input$RemoveStarInput instance,
    TRes Function(Input$RemoveStarInput) then,
  ) = _CopyWithImpl$Input$RemoveStarInput;

  factory CopyWith$Input$RemoveStarInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveStarInput;

  TRes call({
    String? clientMutationId,
    String? starrableId,
  });
}

class _CopyWithImpl$Input$RemoveStarInput<TRes>
    implements CopyWith$Input$RemoveStarInput<TRes> {
  _CopyWithImpl$Input$RemoveStarInput(
    this._instance,
    this._then,
  );

  final Input$RemoveStarInput _instance;

  final TRes Function(Input$RemoveStarInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? starrableId = _undefined,
  }) =>
      _then(Input$RemoveStarInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (starrableId != _undefined && starrableId != null)
          'starrableId': (starrableId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveStarInput<TRes>
    implements CopyWith$Input$RemoveStarInput<TRes> {
  _CopyWithStubImpl$Input$RemoveStarInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? starrableId,
  }) =>
      _res;
}

class Input$RemoveUpvoteInput {
  factory Input$RemoveUpvoteInput({
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$RemoveUpvoteInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$RemoveUpvoteInput._(this._$data);

  factory Input$RemoveUpvoteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$RemoveUpvoteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get subjectId => (_$data['subjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$RemoveUpvoteInput<Input$RemoveUpvoteInput> get copyWith =>
      CopyWith$Input$RemoveUpvoteInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RemoveUpvoteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$RemoveUpvoteInput<TRes> {
  factory CopyWith$Input$RemoveUpvoteInput(
    Input$RemoveUpvoteInput instance,
    TRes Function(Input$RemoveUpvoteInput) then,
  ) = _CopyWithImpl$Input$RemoveUpvoteInput;

  factory CopyWith$Input$RemoveUpvoteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RemoveUpvoteInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$RemoveUpvoteInput<TRes>
    implements CopyWith$Input$RemoveUpvoteInput<TRes> {
  _CopyWithImpl$Input$RemoveUpvoteInput(
    this._instance,
    this._then,
  );

  final Input$RemoveUpvoteInput _instance;

  final TRes Function(Input$RemoveUpvoteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$RemoveUpvoteInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$RemoveUpvoteInput<TRes>
    implements CopyWith$Input$RemoveUpvoteInput<TRes> {
  _CopyWithStubImpl$Input$RemoveUpvoteInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$ReopenDiscussionInput {
  factory Input$ReopenDiscussionInput({
    String? clientMutationId,
    required String discussionId,
  }) =>
      Input$ReopenDiscussionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
      });

  Input$ReopenDiscussionInput._(this._$data);

  factory Input$ReopenDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    return Input$ReopenDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get discussionId => (_$data['discussionId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    return result$data;
  }

  CopyWith$Input$ReopenDiscussionInput<Input$ReopenDiscussionInput>
      get copyWith => CopyWith$Input$ReopenDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReopenDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
    ]);
  }
}

abstract class CopyWith$Input$ReopenDiscussionInput<TRes> {
  factory CopyWith$Input$ReopenDiscussionInput(
    Input$ReopenDiscussionInput instance,
    TRes Function(Input$ReopenDiscussionInput) then,
  ) = _CopyWithImpl$Input$ReopenDiscussionInput;

  factory CopyWith$Input$ReopenDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenDiscussionInput;

  TRes call({
    String? clientMutationId,
    String? discussionId,
  });
}

class _CopyWithImpl$Input$ReopenDiscussionInput<TRes>
    implements CopyWith$Input$ReopenDiscussionInput<TRes> {
  _CopyWithImpl$Input$ReopenDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$ReopenDiscussionInput _instance;

  final TRes Function(Input$ReopenDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
  }) =>
      _then(Input$ReopenDiscussionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
      }));
}

class _CopyWithStubImpl$Input$ReopenDiscussionInput<TRes>
    implements CopyWith$Input$ReopenDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$ReopenDiscussionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? discussionId,
  }) =>
      _res;
}

class Input$ReopenIssueInput {
  factory Input$ReopenIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$ReopenIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$ReopenIssueInput._(this._$data);

  factory Input$ReopenIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$ReopenIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get issueId => (_$data['issueId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$ReopenIssueInput<Input$ReopenIssueInput> get copyWith =>
      CopyWith$Input$ReopenIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReopenIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$ReopenIssueInput<TRes> {
  factory CopyWith$Input$ReopenIssueInput(
    Input$ReopenIssueInput instance,
    TRes Function(Input$ReopenIssueInput) then,
  ) = _CopyWithImpl$Input$ReopenIssueInput;

  factory CopyWith$Input$ReopenIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$ReopenIssueInput<TRes>
    implements CopyWith$Input$ReopenIssueInput<TRes> {
  _CopyWithImpl$Input$ReopenIssueInput(
    this._instance,
    this._then,
  );

  final Input$ReopenIssueInput _instance;

  final TRes Function(Input$ReopenIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$ReopenIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$ReopenIssueInput<TRes>
    implements CopyWith$Input$ReopenIssueInput<TRes> {
  _CopyWithStubImpl$Input$ReopenIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$ReopenPullRequestInput {
  factory Input$ReopenPullRequestInput({
    String? clientMutationId,
    required String pullRequestId,
  }) =>
      Input$ReopenPullRequestInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
      });

  Input$ReopenPullRequestInput._(this._$data);

  factory Input$ReopenPullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$ReopenPullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$ReopenPullRequestInput<Input$ReopenPullRequestInput>
      get copyWith => CopyWith$Input$ReopenPullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ReopenPullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$ReopenPullRequestInput<TRes> {
  factory CopyWith$Input$ReopenPullRequestInput(
    Input$ReopenPullRequestInput instance,
    TRes Function(Input$ReopenPullRequestInput) then,
  ) = _CopyWithImpl$Input$ReopenPullRequestInput;

  factory CopyWith$Input$ReopenPullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ReopenPullRequestInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$ReopenPullRequestInput<TRes>
    implements CopyWith$Input$ReopenPullRequestInput<TRes> {
  _CopyWithImpl$Input$ReopenPullRequestInput(
    this._instance,
    this._then,
  );

  final Input$ReopenPullRequestInput _instance;

  final TRes Function(Input$ReopenPullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$ReopenPullRequestInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$ReopenPullRequestInput<TRes>
    implements CopyWith$Input$ReopenPullRequestInput<TRes> {
  _CopyWithStubImpl$Input$ReopenPullRequestInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$RepositoryInvitationOrder {
  factory Input$RepositoryInvitationOrder({
    required Enum$OrderDirection direction,
    required Enum$RepositoryInvitationOrderField field,
  }) =>
      Input$RepositoryInvitationOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$RepositoryInvitationOrder._(this._$data);

  factory Input$RepositoryInvitationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryInvitationOrderField((l$field as String));
    return Input$RepositoryInvitationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$RepositoryInvitationOrderField get field =>
      (_$data['field'] as Enum$RepositoryInvitationOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryInvitationOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$RepositoryInvitationOrder<Input$RepositoryInvitationOrder>
      get copyWith => CopyWith$Input$RepositoryInvitationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RepositoryInvitationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryInvitationOrder<TRes> {
  factory CopyWith$Input$RepositoryInvitationOrder(
    Input$RepositoryInvitationOrder instance,
    TRes Function(Input$RepositoryInvitationOrder) then,
  ) = _CopyWithImpl$Input$RepositoryInvitationOrder;

  factory CopyWith$Input$RepositoryInvitationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryInvitationOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$RepositoryInvitationOrderField? field,
  });
}

class _CopyWithImpl$Input$RepositoryInvitationOrder<TRes>
    implements CopyWith$Input$RepositoryInvitationOrder<TRes> {
  _CopyWithImpl$Input$RepositoryInvitationOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryInvitationOrder _instance;

  final TRes Function(Input$RepositoryInvitationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$RepositoryInvitationOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryInvitationOrderField),
      }));
}

class _CopyWithStubImpl$Input$RepositoryInvitationOrder<TRes>
    implements CopyWith$Input$RepositoryInvitationOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryInvitationOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$RepositoryInvitationOrderField? field,
  }) =>
      _res;
}

class Input$RepositoryMigrationOrder {
  factory Input$RepositoryMigrationOrder({
    required Enum$RepositoryMigrationOrderDirection direction,
    required Enum$RepositoryMigrationOrderField field,
  }) =>
      Input$RepositoryMigrationOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$RepositoryMigrationOrder._(this._$data);

  factory Input$RepositoryMigrationOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] = fromJson$Enum$RepositoryMigrationOrderDirection(
        (l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryMigrationOrderField((l$field as String));
    return Input$RepositoryMigrationOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$RepositoryMigrationOrderDirection get direction =>
      (_$data['direction'] as Enum$RepositoryMigrationOrderDirection);
  Enum$RepositoryMigrationOrderField get field =>
      (_$data['field'] as Enum$RepositoryMigrationOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] =
        toJson$Enum$RepositoryMigrationOrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryMigrationOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$RepositoryMigrationOrder<Input$RepositoryMigrationOrder>
      get copyWith => CopyWith$Input$RepositoryMigrationOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RepositoryMigrationOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryMigrationOrder<TRes> {
  factory CopyWith$Input$RepositoryMigrationOrder(
    Input$RepositoryMigrationOrder instance,
    TRes Function(Input$RepositoryMigrationOrder) then,
  ) = _CopyWithImpl$Input$RepositoryMigrationOrder;

  factory CopyWith$Input$RepositoryMigrationOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryMigrationOrder;

  TRes call({
    Enum$RepositoryMigrationOrderDirection? direction,
    Enum$RepositoryMigrationOrderField? field,
  });
}

class _CopyWithImpl$Input$RepositoryMigrationOrder<TRes>
    implements CopyWith$Input$RepositoryMigrationOrder<TRes> {
  _CopyWithImpl$Input$RepositoryMigrationOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryMigrationOrder _instance;

  final TRes Function(Input$RepositoryMigrationOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$RepositoryMigrationOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$RepositoryMigrationOrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryMigrationOrderField),
      }));
}

class _CopyWithStubImpl$Input$RepositoryMigrationOrder<TRes>
    implements CopyWith$Input$RepositoryMigrationOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryMigrationOrder(this._res);

  TRes _res;

  call({
    Enum$RepositoryMigrationOrderDirection? direction,
    Enum$RepositoryMigrationOrderField? field,
  }) =>
      _res;
}

class Input$RepositoryOrder {
  factory Input$RepositoryOrder({
    required Enum$OrderDirection direction,
    required Enum$RepositoryOrderField field,
  }) =>
      Input$RepositoryOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$RepositoryOrder._(this._$data);

  factory Input$RepositoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$RepositoryOrderField((l$field as String));
    return Input$RepositoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$RepositoryOrderField get field =>
      (_$data['field'] as Enum$RepositoryOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$RepositoryOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$RepositoryOrder<Input$RepositoryOrder> get copyWith =>
      CopyWith$Input$RepositoryOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RepositoryOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$RepositoryOrder<TRes> {
  factory CopyWith$Input$RepositoryOrder(
    Input$RepositoryOrder instance,
    TRes Function(Input$RepositoryOrder) then,
  ) = _CopyWithImpl$Input$RepositoryOrder;

  factory CopyWith$Input$RepositoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$RepositoryOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$RepositoryOrderField? field,
  });
}

class _CopyWithImpl$Input$RepositoryOrder<TRes>
    implements CopyWith$Input$RepositoryOrder<TRes> {
  _CopyWithImpl$Input$RepositoryOrder(
    this._instance,
    this._then,
  );

  final Input$RepositoryOrder _instance;

  final TRes Function(Input$RepositoryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$RepositoryOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$RepositoryOrderField),
      }));
}

class _CopyWithStubImpl$Input$RepositoryOrder<TRes>
    implements CopyWith$Input$RepositoryOrder<TRes> {
  _CopyWithStubImpl$Input$RepositoryOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$RepositoryOrderField? field,
  }) =>
      _res;
}

class Input$RequestReviewsInput {
  factory Input$RequestReviewsInput({
    String? clientMutationId,
    required String pullRequestId,
    List<String>? teamIds,
    bool? union,
    List<String>? userIds,
  }) =>
      Input$RequestReviewsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestId': pullRequestId,
        if (teamIds != null) r'teamIds': teamIds,
        if (union != null) r'union': union,
        if (userIds != null) r'userIds': userIds,
      });

  Input$RequestReviewsInput._(this._$data);

  factory Input$RequestReviewsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('teamIds')) {
      final l$teamIds = data['teamIds'];
      result$data['teamIds'] =
          (l$teamIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('union')) {
      final l$union = data['union'];
      result$data['union'] = (l$union as bool?);
    }
    if (data.containsKey('userIds')) {
      final l$userIds = data['userIds'];
      result$data['userIds'] =
          (l$userIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    return Input$RequestReviewsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  List<String>? get teamIds => (_$data['teamIds'] as List<String>?);
  bool? get union => (_$data['union'] as bool?);
  List<String>? get userIds => (_$data['userIds'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('teamIds')) {
      final l$teamIds = teamIds;
      result$data['teamIds'] = l$teamIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('union')) {
      final l$union = union;
      result$data['union'] = l$union;
    }
    if (_$data.containsKey('userIds')) {
      final l$userIds = userIds;
      result$data['userIds'] = l$userIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$RequestReviewsInput<Input$RequestReviewsInput> get copyWith =>
      CopyWith$Input$RequestReviewsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RequestReviewsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$teamIds = teamIds;
    final lOther$teamIds = other.teamIds;
    if (_$data.containsKey('teamIds') != other._$data.containsKey('teamIds')) {
      return false;
    }
    if (l$teamIds != null && lOther$teamIds != null) {
      if (l$teamIds.length != lOther$teamIds.length) {
        return false;
      }
      for (int i = 0; i < l$teamIds.length; i++) {
        final l$teamIds$entry = l$teamIds[i];
        final lOther$teamIds$entry = lOther$teamIds[i];
        if (l$teamIds$entry != lOther$teamIds$entry) {
          return false;
        }
      }
    } else if (l$teamIds != lOther$teamIds) {
      return false;
    }
    final l$union = union;
    final lOther$union = other.union;
    if (_$data.containsKey('union') != other._$data.containsKey('union')) {
      return false;
    }
    if (l$union != lOther$union) {
      return false;
    }
    final l$userIds = userIds;
    final lOther$userIds = other.userIds;
    if (_$data.containsKey('userIds') != other._$data.containsKey('userIds')) {
      return false;
    }
    if (l$userIds != null && lOther$userIds != null) {
      if (l$userIds.length != lOther$userIds.length) {
        return false;
      }
      for (int i = 0; i < l$userIds.length; i++) {
        final l$userIds$entry = l$userIds[i];
        final lOther$userIds$entry = lOther$userIds[i];
        if (l$userIds$entry != lOther$userIds$entry) {
          return false;
        }
      }
    } else if (l$userIds != lOther$userIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$pullRequestId = pullRequestId;
    final l$teamIds = teamIds;
    final l$union = union;
    final l$userIds = userIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestId,
      _$data.containsKey('teamIds')
          ? l$teamIds == null
              ? null
              : Object.hashAll(l$teamIds.map((v) => v))
          : const {},
      _$data.containsKey('union') ? l$union : const {},
      _$data.containsKey('userIds')
          ? l$userIds == null
              ? null
              : Object.hashAll(l$userIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$RequestReviewsInput<TRes> {
  factory CopyWith$Input$RequestReviewsInput(
    Input$RequestReviewsInput instance,
    TRes Function(Input$RequestReviewsInput) then,
  ) = _CopyWithImpl$Input$RequestReviewsInput;

  factory CopyWith$Input$RequestReviewsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequestReviewsInput;

  TRes call({
    String? clientMutationId,
    String? pullRequestId,
    List<String>? teamIds,
    bool? union,
    List<String>? userIds,
  });
}

class _CopyWithImpl$Input$RequestReviewsInput<TRes>
    implements CopyWith$Input$RequestReviewsInput<TRes> {
  _CopyWithImpl$Input$RequestReviewsInput(
    this._instance,
    this._then,
  );

  final Input$RequestReviewsInput _instance;

  final TRes Function(Input$RequestReviewsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? pullRequestId = _undefined,
    Object? teamIds = _undefined,
    Object? union = _undefined,
    Object? userIds = _undefined,
  }) =>
      _then(Input$RequestReviewsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (teamIds != _undefined) 'teamIds': (teamIds as List<String>?),
        if (union != _undefined) 'union': (union as bool?),
        if (userIds != _undefined) 'userIds': (userIds as List<String>?),
      }));
}

class _CopyWithStubImpl$Input$RequestReviewsInput<TRes>
    implements CopyWith$Input$RequestReviewsInput<TRes> {
  _CopyWithStubImpl$Input$RequestReviewsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? pullRequestId,
    List<String>? teamIds,
    bool? union,
    List<String>? userIds,
  }) =>
      _res;
}

class Input$RequiredStatusCheckInput {
  factory Input$RequiredStatusCheckInput({
    String? appId,
    required String context,
  }) =>
      Input$RequiredStatusCheckInput._({
        if (appId != null) r'appId': appId,
        r'context': context,
      });

  Input$RequiredStatusCheckInput._(this._$data);

  factory Input$RequiredStatusCheckInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('appId')) {
      final l$appId = data['appId'];
      result$data['appId'] = (l$appId as String?);
    }
    final l$context = data['context'];
    result$data['context'] = (l$context as String);
    return Input$RequiredStatusCheckInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get appId => (_$data['appId'] as String?);
  String get context => (_$data['context'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('appId')) {
      final l$appId = appId;
      result$data['appId'] = l$appId;
    }
    final l$context = context;
    result$data['context'] = l$context;
    return result$data;
  }

  CopyWith$Input$RequiredStatusCheckInput<Input$RequiredStatusCheckInput>
      get copyWith => CopyWith$Input$RequiredStatusCheckInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RequiredStatusCheckInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$appId = appId;
    final lOther$appId = other.appId;
    if (_$data.containsKey('appId') != other._$data.containsKey('appId')) {
      return false;
    }
    if (l$appId != lOther$appId) {
      return false;
    }
    final l$context = context;
    final lOther$context = other.context;
    if (l$context != lOther$context) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$appId = appId;
    final l$context = context;
    return Object.hashAll([
      _$data.containsKey('appId') ? l$appId : const {},
      l$context,
    ]);
  }
}

abstract class CopyWith$Input$RequiredStatusCheckInput<TRes> {
  factory CopyWith$Input$RequiredStatusCheckInput(
    Input$RequiredStatusCheckInput instance,
    TRes Function(Input$RequiredStatusCheckInput) then,
  ) = _CopyWithImpl$Input$RequiredStatusCheckInput;

  factory CopyWith$Input$RequiredStatusCheckInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RequiredStatusCheckInput;

  TRes call({
    String? appId,
    String? context,
  });
}

class _CopyWithImpl$Input$RequiredStatusCheckInput<TRes>
    implements CopyWith$Input$RequiredStatusCheckInput<TRes> {
  _CopyWithImpl$Input$RequiredStatusCheckInput(
    this._instance,
    this._then,
  );

  final Input$RequiredStatusCheckInput _instance;

  final TRes Function(Input$RequiredStatusCheckInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? appId = _undefined,
    Object? context = _undefined,
  }) =>
      _then(Input$RequiredStatusCheckInput._({
        ..._instance._$data,
        if (appId != _undefined) 'appId': (appId as String?),
        if (context != _undefined && context != null)
          'context': (context as String),
      }));
}

class _CopyWithStubImpl$Input$RequiredStatusCheckInput<TRes>
    implements CopyWith$Input$RequiredStatusCheckInput<TRes> {
  _CopyWithStubImpl$Input$RequiredStatusCheckInput(this._res);

  TRes _res;

  call({
    String? appId,
    String? context,
  }) =>
      _res;
}

class Input$RerequestCheckSuiteInput {
  factory Input$RerequestCheckSuiteInput({
    required String checkSuiteId,
    String? clientMutationId,
    required String repositoryId,
  }) =>
      Input$RerequestCheckSuiteInput._({
        r'checkSuiteId': checkSuiteId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
      });

  Input$RerequestCheckSuiteInput._(this._$data);

  factory Input$RerequestCheckSuiteInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$checkSuiteId = data['checkSuiteId'];
    result$data['checkSuiteId'] = (l$checkSuiteId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$RerequestCheckSuiteInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get checkSuiteId => (_$data['checkSuiteId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$checkSuiteId = checkSuiteId;
    result$data['checkSuiteId'] = l$checkSuiteId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$RerequestCheckSuiteInput<Input$RerequestCheckSuiteInput>
      get copyWith => CopyWith$Input$RerequestCheckSuiteInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RerequestCheckSuiteInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$checkSuiteId = checkSuiteId;
    final lOther$checkSuiteId = other.checkSuiteId;
    if (l$checkSuiteId != lOther$checkSuiteId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$checkSuiteId = checkSuiteId;
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      l$checkSuiteId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  factory CopyWith$Input$RerequestCheckSuiteInput(
    Input$RerequestCheckSuiteInput instance,
    TRes Function(Input$RerequestCheckSuiteInput) then,
  ) = _CopyWithImpl$Input$RerequestCheckSuiteInput;

  factory CopyWith$Input$RerequestCheckSuiteInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RerequestCheckSuiteInput;

  TRes call({
    String? checkSuiteId,
    String? clientMutationId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$RerequestCheckSuiteInput<TRes>
    implements CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  _CopyWithImpl$Input$RerequestCheckSuiteInput(
    this._instance,
    this._then,
  );

  final Input$RerequestCheckSuiteInput _instance;

  final TRes Function(Input$RerequestCheckSuiteInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? checkSuiteId = _undefined,
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$RerequestCheckSuiteInput._({
        ..._instance._$data,
        if (checkSuiteId != _undefined && checkSuiteId != null)
          'checkSuiteId': (checkSuiteId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$RerequestCheckSuiteInput<TRes>
    implements CopyWith$Input$RerequestCheckSuiteInput<TRes> {
  _CopyWithStubImpl$Input$RerequestCheckSuiteInput(this._res);

  TRes _res;

  call({
    String? checkSuiteId,
    String? clientMutationId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$ResolveReviewThreadInput {
  factory Input$ResolveReviewThreadInput({
    String? clientMutationId,
    required String threadId,
  }) =>
      Input$ResolveReviewThreadInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'threadId': threadId,
      });

  Input$ResolveReviewThreadInput._(this._$data);

  factory Input$ResolveReviewThreadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$threadId = data['threadId'];
    result$data['threadId'] = (l$threadId as String);
    return Input$ResolveReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get threadId => (_$data['threadId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$threadId = threadId;
    result$data['threadId'] = l$threadId;
    return result$data;
  }

  CopyWith$Input$ResolveReviewThreadInput<Input$ResolveReviewThreadInput>
      get copyWith => CopyWith$Input$ResolveReviewThreadInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ResolveReviewThreadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$threadId = threadId;
    final lOther$threadId = other.threadId;
    if (l$threadId != lOther$threadId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$threadId = threadId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$threadId,
    ]);
  }
}

abstract class CopyWith$Input$ResolveReviewThreadInput<TRes> {
  factory CopyWith$Input$ResolveReviewThreadInput(
    Input$ResolveReviewThreadInput instance,
    TRes Function(Input$ResolveReviewThreadInput) then,
  ) = _CopyWithImpl$Input$ResolveReviewThreadInput;

  factory CopyWith$Input$ResolveReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ResolveReviewThreadInput;

  TRes call({
    String? clientMutationId,
    String? threadId,
  });
}

class _CopyWithImpl$Input$ResolveReviewThreadInput<TRes>
    implements CopyWith$Input$ResolveReviewThreadInput<TRes> {
  _CopyWithImpl$Input$ResolveReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$ResolveReviewThreadInput _instance;

  final TRes Function(Input$ResolveReviewThreadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? threadId = _undefined,
  }) =>
      _then(Input$ResolveReviewThreadInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (threadId != _undefined && threadId != null)
          'threadId': (threadId as String),
      }));
}

class _CopyWithStubImpl$Input$ResolveReviewThreadInput<TRes>
    implements CopyWith$Input$ResolveReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$ResolveReviewThreadInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? threadId,
  }) =>
      _res;
}

class Input$RetireSponsorsTierInput {
  factory Input$RetireSponsorsTierInput({
    String? clientMutationId,
    required String tierId,
  }) =>
      Input$RetireSponsorsTierInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'tierId': tierId,
      });

  Input$RetireSponsorsTierInput._(this._$data);

  factory Input$RetireSponsorsTierInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$tierId = data['tierId'];
    result$data['tierId'] = (l$tierId as String);
    return Input$RetireSponsorsTierInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get tierId => (_$data['tierId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$tierId = tierId;
    result$data['tierId'] = l$tierId;
    return result$data;
  }

  CopyWith$Input$RetireSponsorsTierInput<Input$RetireSponsorsTierInput>
      get copyWith => CopyWith$Input$RetireSponsorsTierInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RetireSponsorsTierInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$tierId = tierId;
    final lOther$tierId = other.tierId;
    if (l$tierId != lOther$tierId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$tierId = tierId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$tierId,
    ]);
  }
}

abstract class CopyWith$Input$RetireSponsorsTierInput<TRes> {
  factory CopyWith$Input$RetireSponsorsTierInput(
    Input$RetireSponsorsTierInput instance,
    TRes Function(Input$RetireSponsorsTierInput) then,
  ) = _CopyWithImpl$Input$RetireSponsorsTierInput;

  factory CopyWith$Input$RetireSponsorsTierInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RetireSponsorsTierInput;

  TRes call({
    String? clientMutationId,
    String? tierId,
  });
}

class _CopyWithImpl$Input$RetireSponsorsTierInput<TRes>
    implements CopyWith$Input$RetireSponsorsTierInput<TRes> {
  _CopyWithImpl$Input$RetireSponsorsTierInput(
    this._instance,
    this._then,
  );

  final Input$RetireSponsorsTierInput _instance;

  final TRes Function(Input$RetireSponsorsTierInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? tierId = _undefined,
  }) =>
      _then(Input$RetireSponsorsTierInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (tierId != _undefined && tierId != null)
          'tierId': (tierId as String),
      }));
}

class _CopyWithStubImpl$Input$RetireSponsorsTierInput<TRes>
    implements CopyWith$Input$RetireSponsorsTierInput<TRes> {
  _CopyWithStubImpl$Input$RetireSponsorsTierInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? tierId,
  }) =>
      _res;
}

class Input$RevertPullRequestInput {
  factory Input$RevertPullRequestInput({
    String? body,
    String? clientMutationId,
    bool? draft,
    required String pullRequestId,
    String? title,
  }) =>
      Input$RevertPullRequestInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (draft != null) r'draft': draft,
        r'pullRequestId': pullRequestId,
        if (title != null) r'title': title,
      });

  Input$RevertPullRequestInput._(this._$data);

  factory Input$RevertPullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('draft')) {
      final l$draft = data['draft'];
      result$data['draft'] = (l$draft as bool?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$RevertPullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get draft => (_$data['draft'] as bool?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('draft')) {
      final l$draft = draft;
      result$data['draft'] = l$draft;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$RevertPullRequestInput<Input$RevertPullRequestInput>
      get copyWith => CopyWith$Input$RevertPullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RevertPullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$draft = draft;
    final lOther$draft = other.draft;
    if (_$data.containsKey('draft') != other._$data.containsKey('draft')) {
      return false;
    }
    if (l$draft != lOther$draft) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$draft = draft;
    final l$pullRequestId = pullRequestId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('draft') ? l$draft : const {},
      l$pullRequestId,
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$RevertPullRequestInput<TRes> {
  factory CopyWith$Input$RevertPullRequestInput(
    Input$RevertPullRequestInput instance,
    TRes Function(Input$RevertPullRequestInput) then,
  ) = _CopyWithImpl$Input$RevertPullRequestInput;

  factory CopyWith$Input$RevertPullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RevertPullRequestInput;

  TRes call({
    String? body,
    String? clientMutationId,
    bool? draft,
    String? pullRequestId,
    String? title,
  });
}

class _CopyWithImpl$Input$RevertPullRequestInput<TRes>
    implements CopyWith$Input$RevertPullRequestInput<TRes> {
  _CopyWithImpl$Input$RevertPullRequestInput(
    this._instance,
    this._then,
  );

  final Input$RevertPullRequestInput _instance;

  final TRes Function(Input$RevertPullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? draft = _undefined,
    Object? pullRequestId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$RevertPullRequestInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (draft != _undefined) 'draft': (draft as bool?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$RevertPullRequestInput<TRes>
    implements CopyWith$Input$RevertPullRequestInput<TRes> {
  _CopyWithStubImpl$Input$RevertPullRequestInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    bool? draft,
    String? pullRequestId,
    String? title,
  }) =>
      _res;
}

class Input$RevokeEnterpriseOrganizationsMigratorRoleInput {
  factory Input$RevokeEnterpriseOrganizationsMigratorRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
  }) =>
      Input$RevokeEnterpriseOrganizationsMigratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
      });

  Input$RevokeEnterpriseOrganizationsMigratorRoleInput._(this._$data);

  factory Input$RevokeEnterpriseOrganizationsMigratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    return Input$RevokeEnterpriseOrganizationsMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    return result$data;
  }

  CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
          Input$RevokeEnterpriseOrganizationsMigratorRoleInput>
      get copyWith =>
          CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RevokeEnterpriseOrganizationsMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
    ]);
  }
}

abstract class CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
    TRes> {
  factory CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
    Input$RevokeEnterpriseOrganizationsMigratorRoleInput instance,
    TRes Function(Input$RevokeEnterpriseOrganizationsMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput;

  factory CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  });
}

class _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes>
    implements
        CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$RevokeEnterpriseOrganizationsMigratorRoleInput _instance;

  final TRes Function(Input$RevokeEnterpriseOrganizationsMigratorRoleInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
  }) =>
      _then(Input$RevokeEnterpriseOrganizationsMigratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
      }));
}

class _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<
        TRes>
    implements
        CopyWith$Input$RevokeEnterpriseOrganizationsMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$RevokeEnterpriseOrganizationsMigratorRoleInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
  }) =>
      _res;
}

class Input$RevokeMigratorRoleInput {
  factory Input$RevokeMigratorRoleInput({
    required String actor,
    required Enum$ActorType actorType,
    String? clientMutationId,
    required String organizationId,
  }) =>
      Input$RevokeMigratorRoleInput._({
        r'actor': actor,
        r'actorType': actorType,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
      });

  Input$RevokeMigratorRoleInput._(this._$data);

  factory Input$RevokeMigratorRoleInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$actor = data['actor'];
    result$data['actor'] = (l$actor as String);
    final l$actorType = data['actorType'];
    result$data['actorType'] = fromJson$Enum$ActorType((l$actorType as String));
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$RevokeMigratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get actor => (_$data['actor'] as String);
  Enum$ActorType get actorType => (_$data['actorType'] as Enum$ActorType);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$actor = actor;
    result$data['actor'] = l$actor;
    final l$actorType = actorType;
    result$data['actorType'] = toJson$Enum$ActorType(l$actorType);
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$RevokeMigratorRoleInput<Input$RevokeMigratorRoleInput>
      get copyWith => CopyWith$Input$RevokeMigratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$RevokeMigratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$actor = actor;
    final lOther$actor = other.actor;
    if (l$actor != lOther$actor) {
      return false;
    }
    final l$actorType = actorType;
    final lOther$actorType = other.actorType;
    if (l$actorType != lOther$actorType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$actor = actor;
    final l$actorType = actorType;
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      l$actor,
      l$actorType,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  factory CopyWith$Input$RevokeMigratorRoleInput(
    Input$RevokeMigratorRoleInput instance,
    TRes Function(Input$RevokeMigratorRoleInput) then,
  ) = _CopyWithImpl$Input$RevokeMigratorRoleInput;

  factory CopyWith$Input$RevokeMigratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$RevokeMigratorRoleInput;

  TRes call({
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$RevokeMigratorRoleInput<TRes>
    implements CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  _CopyWithImpl$Input$RevokeMigratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$RevokeMigratorRoleInput _instance;

  final TRes Function(Input$RevokeMigratorRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? actor = _undefined,
    Object? actorType = _undefined,
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$RevokeMigratorRoleInput._({
        ..._instance._$data,
        if (actor != _undefined && actor != null) 'actor': (actor as String),
        if (actorType != _undefined && actorType != null)
          'actorType': (actorType as Enum$ActorType),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$RevokeMigratorRoleInput<TRes>
    implements CopyWith$Input$RevokeMigratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$RevokeMigratorRoleInput(this._res);

  TRes _res;

  call({
    String? actor,
    Enum$ActorType? actorType,
    String? clientMutationId,
    String? organizationId,
  }) =>
      _res;
}

class Input$SavedReplyOrder {
  factory Input$SavedReplyOrder({
    required Enum$OrderDirection direction,
    required Enum$SavedReplyOrderField field,
  }) =>
      Input$SavedReplyOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SavedReplyOrder._(this._$data);

  factory Input$SavedReplyOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SavedReplyOrderField((l$field as String));
    return Input$SavedReplyOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SavedReplyOrderField get field =>
      (_$data['field'] as Enum$SavedReplyOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SavedReplyOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SavedReplyOrder<Input$SavedReplyOrder> get copyWith =>
      CopyWith$Input$SavedReplyOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SavedReplyOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SavedReplyOrder<TRes> {
  factory CopyWith$Input$SavedReplyOrder(
    Input$SavedReplyOrder instance,
    TRes Function(Input$SavedReplyOrder) then,
  ) = _CopyWithImpl$Input$SavedReplyOrder;

  factory CopyWith$Input$SavedReplyOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SavedReplyOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SavedReplyOrderField? field,
  });
}

class _CopyWithImpl$Input$SavedReplyOrder<TRes>
    implements CopyWith$Input$SavedReplyOrder<TRes> {
  _CopyWithImpl$Input$SavedReplyOrder(
    this._instance,
    this._then,
  );

  final Input$SavedReplyOrder _instance;

  final TRes Function(Input$SavedReplyOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SavedReplyOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SavedReplyOrderField),
      }));
}

class _CopyWithStubImpl$Input$SavedReplyOrder<TRes>
    implements CopyWith$Input$SavedReplyOrder<TRes> {
  _CopyWithStubImpl$Input$SavedReplyOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SavedReplyOrderField? field,
  }) =>
      _res;
}

class Input$SecurityAdvisoryIdentifierFilter {
  factory Input$SecurityAdvisoryIdentifierFilter({
    required Enum$SecurityAdvisoryIdentifierType type,
    required String value,
  }) =>
      Input$SecurityAdvisoryIdentifierFilter._({
        r'type': type,
        r'value': value,
      });

  Input$SecurityAdvisoryIdentifierFilter._(this._$data);

  factory Input$SecurityAdvisoryIdentifierFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$type = data['type'];
    result$data['type'] =
        fromJson$Enum$SecurityAdvisoryIdentifierType((l$type as String));
    final l$value = data['value'];
    result$data['value'] = (l$value as String);
    return Input$SecurityAdvisoryIdentifierFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SecurityAdvisoryIdentifierType get type =>
      (_$data['type'] as Enum$SecurityAdvisoryIdentifierType);
  String get value => (_$data['value'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$type = type;
    result$data['type'] = toJson$Enum$SecurityAdvisoryIdentifierType(l$type);
    final l$value = value;
    result$data['value'] = l$value;
    return result$data;
  }

  CopyWith$Input$SecurityAdvisoryIdentifierFilter<
          Input$SecurityAdvisoryIdentifierFilter>
      get copyWith => CopyWith$Input$SecurityAdvisoryIdentifierFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityAdvisoryIdentifierFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type = type;
    final lOther$type = other.type;
    if (l$type != lOther$type) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type = type;
    final l$value = value;
    return Object.hashAll([
      l$type,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  factory CopyWith$Input$SecurityAdvisoryIdentifierFilter(
    Input$SecurityAdvisoryIdentifierFilter instance,
    TRes Function(Input$SecurityAdvisoryIdentifierFilter) then,
  ) = _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter;

  factory CopyWith$Input$SecurityAdvisoryIdentifierFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter;

  TRes call({
    Enum$SecurityAdvisoryIdentifierType? type,
    String? value,
  });
}

class _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter<TRes>
    implements CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  _CopyWithImpl$Input$SecurityAdvisoryIdentifierFilter(
    this._instance,
    this._then,
  );

  final Input$SecurityAdvisoryIdentifierFilter _instance;

  final TRes Function(Input$SecurityAdvisoryIdentifierFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$SecurityAdvisoryIdentifierFilter._({
        ..._instance._$data,
        if (type != _undefined && type != null)
          'type': (type as Enum$SecurityAdvisoryIdentifierType),
        if (value != _undefined && value != null) 'value': (value as String),
      }));
}

class _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter<TRes>
    implements CopyWith$Input$SecurityAdvisoryIdentifierFilter<TRes> {
  _CopyWithStubImpl$Input$SecurityAdvisoryIdentifierFilter(this._res);

  TRes _res;

  call({
    Enum$SecurityAdvisoryIdentifierType? type,
    String? value,
  }) =>
      _res;
}

class Input$SecurityAdvisoryOrder {
  factory Input$SecurityAdvisoryOrder({
    required Enum$OrderDirection direction,
    required Enum$SecurityAdvisoryOrderField field,
  }) =>
      Input$SecurityAdvisoryOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SecurityAdvisoryOrder._(this._$data);

  factory Input$SecurityAdvisoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SecurityAdvisoryOrderField((l$field as String));
    return Input$SecurityAdvisoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SecurityAdvisoryOrderField get field =>
      (_$data['field'] as Enum$SecurityAdvisoryOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SecurityAdvisoryOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SecurityAdvisoryOrder<Input$SecurityAdvisoryOrder>
      get copyWith => CopyWith$Input$SecurityAdvisoryOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityAdvisoryOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  factory CopyWith$Input$SecurityAdvisoryOrder(
    Input$SecurityAdvisoryOrder instance,
    TRes Function(Input$SecurityAdvisoryOrder) then,
  ) = _CopyWithImpl$Input$SecurityAdvisoryOrder;

  factory CopyWith$Input$SecurityAdvisoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityAdvisoryOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SecurityAdvisoryOrderField? field,
  });
}

class _CopyWithImpl$Input$SecurityAdvisoryOrder<TRes>
    implements CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  _CopyWithImpl$Input$SecurityAdvisoryOrder(
    this._instance,
    this._then,
  );

  final Input$SecurityAdvisoryOrder _instance;

  final TRes Function(Input$SecurityAdvisoryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SecurityAdvisoryOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SecurityAdvisoryOrderField),
      }));
}

class _CopyWithStubImpl$Input$SecurityAdvisoryOrder<TRes>
    implements CopyWith$Input$SecurityAdvisoryOrder<TRes> {
  _CopyWithStubImpl$Input$SecurityAdvisoryOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SecurityAdvisoryOrderField? field,
  }) =>
      _res;
}

class Input$SecurityVulnerabilityOrder {
  factory Input$SecurityVulnerabilityOrder({
    required Enum$OrderDirection direction,
    required Enum$SecurityVulnerabilityOrderField field,
  }) =>
      Input$SecurityVulnerabilityOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SecurityVulnerabilityOrder._(this._$data);

  factory Input$SecurityVulnerabilityOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SecurityVulnerabilityOrderField((l$field as String));
    return Input$SecurityVulnerabilityOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SecurityVulnerabilityOrderField get field =>
      (_$data['field'] as Enum$SecurityVulnerabilityOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SecurityVulnerabilityOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SecurityVulnerabilityOrder<Input$SecurityVulnerabilityOrder>
      get copyWith => CopyWith$Input$SecurityVulnerabilityOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SecurityVulnerabilityOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  factory CopyWith$Input$SecurityVulnerabilityOrder(
    Input$SecurityVulnerabilityOrder instance,
    TRes Function(Input$SecurityVulnerabilityOrder) then,
  ) = _CopyWithImpl$Input$SecurityVulnerabilityOrder;

  factory CopyWith$Input$SecurityVulnerabilityOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SecurityVulnerabilityOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SecurityVulnerabilityOrderField? field,
  });
}

class _CopyWithImpl$Input$SecurityVulnerabilityOrder<TRes>
    implements CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  _CopyWithImpl$Input$SecurityVulnerabilityOrder(
    this._instance,
    this._then,
  );

  final Input$SecurityVulnerabilityOrder _instance;

  final TRes Function(Input$SecurityVulnerabilityOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SecurityVulnerabilityOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SecurityVulnerabilityOrderField),
      }));
}

class _CopyWithStubImpl$Input$SecurityVulnerabilityOrder<TRes>
    implements CopyWith$Input$SecurityVulnerabilityOrder<TRes> {
  _CopyWithStubImpl$Input$SecurityVulnerabilityOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SecurityVulnerabilityOrderField? field,
  }) =>
      _res;
}

class Input$SetEnterpriseIdentityProviderInput {
  factory Input$SetEnterpriseIdentityProviderInput({
    String? clientMutationId,
    required Enum$SamlDigestAlgorithm digestMethod,
    required String enterpriseId,
    required String idpCertificate,
    String? issuer,
    required Enum$SamlSignatureAlgorithm signatureMethod,
    required String ssoUrl,
  }) =>
      Input$SetEnterpriseIdentityProviderInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'digestMethod': digestMethod,
        r'enterpriseId': enterpriseId,
        r'idpCertificate': idpCertificate,
        if (issuer != null) r'issuer': issuer,
        r'signatureMethod': signatureMethod,
        r'ssoUrl': ssoUrl,
      });

  Input$SetEnterpriseIdentityProviderInput._(this._$data);

  factory Input$SetEnterpriseIdentityProviderInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$digestMethod = data['digestMethod'];
    result$data['digestMethod'] =
        fromJson$Enum$SamlDigestAlgorithm((l$digestMethod as String));
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$idpCertificate = data['idpCertificate'];
    result$data['idpCertificate'] = (l$idpCertificate as String);
    if (data.containsKey('issuer')) {
      final l$issuer = data['issuer'];
      result$data['issuer'] = (l$issuer as String?);
    }
    final l$signatureMethod = data['signatureMethod'];
    result$data['signatureMethod'] =
        fromJson$Enum$SamlSignatureAlgorithm((l$signatureMethod as String));
    final l$ssoUrl = data['ssoUrl'];
    result$data['ssoUrl'] = (l$ssoUrl as String);
    return Input$SetEnterpriseIdentityProviderInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$SamlDigestAlgorithm get digestMethod =>
      (_$data['digestMethod'] as Enum$SamlDigestAlgorithm);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get idpCertificate => (_$data['idpCertificate'] as String);
  String? get issuer => (_$data['issuer'] as String?);
  Enum$SamlSignatureAlgorithm get signatureMethod =>
      (_$data['signatureMethod'] as Enum$SamlSignatureAlgorithm);
  String get ssoUrl => (_$data['ssoUrl'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$digestMethod = digestMethod;
    result$data['digestMethod'] =
        toJson$Enum$SamlDigestAlgorithm(l$digestMethod);
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$idpCertificate = idpCertificate;
    result$data['idpCertificate'] = l$idpCertificate;
    if (_$data.containsKey('issuer')) {
      final l$issuer = issuer;
      result$data['issuer'] = l$issuer;
    }
    final l$signatureMethod = signatureMethod;
    result$data['signatureMethod'] =
        toJson$Enum$SamlSignatureAlgorithm(l$signatureMethod);
    final l$ssoUrl = ssoUrl;
    result$data['ssoUrl'] = l$ssoUrl;
    return result$data;
  }

  CopyWith$Input$SetEnterpriseIdentityProviderInput<
          Input$SetEnterpriseIdentityProviderInput>
      get copyWith => CopyWith$Input$SetEnterpriseIdentityProviderInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetEnterpriseIdentityProviderInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$digestMethod = digestMethod;
    final lOther$digestMethod = other.digestMethod;
    if (l$digestMethod != lOther$digestMethod) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$idpCertificate = idpCertificate;
    final lOther$idpCertificate = other.idpCertificate;
    if (l$idpCertificate != lOther$idpCertificate) {
      return false;
    }
    final l$issuer = issuer;
    final lOther$issuer = other.issuer;
    if (_$data.containsKey('issuer') != other._$data.containsKey('issuer')) {
      return false;
    }
    if (l$issuer != lOther$issuer) {
      return false;
    }
    final l$signatureMethod = signatureMethod;
    final lOther$signatureMethod = other.signatureMethod;
    if (l$signatureMethod != lOther$signatureMethod) {
      return false;
    }
    final l$ssoUrl = ssoUrl;
    final lOther$ssoUrl = other.ssoUrl;
    if (l$ssoUrl != lOther$ssoUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$digestMethod = digestMethod;
    final l$enterpriseId = enterpriseId;
    final l$idpCertificate = idpCertificate;
    final l$issuer = issuer;
    final l$signatureMethod = signatureMethod;
    final l$ssoUrl = ssoUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$digestMethod,
      l$enterpriseId,
      l$idpCertificate,
      _$data.containsKey('issuer') ? l$issuer : const {},
      l$signatureMethod,
      l$ssoUrl,
    ]);
  }
}

abstract class CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  factory CopyWith$Input$SetEnterpriseIdentityProviderInput(
    Input$SetEnterpriseIdentityProviderInput instance,
    TRes Function(Input$SetEnterpriseIdentityProviderInput) then,
  ) = _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput;

  factory CopyWith$Input$SetEnterpriseIdentityProviderInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput;

  TRes call({
    String? clientMutationId,
    Enum$SamlDigestAlgorithm? digestMethod,
    String? enterpriseId,
    String? idpCertificate,
    String? issuer,
    Enum$SamlSignatureAlgorithm? signatureMethod,
    String? ssoUrl,
  });
}

class _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  _CopyWithImpl$Input$SetEnterpriseIdentityProviderInput(
    this._instance,
    this._then,
  );

  final Input$SetEnterpriseIdentityProviderInput _instance;

  final TRes Function(Input$SetEnterpriseIdentityProviderInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? digestMethod = _undefined,
    Object? enterpriseId = _undefined,
    Object? idpCertificate = _undefined,
    Object? issuer = _undefined,
    Object? signatureMethod = _undefined,
    Object? ssoUrl = _undefined,
  }) =>
      _then(Input$SetEnterpriseIdentityProviderInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (digestMethod != _undefined && digestMethod != null)
          'digestMethod': (digestMethod as Enum$SamlDigestAlgorithm),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (idpCertificate != _undefined && idpCertificate != null)
          'idpCertificate': (idpCertificate as String),
        if (issuer != _undefined) 'issuer': (issuer as String?),
        if (signatureMethod != _undefined && signatureMethod != null)
          'signatureMethod': (signatureMethod as Enum$SamlSignatureAlgorithm),
        if (ssoUrl != _undefined && ssoUrl != null)
          'ssoUrl': (ssoUrl as String),
      }));
}

class _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput<TRes>
    implements CopyWith$Input$SetEnterpriseIdentityProviderInput<TRes> {
  _CopyWithStubImpl$Input$SetEnterpriseIdentityProviderInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$SamlDigestAlgorithm? digestMethod,
    String? enterpriseId,
    String? idpCertificate,
    String? issuer,
    Enum$SamlSignatureAlgorithm? signatureMethod,
    String? ssoUrl,
  }) =>
      _res;
}

class Input$SetOrganizationInteractionLimitInput {
  factory Input$SetOrganizationInteractionLimitInput({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    required Enum$RepositoryInteractionLimit limit,
    required String organizationId,
  }) =>
      Input$SetOrganizationInteractionLimitInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (expiry != null) r'expiry': expiry,
        r'limit': limit,
        r'organizationId': organizationId,
      });

  Input$SetOrganizationInteractionLimitInput._(this._$data);

  factory Input$SetOrganizationInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$SetOrganizationInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);
  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$SetOrganizationInteractionLimitInput<
          Input$SetOrganizationInteractionLimitInput>
      get copyWith => CopyWith$Input$SetOrganizationInteractionLimitInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetOrganizationInteractionLimitInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$expiry = expiry;
    final l$limit = limit;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('expiry') ? l$expiry : const {},
      l$limit,
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetOrganizationInteractionLimitInput(
    Input$SetOrganizationInteractionLimitInput instance,
    TRes Function(Input$SetOrganizationInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetOrganizationInteractionLimitInput;

  factory CopyWith$Input$SetOrganizationInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput;

  TRes call({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    Enum$RepositoryInteractionLimit? limit,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$SetOrganizationInteractionLimitInput<TRes>
    implements CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetOrganizationInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetOrganizationInteractionLimitInput _instance;

  final TRes Function(Input$SetOrganizationInteractionLimitInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? expiry = _undefined,
    Object? limit = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$SetOrganizationInteractionLimitInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput<TRes>
    implements CopyWith$Input$SetOrganizationInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetOrganizationInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    Enum$RepositoryInteractionLimit? limit,
    String? organizationId,
  }) =>
      _res;
}

class Input$SetRepositoryInteractionLimitInput {
  factory Input$SetRepositoryInteractionLimitInput({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    required Enum$RepositoryInteractionLimit limit,
    required String repositoryId,
  }) =>
      Input$SetRepositoryInteractionLimitInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (expiry != null) r'expiry': expiry,
        r'limit': limit,
        r'repositoryId': repositoryId,
      });

  Input$SetRepositoryInteractionLimitInput._(this._$data);

  factory Input$SetRepositoryInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$SetRepositoryInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);
  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$SetRepositoryInteractionLimitInput<
          Input$SetRepositoryInteractionLimitInput>
      get copyWith => CopyWith$Input$SetRepositoryInteractionLimitInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetRepositoryInteractionLimitInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$expiry = expiry;
    final l$limit = limit;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('expiry') ? l$expiry : const {},
      l$limit,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetRepositoryInteractionLimitInput(
    Input$SetRepositoryInteractionLimitInput instance,
    TRes Function(Input$SetRepositoryInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetRepositoryInteractionLimitInput;

  factory CopyWith$Input$SetRepositoryInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput;

  TRes call({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    Enum$RepositoryInteractionLimit? limit,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$SetRepositoryInteractionLimitInput<TRes>
    implements CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetRepositoryInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetRepositoryInteractionLimitInput _instance;

  final TRes Function(Input$SetRepositoryInteractionLimitInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? expiry = _undefined,
    Object? limit = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$SetRepositoryInteractionLimitInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput<TRes>
    implements CopyWith$Input$SetRepositoryInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetRepositoryInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    Enum$RepositoryInteractionLimit? limit,
    String? repositoryId,
  }) =>
      _res;
}

class Input$SetUserInteractionLimitInput {
  factory Input$SetUserInteractionLimitInput({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    required Enum$RepositoryInteractionLimit limit,
    required String userId,
  }) =>
      Input$SetUserInteractionLimitInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (expiry != null) r'expiry': expiry,
        r'limit': limit,
        r'userId': userId,
      });

  Input$SetUserInteractionLimitInput._(this._$data);

  factory Input$SetUserInteractionLimitInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('expiry')) {
      final l$expiry = data['expiry'];
      result$data['expiry'] = l$expiry == null
          ? null
          : fromJson$Enum$RepositoryInteractionLimitExpiry(
              (l$expiry as String));
    }
    final l$limit = data['limit'];
    result$data['limit'] =
        fromJson$Enum$RepositoryInteractionLimit((l$limit as String));
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$SetUserInteractionLimitInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$RepositoryInteractionLimitExpiry? get expiry =>
      (_$data['expiry'] as Enum$RepositoryInteractionLimitExpiry?);
  Enum$RepositoryInteractionLimit get limit =>
      (_$data['limit'] as Enum$RepositoryInteractionLimit);
  String get userId => (_$data['userId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('expiry')) {
      final l$expiry = expiry;
      result$data['expiry'] = l$expiry == null
          ? null
          : toJson$Enum$RepositoryInteractionLimitExpiry(l$expiry);
    }
    final l$limit = limit;
    result$data['limit'] = toJson$Enum$RepositoryInteractionLimit(l$limit);
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$SetUserInteractionLimitInput<
          Input$SetUserInteractionLimitInput>
      get copyWith => CopyWith$Input$SetUserInteractionLimitInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SetUserInteractionLimitInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$expiry = expiry;
    final lOther$expiry = other.expiry;
    if (_$data.containsKey('expiry') != other._$data.containsKey('expiry')) {
      return false;
    }
    if (l$expiry != lOther$expiry) {
      return false;
    }
    final l$limit = limit;
    final lOther$limit = other.limit;
    if (l$limit != lOther$limit) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$expiry = expiry;
    final l$limit = limit;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('expiry') ? l$expiry : const {},
      l$limit,
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  factory CopyWith$Input$SetUserInteractionLimitInput(
    Input$SetUserInteractionLimitInput instance,
    TRes Function(Input$SetUserInteractionLimitInput) then,
  ) = _CopyWithImpl$Input$SetUserInteractionLimitInput;

  factory CopyWith$Input$SetUserInteractionLimitInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SetUserInteractionLimitInput;

  TRes call({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    Enum$RepositoryInteractionLimit? limit,
    String? userId,
  });
}

class _CopyWithImpl$Input$SetUserInteractionLimitInput<TRes>
    implements CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  _CopyWithImpl$Input$SetUserInteractionLimitInput(
    this._instance,
    this._then,
  );

  final Input$SetUserInteractionLimitInput _instance;

  final TRes Function(Input$SetUserInteractionLimitInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? expiry = _undefined,
    Object? limit = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$SetUserInteractionLimitInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (expiry != _undefined)
          'expiry': (expiry as Enum$RepositoryInteractionLimitExpiry?),
        if (limit != _undefined && limit != null)
          'limit': (limit as Enum$RepositoryInteractionLimit),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$SetUserInteractionLimitInput<TRes>
    implements CopyWith$Input$SetUserInteractionLimitInput<TRes> {
  _CopyWithStubImpl$Input$SetUserInteractionLimitInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$RepositoryInteractionLimitExpiry? expiry,
    Enum$RepositoryInteractionLimit? limit,
    String? userId,
  }) =>
      _res;
}

class Input$SponsorOrder {
  factory Input$SponsorOrder({
    required Enum$OrderDirection direction,
    required Enum$SponsorOrderField field,
  }) =>
      Input$SponsorOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SponsorOrder._(this._$data);

  factory Input$SponsorOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$SponsorOrderField((l$field as String));
    return Input$SponsorOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SponsorOrderField get field =>
      (_$data['field'] as Enum$SponsorOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SponsorOrder<Input$SponsorOrder> get copyWith =>
      CopyWith$Input$SponsorOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SponsorOrder<TRes> {
  factory CopyWith$Input$SponsorOrder(
    Input$SponsorOrder instance,
    TRes Function(Input$SponsorOrder) then,
  ) = _CopyWithImpl$Input$SponsorOrder;

  factory CopyWith$Input$SponsorOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SponsorOrderField? field,
  });
}

class _CopyWithImpl$Input$SponsorOrder<TRes>
    implements CopyWith$Input$SponsorOrder<TRes> {
  _CopyWithImpl$Input$SponsorOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorOrder _instance;

  final TRes Function(Input$SponsorOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SponsorOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorOrderField),
      }));
}

class _CopyWithStubImpl$Input$SponsorOrder<TRes>
    implements CopyWith$Input$SponsorOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SponsorOrderField? field,
  }) =>
      _res;
}

class Input$SponsorableOrder {
  factory Input$SponsorableOrder({
    required Enum$OrderDirection direction,
    required Enum$SponsorableOrderField field,
  }) =>
      Input$SponsorableOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SponsorableOrder._(this._$data);

  factory Input$SponsorableOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorableOrderField((l$field as String));
    return Input$SponsorableOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SponsorableOrderField get field =>
      (_$data['field'] as Enum$SponsorableOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorableOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SponsorableOrder<Input$SponsorableOrder> get copyWith =>
      CopyWith$Input$SponsorableOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorableOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SponsorableOrder<TRes> {
  factory CopyWith$Input$SponsorableOrder(
    Input$SponsorableOrder instance,
    TRes Function(Input$SponsorableOrder) then,
  ) = _CopyWithImpl$Input$SponsorableOrder;

  factory CopyWith$Input$SponsorableOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorableOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SponsorableOrderField? field,
  });
}

class _CopyWithImpl$Input$SponsorableOrder<TRes>
    implements CopyWith$Input$SponsorableOrder<TRes> {
  _CopyWithImpl$Input$SponsorableOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorableOrder _instance;

  final TRes Function(Input$SponsorableOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SponsorableOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorableOrderField),
      }));
}

class _CopyWithStubImpl$Input$SponsorableOrder<TRes>
    implements CopyWith$Input$SponsorableOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorableOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SponsorableOrderField? field,
  }) =>
      _res;
}

class Input$SponsorsActivityOrder {
  factory Input$SponsorsActivityOrder({
    required Enum$OrderDirection direction,
    required Enum$SponsorsActivityOrderField field,
  }) =>
      Input$SponsorsActivityOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SponsorsActivityOrder._(this._$data);

  factory Input$SponsorsActivityOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorsActivityOrderField((l$field as String));
    return Input$SponsorsActivityOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SponsorsActivityOrderField get field =>
      (_$data['field'] as Enum$SponsorsActivityOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorsActivityOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SponsorsActivityOrder<Input$SponsorsActivityOrder>
      get copyWith => CopyWith$Input$SponsorsActivityOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorsActivityOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SponsorsActivityOrder<TRes> {
  factory CopyWith$Input$SponsorsActivityOrder(
    Input$SponsorsActivityOrder instance,
    TRes Function(Input$SponsorsActivityOrder) then,
  ) = _CopyWithImpl$Input$SponsorsActivityOrder;

  factory CopyWith$Input$SponsorsActivityOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorsActivityOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SponsorsActivityOrderField? field,
  });
}

class _CopyWithImpl$Input$SponsorsActivityOrder<TRes>
    implements CopyWith$Input$SponsorsActivityOrder<TRes> {
  _CopyWithImpl$Input$SponsorsActivityOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorsActivityOrder _instance;

  final TRes Function(Input$SponsorsActivityOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SponsorsActivityOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorsActivityOrderField),
      }));
}

class _CopyWithStubImpl$Input$SponsorsActivityOrder<TRes>
    implements CopyWith$Input$SponsorsActivityOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorsActivityOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SponsorsActivityOrderField? field,
  }) =>
      _res;
}

class Input$SponsorsTierOrder {
  factory Input$SponsorsTierOrder({
    required Enum$OrderDirection direction,
    required Enum$SponsorsTierOrderField field,
  }) =>
      Input$SponsorsTierOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SponsorsTierOrder._(this._$data);

  factory Input$SponsorsTierOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorsTierOrderField((l$field as String));
    return Input$SponsorsTierOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SponsorsTierOrderField get field =>
      (_$data['field'] as Enum$SponsorsTierOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorsTierOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SponsorsTierOrder<Input$SponsorsTierOrder> get copyWith =>
      CopyWith$Input$SponsorsTierOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorsTierOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SponsorsTierOrder<TRes> {
  factory CopyWith$Input$SponsorsTierOrder(
    Input$SponsorsTierOrder instance,
    TRes Function(Input$SponsorsTierOrder) then,
  ) = _CopyWithImpl$Input$SponsorsTierOrder;

  factory CopyWith$Input$SponsorsTierOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorsTierOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SponsorsTierOrderField? field,
  });
}

class _CopyWithImpl$Input$SponsorsTierOrder<TRes>
    implements CopyWith$Input$SponsorsTierOrder<TRes> {
  _CopyWithImpl$Input$SponsorsTierOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorsTierOrder _instance;

  final TRes Function(Input$SponsorsTierOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SponsorsTierOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorsTierOrderField),
      }));
}

class _CopyWithStubImpl$Input$SponsorsTierOrder<TRes>
    implements CopyWith$Input$SponsorsTierOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorsTierOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SponsorsTierOrderField? field,
  }) =>
      _res;
}

class Input$SponsorshipNewsletterOrder {
  factory Input$SponsorshipNewsletterOrder({
    required Enum$OrderDirection direction,
    required Enum$SponsorshipNewsletterOrderField field,
  }) =>
      Input$SponsorshipNewsletterOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SponsorshipNewsletterOrder._(this._$data);

  factory Input$SponsorshipNewsletterOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorshipNewsletterOrderField((l$field as String));
    return Input$SponsorshipNewsletterOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SponsorshipNewsletterOrderField get field =>
      (_$data['field'] as Enum$SponsorshipNewsletterOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorshipNewsletterOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SponsorshipNewsletterOrder<Input$SponsorshipNewsletterOrder>
      get copyWith => CopyWith$Input$SponsorshipNewsletterOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorshipNewsletterOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  factory CopyWith$Input$SponsorshipNewsletterOrder(
    Input$SponsorshipNewsletterOrder instance,
    TRes Function(Input$SponsorshipNewsletterOrder) then,
  ) = _CopyWithImpl$Input$SponsorshipNewsletterOrder;

  factory CopyWith$Input$SponsorshipNewsletterOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorshipNewsletterOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SponsorshipNewsletterOrderField? field,
  });
}

class _CopyWithImpl$Input$SponsorshipNewsletterOrder<TRes>
    implements CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  _CopyWithImpl$Input$SponsorshipNewsletterOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorshipNewsletterOrder _instance;

  final TRes Function(Input$SponsorshipNewsletterOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SponsorshipNewsletterOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorshipNewsletterOrderField),
      }));
}

class _CopyWithStubImpl$Input$SponsorshipNewsletterOrder<TRes>
    implements CopyWith$Input$SponsorshipNewsletterOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorshipNewsletterOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SponsorshipNewsletterOrderField? field,
  }) =>
      _res;
}

class Input$SponsorshipOrder {
  factory Input$SponsorshipOrder({
    required Enum$OrderDirection direction,
    required Enum$SponsorshipOrderField field,
  }) =>
      Input$SponsorshipOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$SponsorshipOrder._(this._$data);

  factory Input$SponsorshipOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$SponsorshipOrderField((l$field as String));
    return Input$SponsorshipOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$SponsorshipOrderField get field =>
      (_$data['field'] as Enum$SponsorshipOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$SponsorshipOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$SponsorshipOrder<Input$SponsorshipOrder> get copyWith =>
      CopyWith$Input$SponsorshipOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SponsorshipOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$SponsorshipOrder<TRes> {
  factory CopyWith$Input$SponsorshipOrder(
    Input$SponsorshipOrder instance,
    TRes Function(Input$SponsorshipOrder) then,
  ) = _CopyWithImpl$Input$SponsorshipOrder;

  factory CopyWith$Input$SponsorshipOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$SponsorshipOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$SponsorshipOrderField? field,
  });
}

class _CopyWithImpl$Input$SponsorshipOrder<TRes>
    implements CopyWith$Input$SponsorshipOrder<TRes> {
  _CopyWithImpl$Input$SponsorshipOrder(
    this._instance,
    this._then,
  );

  final Input$SponsorshipOrder _instance;

  final TRes Function(Input$SponsorshipOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$SponsorshipOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$SponsorshipOrderField),
      }));
}

class _CopyWithStubImpl$Input$SponsorshipOrder<TRes>
    implements CopyWith$Input$SponsorshipOrder<TRes> {
  _CopyWithStubImpl$Input$SponsorshipOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$SponsorshipOrderField? field,
  }) =>
      _res;
}

class Input$StarOrder {
  factory Input$StarOrder({
    required Enum$OrderDirection direction,
    required Enum$StarOrderField field,
  }) =>
      Input$StarOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$StarOrder._(this._$data);

  factory Input$StarOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$StarOrderField((l$field as String));
    return Input$StarOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$StarOrderField get field => (_$data['field'] as Enum$StarOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$StarOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$StarOrder<Input$StarOrder> get copyWith =>
      CopyWith$Input$StarOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StarOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$StarOrder<TRes> {
  factory CopyWith$Input$StarOrder(
    Input$StarOrder instance,
    TRes Function(Input$StarOrder) then,
  ) = _CopyWithImpl$Input$StarOrder;

  factory CopyWith$Input$StarOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$StarOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$StarOrderField? field,
  });
}

class _CopyWithImpl$Input$StarOrder<TRes>
    implements CopyWith$Input$StarOrder<TRes> {
  _CopyWithImpl$Input$StarOrder(
    this._instance,
    this._then,
  );

  final Input$StarOrder _instance;

  final TRes Function(Input$StarOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$StarOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$StarOrderField),
      }));
}

class _CopyWithStubImpl$Input$StarOrder<TRes>
    implements CopyWith$Input$StarOrder<TRes> {
  _CopyWithStubImpl$Input$StarOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$StarOrderField? field,
  }) =>
      _res;
}

class Input$StartOrganizationMigrationInput {
  factory Input$StartOrganizationMigrationInput({
    String? clientMutationId,
    required String sourceAccessToken,
    required String sourceOrgUrl,
    required String targetEnterpriseId,
    required String targetOrgName,
  }) =>
      Input$StartOrganizationMigrationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'sourceAccessToken': sourceAccessToken,
        r'sourceOrgUrl': sourceOrgUrl,
        r'targetEnterpriseId': targetEnterpriseId,
        r'targetOrgName': targetOrgName,
      });

  Input$StartOrganizationMigrationInput._(this._$data);

  factory Input$StartOrganizationMigrationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$sourceAccessToken = data['sourceAccessToken'];
    result$data['sourceAccessToken'] = (l$sourceAccessToken as String);
    final l$sourceOrgUrl = data['sourceOrgUrl'];
    result$data['sourceOrgUrl'] = (l$sourceOrgUrl as String);
    final l$targetEnterpriseId = data['targetEnterpriseId'];
    result$data['targetEnterpriseId'] = (l$targetEnterpriseId as String);
    final l$targetOrgName = data['targetOrgName'];
    result$data['targetOrgName'] = (l$targetOrgName as String);
    return Input$StartOrganizationMigrationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get sourceAccessToken => (_$data['sourceAccessToken'] as String);
  String get sourceOrgUrl => (_$data['sourceOrgUrl'] as String);
  String get targetEnterpriseId => (_$data['targetEnterpriseId'] as String);
  String get targetOrgName => (_$data['targetOrgName'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$sourceAccessToken = sourceAccessToken;
    result$data['sourceAccessToken'] = l$sourceAccessToken;
    final l$sourceOrgUrl = sourceOrgUrl;
    result$data['sourceOrgUrl'] = l$sourceOrgUrl;
    final l$targetEnterpriseId = targetEnterpriseId;
    result$data['targetEnterpriseId'] = l$targetEnterpriseId;
    final l$targetOrgName = targetOrgName;
    result$data['targetOrgName'] = l$targetOrgName;
    return result$data;
  }

  CopyWith$Input$StartOrganizationMigrationInput<
          Input$StartOrganizationMigrationInput>
      get copyWith => CopyWith$Input$StartOrganizationMigrationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StartOrganizationMigrationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$sourceAccessToken = sourceAccessToken;
    final lOther$sourceAccessToken = other.sourceAccessToken;
    if (l$sourceAccessToken != lOther$sourceAccessToken) {
      return false;
    }
    final l$sourceOrgUrl = sourceOrgUrl;
    final lOther$sourceOrgUrl = other.sourceOrgUrl;
    if (l$sourceOrgUrl != lOther$sourceOrgUrl) {
      return false;
    }
    final l$targetEnterpriseId = targetEnterpriseId;
    final lOther$targetEnterpriseId = other.targetEnterpriseId;
    if (l$targetEnterpriseId != lOther$targetEnterpriseId) {
      return false;
    }
    final l$targetOrgName = targetOrgName;
    final lOther$targetOrgName = other.targetOrgName;
    if (l$targetOrgName != lOther$targetOrgName) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$sourceAccessToken = sourceAccessToken;
    final l$sourceOrgUrl = sourceOrgUrl;
    final l$targetEnterpriseId = targetEnterpriseId;
    final l$targetOrgName = targetOrgName;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$sourceAccessToken,
      l$sourceOrgUrl,
      l$targetEnterpriseId,
      l$targetOrgName,
    ]);
  }
}

abstract class CopyWith$Input$StartOrganizationMigrationInput<TRes> {
  factory CopyWith$Input$StartOrganizationMigrationInput(
    Input$StartOrganizationMigrationInput instance,
    TRes Function(Input$StartOrganizationMigrationInput) then,
  ) = _CopyWithImpl$Input$StartOrganizationMigrationInput;

  factory CopyWith$Input$StartOrganizationMigrationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StartOrganizationMigrationInput;

  TRes call({
    String? clientMutationId,
    String? sourceAccessToken,
    String? sourceOrgUrl,
    String? targetEnterpriseId,
    String? targetOrgName,
  });
}

class _CopyWithImpl$Input$StartOrganizationMigrationInput<TRes>
    implements CopyWith$Input$StartOrganizationMigrationInput<TRes> {
  _CopyWithImpl$Input$StartOrganizationMigrationInput(
    this._instance,
    this._then,
  );

  final Input$StartOrganizationMigrationInput _instance;

  final TRes Function(Input$StartOrganizationMigrationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? sourceAccessToken = _undefined,
    Object? sourceOrgUrl = _undefined,
    Object? targetEnterpriseId = _undefined,
    Object? targetOrgName = _undefined,
  }) =>
      _then(Input$StartOrganizationMigrationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (sourceAccessToken != _undefined && sourceAccessToken != null)
          'sourceAccessToken': (sourceAccessToken as String),
        if (sourceOrgUrl != _undefined && sourceOrgUrl != null)
          'sourceOrgUrl': (sourceOrgUrl as String),
        if (targetEnterpriseId != _undefined && targetEnterpriseId != null)
          'targetEnterpriseId': (targetEnterpriseId as String),
        if (targetOrgName != _undefined && targetOrgName != null)
          'targetOrgName': (targetOrgName as String),
      }));
}

class _CopyWithStubImpl$Input$StartOrganizationMigrationInput<TRes>
    implements CopyWith$Input$StartOrganizationMigrationInput<TRes> {
  _CopyWithStubImpl$Input$StartOrganizationMigrationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? sourceAccessToken,
    String? sourceOrgUrl,
    String? targetEnterpriseId,
    String? targetOrgName,
  }) =>
      _res;
}

class Input$StartRepositoryMigrationInput {
  factory Input$StartRepositoryMigrationInput({
    String? accessToken,
    String? clientMutationId,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? githubPat,
    bool? lockSource,
    String? metadataArchiveUrl,
    required String ownerId,
    required String repositoryName,
    bool? skipReleases,
    required String sourceId,
    String? sourceRepositoryUrl,
    String? targetRepoVisibility,
  }) =>
      Input$StartRepositoryMigrationInput._({
        if (accessToken != null) r'accessToken': accessToken,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (continueOnError != null) r'continueOnError': continueOnError,
        if (gitArchiveUrl != null) r'gitArchiveUrl': gitArchiveUrl,
        if (githubPat != null) r'githubPat': githubPat,
        if (lockSource != null) r'lockSource': lockSource,
        if (metadataArchiveUrl != null)
          r'metadataArchiveUrl': metadataArchiveUrl,
        r'ownerId': ownerId,
        r'repositoryName': repositoryName,
        if (skipReleases != null) r'skipReleases': skipReleases,
        r'sourceId': sourceId,
        if (sourceRepositoryUrl != null)
          r'sourceRepositoryUrl': sourceRepositoryUrl,
        if (targetRepoVisibility != null)
          r'targetRepoVisibility': targetRepoVisibility,
      });

  Input$StartRepositoryMigrationInput._(this._$data);

  factory Input$StartRepositoryMigrationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('accessToken')) {
      final l$accessToken = data['accessToken'];
      result$data['accessToken'] = (l$accessToken as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('continueOnError')) {
      final l$continueOnError = data['continueOnError'];
      result$data['continueOnError'] = (l$continueOnError as bool?);
    }
    if (data.containsKey('gitArchiveUrl')) {
      final l$gitArchiveUrl = data['gitArchiveUrl'];
      result$data['gitArchiveUrl'] = (l$gitArchiveUrl as String?);
    }
    if (data.containsKey('githubPat')) {
      final l$githubPat = data['githubPat'];
      result$data['githubPat'] = (l$githubPat as String?);
    }
    if (data.containsKey('lockSource')) {
      final l$lockSource = data['lockSource'];
      result$data['lockSource'] = (l$lockSource as bool?);
    }
    if (data.containsKey('metadataArchiveUrl')) {
      final l$metadataArchiveUrl = data['metadataArchiveUrl'];
      result$data['metadataArchiveUrl'] = (l$metadataArchiveUrl as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$repositoryName = data['repositoryName'];
    result$data['repositoryName'] = (l$repositoryName as String);
    if (data.containsKey('skipReleases')) {
      final l$skipReleases = data['skipReleases'];
      result$data['skipReleases'] = (l$skipReleases as bool?);
    }
    final l$sourceId = data['sourceId'];
    result$data['sourceId'] = (l$sourceId as String);
    if (data.containsKey('sourceRepositoryUrl')) {
      final l$sourceRepositoryUrl = data['sourceRepositoryUrl'];
      result$data['sourceRepositoryUrl'] = (l$sourceRepositoryUrl as String?);
    }
    if (data.containsKey('targetRepoVisibility')) {
      final l$targetRepoVisibility = data['targetRepoVisibility'];
      result$data['targetRepoVisibility'] = (l$targetRepoVisibility as String?);
    }
    return Input$StartRepositoryMigrationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get accessToken => (_$data['accessToken'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get continueOnError => (_$data['continueOnError'] as bool?);
  String? get gitArchiveUrl => (_$data['gitArchiveUrl'] as String?);
  String? get githubPat => (_$data['githubPat'] as String?);
  bool? get lockSource => (_$data['lockSource'] as bool?);
  String? get metadataArchiveUrl => (_$data['metadataArchiveUrl'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  String get repositoryName => (_$data['repositoryName'] as String);
  bool? get skipReleases => (_$data['skipReleases'] as bool?);
  String get sourceId => (_$data['sourceId'] as String);
  String? get sourceRepositoryUrl => (_$data['sourceRepositoryUrl'] as String?);
  String? get targetRepoVisibility =>
      (_$data['targetRepoVisibility'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('accessToken')) {
      final l$accessToken = accessToken;
      result$data['accessToken'] = l$accessToken;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('continueOnError')) {
      final l$continueOnError = continueOnError;
      result$data['continueOnError'] = l$continueOnError;
    }
    if (_$data.containsKey('gitArchiveUrl')) {
      final l$gitArchiveUrl = gitArchiveUrl;
      result$data['gitArchiveUrl'] = l$gitArchiveUrl;
    }
    if (_$data.containsKey('githubPat')) {
      final l$githubPat = githubPat;
      result$data['githubPat'] = l$githubPat;
    }
    if (_$data.containsKey('lockSource')) {
      final l$lockSource = lockSource;
      result$data['lockSource'] = l$lockSource;
    }
    if (_$data.containsKey('metadataArchiveUrl')) {
      final l$metadataArchiveUrl = metadataArchiveUrl;
      result$data['metadataArchiveUrl'] = l$metadataArchiveUrl;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$repositoryName = repositoryName;
    result$data['repositoryName'] = l$repositoryName;
    if (_$data.containsKey('skipReleases')) {
      final l$skipReleases = skipReleases;
      result$data['skipReleases'] = l$skipReleases;
    }
    final l$sourceId = sourceId;
    result$data['sourceId'] = l$sourceId;
    if (_$data.containsKey('sourceRepositoryUrl')) {
      final l$sourceRepositoryUrl = sourceRepositoryUrl;
      result$data['sourceRepositoryUrl'] = l$sourceRepositoryUrl;
    }
    if (_$data.containsKey('targetRepoVisibility')) {
      final l$targetRepoVisibility = targetRepoVisibility;
      result$data['targetRepoVisibility'] = l$targetRepoVisibility;
    }
    return result$data;
  }

  CopyWith$Input$StartRepositoryMigrationInput<
          Input$StartRepositoryMigrationInput>
      get copyWith => CopyWith$Input$StartRepositoryMigrationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StartRepositoryMigrationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$accessToken = accessToken;
    final lOther$accessToken = other.accessToken;
    if (_$data.containsKey('accessToken') !=
        other._$data.containsKey('accessToken')) {
      return false;
    }
    if (l$accessToken != lOther$accessToken) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$continueOnError = continueOnError;
    final lOther$continueOnError = other.continueOnError;
    if (_$data.containsKey('continueOnError') !=
        other._$data.containsKey('continueOnError')) {
      return false;
    }
    if (l$continueOnError != lOther$continueOnError) {
      return false;
    }
    final l$gitArchiveUrl = gitArchiveUrl;
    final lOther$gitArchiveUrl = other.gitArchiveUrl;
    if (_$data.containsKey('gitArchiveUrl') !=
        other._$data.containsKey('gitArchiveUrl')) {
      return false;
    }
    if (l$gitArchiveUrl != lOther$gitArchiveUrl) {
      return false;
    }
    final l$githubPat = githubPat;
    final lOther$githubPat = other.githubPat;
    if (_$data.containsKey('githubPat') !=
        other._$data.containsKey('githubPat')) {
      return false;
    }
    if (l$githubPat != lOther$githubPat) {
      return false;
    }
    final l$lockSource = lockSource;
    final lOther$lockSource = other.lockSource;
    if (_$data.containsKey('lockSource') !=
        other._$data.containsKey('lockSource')) {
      return false;
    }
    if (l$lockSource != lOther$lockSource) {
      return false;
    }
    final l$metadataArchiveUrl = metadataArchiveUrl;
    final lOther$metadataArchiveUrl = other.metadataArchiveUrl;
    if (_$data.containsKey('metadataArchiveUrl') !=
        other._$data.containsKey('metadataArchiveUrl')) {
      return false;
    }
    if (l$metadataArchiveUrl != lOther$metadataArchiveUrl) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$repositoryName = repositoryName;
    final lOther$repositoryName = other.repositoryName;
    if (l$repositoryName != lOther$repositoryName) {
      return false;
    }
    final l$skipReleases = skipReleases;
    final lOther$skipReleases = other.skipReleases;
    if (_$data.containsKey('skipReleases') !=
        other._$data.containsKey('skipReleases')) {
      return false;
    }
    if (l$skipReleases != lOther$skipReleases) {
      return false;
    }
    final l$sourceId = sourceId;
    final lOther$sourceId = other.sourceId;
    if (l$sourceId != lOther$sourceId) {
      return false;
    }
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    final lOther$sourceRepositoryUrl = other.sourceRepositoryUrl;
    if (_$data.containsKey('sourceRepositoryUrl') !=
        other._$data.containsKey('sourceRepositoryUrl')) {
      return false;
    }
    if (l$sourceRepositoryUrl != lOther$sourceRepositoryUrl) {
      return false;
    }
    final l$targetRepoVisibility = targetRepoVisibility;
    final lOther$targetRepoVisibility = other.targetRepoVisibility;
    if (_$data.containsKey('targetRepoVisibility') !=
        other._$data.containsKey('targetRepoVisibility')) {
      return false;
    }
    if (l$targetRepoVisibility != lOther$targetRepoVisibility) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$accessToken = accessToken;
    final l$clientMutationId = clientMutationId;
    final l$continueOnError = continueOnError;
    final l$gitArchiveUrl = gitArchiveUrl;
    final l$githubPat = githubPat;
    final l$lockSource = lockSource;
    final l$metadataArchiveUrl = metadataArchiveUrl;
    final l$ownerId = ownerId;
    final l$repositoryName = repositoryName;
    final l$skipReleases = skipReleases;
    final l$sourceId = sourceId;
    final l$sourceRepositoryUrl = sourceRepositoryUrl;
    final l$targetRepoVisibility = targetRepoVisibility;
    return Object.hashAll([
      _$data.containsKey('accessToken') ? l$accessToken : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('continueOnError') ? l$continueOnError : const {},
      _$data.containsKey('gitArchiveUrl') ? l$gitArchiveUrl : const {},
      _$data.containsKey('githubPat') ? l$githubPat : const {},
      _$data.containsKey('lockSource') ? l$lockSource : const {},
      _$data.containsKey('metadataArchiveUrl')
          ? l$metadataArchiveUrl
          : const {},
      l$ownerId,
      l$repositoryName,
      _$data.containsKey('skipReleases') ? l$skipReleases : const {},
      l$sourceId,
      _$data.containsKey('sourceRepositoryUrl')
          ? l$sourceRepositoryUrl
          : const {},
      _$data.containsKey('targetRepoVisibility')
          ? l$targetRepoVisibility
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  factory CopyWith$Input$StartRepositoryMigrationInput(
    Input$StartRepositoryMigrationInput instance,
    TRes Function(Input$StartRepositoryMigrationInput) then,
  ) = _CopyWithImpl$Input$StartRepositoryMigrationInput;

  factory CopyWith$Input$StartRepositoryMigrationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StartRepositoryMigrationInput;

  TRes call({
    String? accessToken,
    String? clientMutationId,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? githubPat,
    bool? lockSource,
    String? metadataArchiveUrl,
    String? ownerId,
    String? repositoryName,
    bool? skipReleases,
    String? sourceId,
    String? sourceRepositoryUrl,
    String? targetRepoVisibility,
  });
}

class _CopyWithImpl$Input$StartRepositoryMigrationInput<TRes>
    implements CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  _CopyWithImpl$Input$StartRepositoryMigrationInput(
    this._instance,
    this._then,
  );

  final Input$StartRepositoryMigrationInput _instance;

  final TRes Function(Input$StartRepositoryMigrationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? accessToken = _undefined,
    Object? clientMutationId = _undefined,
    Object? continueOnError = _undefined,
    Object? gitArchiveUrl = _undefined,
    Object? githubPat = _undefined,
    Object? lockSource = _undefined,
    Object? metadataArchiveUrl = _undefined,
    Object? ownerId = _undefined,
    Object? repositoryName = _undefined,
    Object? skipReleases = _undefined,
    Object? sourceId = _undefined,
    Object? sourceRepositoryUrl = _undefined,
    Object? targetRepoVisibility = _undefined,
  }) =>
      _then(Input$StartRepositoryMigrationInput._({
        ..._instance._$data,
        if (accessToken != _undefined) 'accessToken': (accessToken as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (continueOnError != _undefined)
          'continueOnError': (continueOnError as bool?),
        if (gitArchiveUrl != _undefined)
          'gitArchiveUrl': (gitArchiveUrl as String?),
        if (githubPat != _undefined) 'githubPat': (githubPat as String?),
        if (lockSource != _undefined) 'lockSource': (lockSource as bool?),
        if (metadataArchiveUrl != _undefined)
          'metadataArchiveUrl': (metadataArchiveUrl as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (repositoryName != _undefined && repositoryName != null)
          'repositoryName': (repositoryName as String),
        if (skipReleases != _undefined) 'skipReleases': (skipReleases as bool?),
        if (sourceId != _undefined && sourceId != null)
          'sourceId': (sourceId as String),
        if (sourceRepositoryUrl != _undefined)
          'sourceRepositoryUrl': (sourceRepositoryUrl as String?),
        if (targetRepoVisibility != _undefined)
          'targetRepoVisibility': (targetRepoVisibility as String?),
      }));
}

class _CopyWithStubImpl$Input$StartRepositoryMigrationInput<TRes>
    implements CopyWith$Input$StartRepositoryMigrationInput<TRes> {
  _CopyWithStubImpl$Input$StartRepositoryMigrationInput(this._res);

  TRes _res;

  call({
    String? accessToken,
    String? clientMutationId,
    bool? continueOnError,
    String? gitArchiveUrl,
    String? githubPat,
    bool? lockSource,
    String? metadataArchiveUrl,
    String? ownerId,
    String? repositoryName,
    bool? skipReleases,
    String? sourceId,
    String? sourceRepositoryUrl,
    String? targetRepoVisibility,
  }) =>
      _res;
}

class Input$SubmitPullRequestReviewInput {
  factory Input$SubmitPullRequestReviewInput({
    String? body,
    String? clientMutationId,
    required Enum$PullRequestReviewEvent event,
    String? pullRequestId,
    String? pullRequestReviewId,
  }) =>
      Input$SubmitPullRequestReviewInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'event': event,
        if (pullRequestId != null) r'pullRequestId': pullRequestId,
        if (pullRequestReviewId != null)
          r'pullRequestReviewId': pullRequestReviewId,
      });

  Input$SubmitPullRequestReviewInput._(this._$data);

  factory Input$SubmitPullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$event = data['event'];
    result$data['event'] =
        fromJson$Enum$PullRequestReviewEvent((l$event as String));
    if (data.containsKey('pullRequestId')) {
      final l$pullRequestId = data['pullRequestId'];
      result$data['pullRequestId'] = (l$pullRequestId as String?);
    }
    if (data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = data['pullRequestReviewId'];
      result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String?);
    }
    return Input$SubmitPullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$PullRequestReviewEvent get event =>
      (_$data['event'] as Enum$PullRequestReviewEvent);
  String? get pullRequestId => (_$data['pullRequestId'] as String?);
  String? get pullRequestReviewId => (_$data['pullRequestReviewId'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$event = event;
    result$data['event'] = toJson$Enum$PullRequestReviewEvent(l$event);
    if (_$data.containsKey('pullRequestId')) {
      final l$pullRequestId = pullRequestId;
      result$data['pullRequestId'] = l$pullRequestId;
    }
    if (_$data.containsKey('pullRequestReviewId')) {
      final l$pullRequestReviewId = pullRequestReviewId;
      result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    }
    return result$data;
  }

  CopyWith$Input$SubmitPullRequestReviewInput<
          Input$SubmitPullRequestReviewInput>
      get copyWith => CopyWith$Input$SubmitPullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SubmitPullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$event = event;
    final lOther$event = other.event;
    if (l$event != lOther$event) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (_$data.containsKey('pullRequestId') !=
        other._$data.containsKey('pullRequestId')) {
      return false;
    }
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (_$data.containsKey('pullRequestReviewId') !=
        other._$data.containsKey('pullRequestReviewId')) {
      return false;
    }
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$event = event;
    final l$pullRequestId = pullRequestId;
    final l$pullRequestReviewId = pullRequestReviewId;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$event,
      _$data.containsKey('pullRequestId') ? l$pullRequestId : const {},
      _$data.containsKey('pullRequestReviewId')
          ? l$pullRequestReviewId
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  factory CopyWith$Input$SubmitPullRequestReviewInput(
    Input$SubmitPullRequestReviewInput instance,
    TRes Function(Input$SubmitPullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$SubmitPullRequestReviewInput;

  factory CopyWith$Input$SubmitPullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SubmitPullRequestReviewInput;

  TRes call({
    String? body,
    String? clientMutationId,
    Enum$PullRequestReviewEvent? event,
    String? pullRequestId,
    String? pullRequestReviewId,
  });
}

class _CopyWithImpl$Input$SubmitPullRequestReviewInput<TRes>
    implements CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$SubmitPullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$SubmitPullRequestReviewInput _instance;

  final TRes Function(Input$SubmitPullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? event = _undefined,
    Object? pullRequestId = _undefined,
    Object? pullRequestReviewId = _undefined,
  }) =>
      _then(Input$SubmitPullRequestReviewInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (event != _undefined && event != null)
          'event': (event as Enum$PullRequestReviewEvent),
        if (pullRequestId != _undefined)
          'pullRequestId': (pullRequestId as String?),
        if (pullRequestReviewId != _undefined)
          'pullRequestReviewId': (pullRequestReviewId as String?),
      }));
}

class _CopyWithStubImpl$Input$SubmitPullRequestReviewInput<TRes>
    implements CopyWith$Input$SubmitPullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$SubmitPullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    Enum$PullRequestReviewEvent? event,
    String? pullRequestId,
    String? pullRequestReviewId,
  }) =>
      _res;
}

class Input$TeamDiscussionCommentOrder {
  factory Input$TeamDiscussionCommentOrder({
    required Enum$OrderDirection direction,
    required Enum$TeamDiscussionCommentOrderField field,
  }) =>
      Input$TeamDiscussionCommentOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$TeamDiscussionCommentOrder._(this._$data);

  factory Input$TeamDiscussionCommentOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamDiscussionCommentOrderField((l$field as String));
    return Input$TeamDiscussionCommentOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$TeamDiscussionCommentOrderField get field =>
      (_$data['field'] as Enum$TeamDiscussionCommentOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamDiscussionCommentOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$TeamDiscussionCommentOrder<Input$TeamDiscussionCommentOrder>
      get copyWith => CopyWith$Input$TeamDiscussionCommentOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamDiscussionCommentOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  factory CopyWith$Input$TeamDiscussionCommentOrder(
    Input$TeamDiscussionCommentOrder instance,
    TRes Function(Input$TeamDiscussionCommentOrder) then,
  ) = _CopyWithImpl$Input$TeamDiscussionCommentOrder;

  factory CopyWith$Input$TeamDiscussionCommentOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamDiscussionCommentOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$TeamDiscussionCommentOrderField? field,
  });
}

class _CopyWithImpl$Input$TeamDiscussionCommentOrder<TRes>
    implements CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  _CopyWithImpl$Input$TeamDiscussionCommentOrder(
    this._instance,
    this._then,
  );

  final Input$TeamDiscussionCommentOrder _instance;

  final TRes Function(Input$TeamDiscussionCommentOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$TeamDiscussionCommentOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamDiscussionCommentOrderField),
      }));
}

class _CopyWithStubImpl$Input$TeamDiscussionCommentOrder<TRes>
    implements CopyWith$Input$TeamDiscussionCommentOrder<TRes> {
  _CopyWithStubImpl$Input$TeamDiscussionCommentOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$TeamDiscussionCommentOrderField? field,
  }) =>
      _res;
}

class Input$TeamDiscussionOrder {
  factory Input$TeamDiscussionOrder({
    required Enum$OrderDirection direction,
    required Enum$TeamDiscussionOrderField field,
  }) =>
      Input$TeamDiscussionOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$TeamDiscussionOrder._(this._$data);

  factory Input$TeamDiscussionOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamDiscussionOrderField((l$field as String));
    return Input$TeamDiscussionOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$TeamDiscussionOrderField get field =>
      (_$data['field'] as Enum$TeamDiscussionOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamDiscussionOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$TeamDiscussionOrder<Input$TeamDiscussionOrder> get copyWith =>
      CopyWith$Input$TeamDiscussionOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamDiscussionOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$TeamDiscussionOrder<TRes> {
  factory CopyWith$Input$TeamDiscussionOrder(
    Input$TeamDiscussionOrder instance,
    TRes Function(Input$TeamDiscussionOrder) then,
  ) = _CopyWithImpl$Input$TeamDiscussionOrder;

  factory CopyWith$Input$TeamDiscussionOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamDiscussionOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$TeamDiscussionOrderField? field,
  });
}

class _CopyWithImpl$Input$TeamDiscussionOrder<TRes>
    implements CopyWith$Input$TeamDiscussionOrder<TRes> {
  _CopyWithImpl$Input$TeamDiscussionOrder(
    this._instance,
    this._then,
  );

  final Input$TeamDiscussionOrder _instance;

  final TRes Function(Input$TeamDiscussionOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$TeamDiscussionOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamDiscussionOrderField),
      }));
}

class _CopyWithStubImpl$Input$TeamDiscussionOrder<TRes>
    implements CopyWith$Input$TeamDiscussionOrder<TRes> {
  _CopyWithStubImpl$Input$TeamDiscussionOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$TeamDiscussionOrderField? field,
  }) =>
      _res;
}

class Input$TeamMemberOrder {
  factory Input$TeamMemberOrder({
    required Enum$OrderDirection direction,
    required Enum$TeamMemberOrderField field,
  }) =>
      Input$TeamMemberOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$TeamMemberOrder._(this._$data);

  factory Input$TeamMemberOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamMemberOrderField((l$field as String));
    return Input$TeamMemberOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$TeamMemberOrderField get field =>
      (_$data['field'] as Enum$TeamMemberOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamMemberOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$TeamMemberOrder<Input$TeamMemberOrder> get copyWith =>
      CopyWith$Input$TeamMemberOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamMemberOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$TeamMemberOrder<TRes> {
  factory CopyWith$Input$TeamMemberOrder(
    Input$TeamMemberOrder instance,
    TRes Function(Input$TeamMemberOrder) then,
  ) = _CopyWithImpl$Input$TeamMemberOrder;

  factory CopyWith$Input$TeamMemberOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamMemberOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$TeamMemberOrderField? field,
  });
}

class _CopyWithImpl$Input$TeamMemberOrder<TRes>
    implements CopyWith$Input$TeamMemberOrder<TRes> {
  _CopyWithImpl$Input$TeamMemberOrder(
    this._instance,
    this._then,
  );

  final Input$TeamMemberOrder _instance;

  final TRes Function(Input$TeamMemberOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$TeamMemberOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamMemberOrderField),
      }));
}

class _CopyWithStubImpl$Input$TeamMemberOrder<TRes>
    implements CopyWith$Input$TeamMemberOrder<TRes> {
  _CopyWithStubImpl$Input$TeamMemberOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$TeamMemberOrderField? field,
  }) =>
      _res;
}

class Input$TeamOrder {
  factory Input$TeamOrder({
    required Enum$OrderDirection direction,
    required Enum$TeamOrderField field,
  }) =>
      Input$TeamOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$TeamOrder._(this._$data);

  factory Input$TeamOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] = fromJson$Enum$TeamOrderField((l$field as String));
    return Input$TeamOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$TeamOrderField get field => (_$data['field'] as Enum$TeamOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$TeamOrder<Input$TeamOrder> get copyWith =>
      CopyWith$Input$TeamOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$TeamOrder<TRes> {
  factory CopyWith$Input$TeamOrder(
    Input$TeamOrder instance,
    TRes Function(Input$TeamOrder) then,
  ) = _CopyWithImpl$Input$TeamOrder;

  factory CopyWith$Input$TeamOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$TeamOrderField? field,
  });
}

class _CopyWithImpl$Input$TeamOrder<TRes>
    implements CopyWith$Input$TeamOrder<TRes> {
  _CopyWithImpl$Input$TeamOrder(
    this._instance,
    this._then,
  );

  final Input$TeamOrder _instance;

  final TRes Function(Input$TeamOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$TeamOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamOrderField),
      }));
}

class _CopyWithStubImpl$Input$TeamOrder<TRes>
    implements CopyWith$Input$TeamOrder<TRes> {
  _CopyWithStubImpl$Input$TeamOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$TeamOrderField? field,
  }) =>
      _res;
}

class Input$TeamRepositoryOrder {
  factory Input$TeamRepositoryOrder({
    required Enum$OrderDirection direction,
    required Enum$TeamRepositoryOrderField field,
  }) =>
      Input$TeamRepositoryOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$TeamRepositoryOrder._(this._$data);

  factory Input$TeamRepositoryOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$TeamRepositoryOrderField((l$field as String));
    return Input$TeamRepositoryOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$TeamRepositoryOrderField get field =>
      (_$data['field'] as Enum$TeamRepositoryOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$TeamRepositoryOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$TeamRepositoryOrder<Input$TeamRepositoryOrder> get copyWith =>
      CopyWith$Input$TeamRepositoryOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TeamRepositoryOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$TeamRepositoryOrder<TRes> {
  factory CopyWith$Input$TeamRepositoryOrder(
    Input$TeamRepositoryOrder instance,
    TRes Function(Input$TeamRepositoryOrder) then,
  ) = _CopyWithImpl$Input$TeamRepositoryOrder;

  factory CopyWith$Input$TeamRepositoryOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$TeamRepositoryOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$TeamRepositoryOrderField? field,
  });
}

class _CopyWithImpl$Input$TeamRepositoryOrder<TRes>
    implements CopyWith$Input$TeamRepositoryOrder<TRes> {
  _CopyWithImpl$Input$TeamRepositoryOrder(
    this._instance,
    this._then,
  );

  final Input$TeamRepositoryOrder _instance;

  final TRes Function(Input$TeamRepositoryOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$TeamRepositoryOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$TeamRepositoryOrderField),
      }));
}

class _CopyWithStubImpl$Input$TeamRepositoryOrder<TRes>
    implements CopyWith$Input$TeamRepositoryOrder<TRes> {
  _CopyWithStubImpl$Input$TeamRepositoryOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$TeamRepositoryOrderField? field,
  }) =>
      _res;
}

class Input$TransferEnterpriseOrganizationInput {
  factory Input$TransferEnterpriseOrganizationInput({
    String? clientMutationId,
    required String destinationEnterpriseId,
    required String organizationId,
  }) =>
      Input$TransferEnterpriseOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'destinationEnterpriseId': destinationEnterpriseId,
        r'organizationId': organizationId,
      });

  Input$TransferEnterpriseOrganizationInput._(this._$data);

  factory Input$TransferEnterpriseOrganizationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$destinationEnterpriseId = data['destinationEnterpriseId'];
    result$data['destinationEnterpriseId'] =
        (l$destinationEnterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$TransferEnterpriseOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get destinationEnterpriseId =>
      (_$data['destinationEnterpriseId'] as String);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$destinationEnterpriseId = destinationEnterpriseId;
    result$data['destinationEnterpriseId'] = l$destinationEnterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$TransferEnterpriseOrganizationInput<
          Input$TransferEnterpriseOrganizationInput>
      get copyWith => CopyWith$Input$TransferEnterpriseOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferEnterpriseOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$destinationEnterpriseId = destinationEnterpriseId;
    final lOther$destinationEnterpriseId = other.destinationEnterpriseId;
    if (l$destinationEnterpriseId != lOther$destinationEnterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$destinationEnterpriseId = destinationEnterpriseId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$destinationEnterpriseId,
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  factory CopyWith$Input$TransferEnterpriseOrganizationInput(
    Input$TransferEnterpriseOrganizationInput instance,
    TRes Function(Input$TransferEnterpriseOrganizationInput) then,
  ) = _CopyWithImpl$Input$TransferEnterpriseOrganizationInput;

  factory CopyWith$Input$TransferEnterpriseOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? destinationEnterpriseId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$TransferEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  _CopyWithImpl$Input$TransferEnterpriseOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$TransferEnterpriseOrganizationInput _instance;

  final TRes Function(Input$TransferEnterpriseOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? destinationEnterpriseId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$TransferEnterpriseOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (destinationEnterpriseId != _undefined &&
            destinationEnterpriseId != null)
          'destinationEnterpriseId': (destinationEnterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput<TRes>
    implements CopyWith$Input$TransferEnterpriseOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$TransferEnterpriseOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? destinationEnterpriseId,
    String? organizationId,
  }) =>
      _res;
}

class Input$TransferIssueInput {
  factory Input$TransferIssueInput({
    String? clientMutationId,
    bool? createLabelsIfMissing,
    required String issueId,
    required String repositoryId,
  }) =>
      Input$TransferIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (createLabelsIfMissing != null)
          r'createLabelsIfMissing': createLabelsIfMissing,
        r'issueId': issueId,
        r'repositoryId': repositoryId,
      });

  Input$TransferIssueInput._(this._$data);

  factory Input$TransferIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('createLabelsIfMissing')) {
      final l$createLabelsIfMissing = data['createLabelsIfMissing'];
      result$data['createLabelsIfMissing'] = (l$createLabelsIfMissing as bool?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$TransferIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get createLabelsIfMissing => (_$data['createLabelsIfMissing'] as bool?);
  String get issueId => (_$data['issueId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('createLabelsIfMissing')) {
      final l$createLabelsIfMissing = createLabelsIfMissing;
      result$data['createLabelsIfMissing'] = l$createLabelsIfMissing;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$TransferIssueInput<Input$TransferIssueInput> get copyWith =>
      CopyWith$Input$TransferIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransferIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$createLabelsIfMissing = createLabelsIfMissing;
    final lOther$createLabelsIfMissing = other.createLabelsIfMissing;
    if (_$data.containsKey('createLabelsIfMissing') !=
        other._$data.containsKey('createLabelsIfMissing')) {
      return false;
    }
    if (l$createLabelsIfMissing != lOther$createLabelsIfMissing) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$createLabelsIfMissing = createLabelsIfMissing;
    final l$issueId = issueId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('createLabelsIfMissing')
          ? l$createLabelsIfMissing
          : const {},
      l$issueId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$TransferIssueInput<TRes> {
  factory CopyWith$Input$TransferIssueInput(
    Input$TransferIssueInput instance,
    TRes Function(Input$TransferIssueInput) then,
  ) = _CopyWithImpl$Input$TransferIssueInput;

  factory CopyWith$Input$TransferIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransferIssueInput;

  TRes call({
    String? clientMutationId,
    bool? createLabelsIfMissing,
    String? issueId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$TransferIssueInput<TRes>
    implements CopyWith$Input$TransferIssueInput<TRes> {
  _CopyWithImpl$Input$TransferIssueInput(
    this._instance,
    this._then,
  );

  final Input$TransferIssueInput _instance;

  final TRes Function(Input$TransferIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? createLabelsIfMissing = _undefined,
    Object? issueId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$TransferIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (createLabelsIfMissing != _undefined)
          'createLabelsIfMissing': (createLabelsIfMissing as bool?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$TransferIssueInput<TRes>
    implements CopyWith$Input$TransferIssueInput<TRes> {
  _CopyWithStubImpl$Input$TransferIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? createLabelsIfMissing,
    String? issueId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$UnarchiveProjectV2ItemInput {
  factory Input$UnarchiveProjectV2ItemInput({
    String? clientMutationId,
    required String itemId,
    required String projectId,
  }) =>
      Input$UnarchiveProjectV2ItemInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'itemId': itemId,
        r'projectId': projectId,
      });

  Input$UnarchiveProjectV2ItemInput._(this._$data);

  factory Input$UnarchiveProjectV2ItemInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$UnarchiveProjectV2ItemInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get itemId => (_$data['itemId'] as String);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$UnarchiveProjectV2ItemInput<Input$UnarchiveProjectV2ItemInput>
      get copyWith => CopyWith$Input$UnarchiveProjectV2ItemInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnarchiveProjectV2ItemInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$itemId = itemId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$itemId,
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  factory CopyWith$Input$UnarchiveProjectV2ItemInput(
    Input$UnarchiveProjectV2ItemInput instance,
    TRes Function(Input$UnarchiveProjectV2ItemInput) then,
  ) = _CopyWithImpl$Input$UnarchiveProjectV2ItemInput;

  factory CopyWith$Input$UnarchiveProjectV2ItemInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput;

  TRes call({
    String? clientMutationId,
    String? itemId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$UnarchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  _CopyWithImpl$Input$UnarchiveProjectV2ItemInput(
    this._instance,
    this._then,
  );

  final Input$UnarchiveProjectV2ItemInput _instance;

  final TRes Function(Input$UnarchiveProjectV2ItemInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? itemId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$UnarchiveProjectV2ItemInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput<TRes>
    implements CopyWith$Input$UnarchiveProjectV2ItemInput<TRes> {
  _CopyWithStubImpl$Input$UnarchiveProjectV2ItemInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? itemId,
    String? projectId,
  }) =>
      _res;
}

class Input$UnarchiveRepositoryInput {
  factory Input$UnarchiveRepositoryInput({
    String? clientMutationId,
    required String repositoryId,
  }) =>
      Input$UnarchiveRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
      });

  Input$UnarchiveRepositoryInput._(this._$data);

  factory Input$UnarchiveRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UnarchiveRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UnarchiveRepositoryInput<Input$UnarchiveRepositoryInput>
      get copyWith => CopyWith$Input$UnarchiveRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnarchiveRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  factory CopyWith$Input$UnarchiveRepositoryInput(
    Input$UnarchiveRepositoryInput instance,
    TRes Function(Input$UnarchiveRepositoryInput) then,
  ) = _CopyWithImpl$Input$UnarchiveRepositoryInput;

  factory CopyWith$Input$UnarchiveRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnarchiveRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$UnarchiveRepositoryInput<TRes>
    implements CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  _CopyWithImpl$Input$UnarchiveRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UnarchiveRepositoryInput _instance;

  final TRes Function(Input$UnarchiveRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UnarchiveRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$UnarchiveRepositoryInput<TRes>
    implements CopyWith$Input$UnarchiveRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UnarchiveRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$UnfollowOrganizationInput {
  factory Input$UnfollowOrganizationInput({
    String? clientMutationId,
    required String organizationId,
  }) =>
      Input$UnfollowOrganizationInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
      });

  Input$UnfollowOrganizationInput._(this._$data);

  factory Input$UnfollowOrganizationInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$UnfollowOrganizationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$UnfollowOrganizationInput<Input$UnfollowOrganizationInput>
      get copyWith => CopyWith$Input$UnfollowOrganizationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnfollowOrganizationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$UnfollowOrganizationInput<TRes> {
  factory CopyWith$Input$UnfollowOrganizationInput(
    Input$UnfollowOrganizationInput instance,
    TRes Function(Input$UnfollowOrganizationInput) then,
  ) = _CopyWithImpl$Input$UnfollowOrganizationInput;

  factory CopyWith$Input$UnfollowOrganizationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnfollowOrganizationInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$UnfollowOrganizationInput<TRes>
    implements CopyWith$Input$UnfollowOrganizationInput<TRes> {
  _CopyWithImpl$Input$UnfollowOrganizationInput(
    this._instance,
    this._then,
  );

  final Input$UnfollowOrganizationInput _instance;

  final TRes Function(Input$UnfollowOrganizationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(Input$UnfollowOrganizationInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$UnfollowOrganizationInput<TRes>
    implements CopyWith$Input$UnfollowOrganizationInput<TRes> {
  _CopyWithStubImpl$Input$UnfollowOrganizationInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
  }) =>
      _res;
}

class Input$UnfollowUserInput {
  factory Input$UnfollowUserInput({
    String? clientMutationId,
    required String userId,
  }) =>
      Input$UnfollowUserInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'userId': userId,
      });

  Input$UnfollowUserInput._(this._$data);

  factory Input$UnfollowUserInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$userId = data['userId'];
    result$data['userId'] = (l$userId as String);
    return Input$UnfollowUserInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get userId => (_$data['userId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$userId = userId;
    result$data['userId'] = l$userId;
    return result$data;
  }

  CopyWith$Input$UnfollowUserInput<Input$UnfollowUserInput> get copyWith =>
      CopyWith$Input$UnfollowUserInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnfollowUserInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$userId = userId;
    final lOther$userId = other.userId;
    if (l$userId != lOther$userId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$userId = userId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$userId,
    ]);
  }
}

abstract class CopyWith$Input$UnfollowUserInput<TRes> {
  factory CopyWith$Input$UnfollowUserInput(
    Input$UnfollowUserInput instance,
    TRes Function(Input$UnfollowUserInput) then,
  ) = _CopyWithImpl$Input$UnfollowUserInput;

  factory CopyWith$Input$UnfollowUserInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnfollowUserInput;

  TRes call({
    String? clientMutationId,
    String? userId,
  });
}

class _CopyWithImpl$Input$UnfollowUserInput<TRes>
    implements CopyWith$Input$UnfollowUserInput<TRes> {
  _CopyWithImpl$Input$UnfollowUserInput(
    this._instance,
    this._then,
  );

  final Input$UnfollowUserInput _instance;

  final TRes Function(Input$UnfollowUserInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? userId = _undefined,
  }) =>
      _then(Input$UnfollowUserInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (userId != _undefined && userId != null)
          'userId': (userId as String),
      }));
}

class _CopyWithStubImpl$Input$UnfollowUserInput<TRes>
    implements CopyWith$Input$UnfollowUserInput<TRes> {
  _CopyWithStubImpl$Input$UnfollowUserInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? userId,
  }) =>
      _res;
}

class Input$UnlinkProjectV2FromRepositoryInput {
  factory Input$UnlinkProjectV2FromRepositoryInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$UnlinkProjectV2FromRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$UnlinkProjectV2FromRepositoryInput._(this._$data);

  factory Input$UnlinkProjectV2FromRepositoryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UnlinkProjectV2FromRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UnlinkProjectV2FromRepositoryInput<
          Input$UnlinkProjectV2FromRepositoryInput>
      get copyWith => CopyWith$Input$UnlinkProjectV2FromRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlinkProjectV2FromRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  factory CopyWith$Input$UnlinkProjectV2FromRepositoryInput(
    Input$UnlinkProjectV2FromRepositoryInput instance,
    TRes Function(Input$UnlinkProjectV2FromRepositoryInput) then,
  ) = _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput;

  factory CopyWith$Input$UnlinkProjectV2FromRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  _CopyWithImpl$Input$UnlinkProjectV2FromRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkProjectV2FromRepositoryInput _instance;

  final TRes Function(Input$UnlinkProjectV2FromRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UnlinkProjectV2FromRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkProjectV2FromRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$UnlinkProjectV2FromTeamInput {
  factory Input$UnlinkProjectV2FromTeamInput({
    String? clientMutationId,
    required String projectId,
    required String teamId,
  }) =>
      Input$UnlinkProjectV2FromTeamInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'teamId': teamId,
      });

  Input$UnlinkProjectV2FromTeamInput._(this._$data);

  factory Input$UnlinkProjectV2FromTeamInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$teamId = data['teamId'];
    result$data['teamId'] = (l$teamId as String);
    return Input$UnlinkProjectV2FromTeamInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String get teamId => (_$data['teamId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$teamId = teamId;
    result$data['teamId'] = l$teamId;
    return result$data;
  }

  CopyWith$Input$UnlinkProjectV2FromTeamInput<
          Input$UnlinkProjectV2FromTeamInput>
      get copyWith => CopyWith$Input$UnlinkProjectV2FromTeamInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlinkProjectV2FromTeamInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$teamId = teamId;
    final lOther$teamId = other.teamId;
    if (l$teamId != lOther$teamId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$teamId = teamId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$teamId,
    ]);
  }
}

abstract class CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  factory CopyWith$Input$UnlinkProjectV2FromTeamInput(
    Input$UnlinkProjectV2FromTeamInput instance,
    TRes Function(Input$UnlinkProjectV2FromTeamInput) then,
  ) = _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput;

  factory CopyWith$Input$UnlinkProjectV2FromTeamInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  });
}

class _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  _CopyWithImpl$Input$UnlinkProjectV2FromTeamInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkProjectV2FromTeamInput _instance;

  final TRes Function(Input$UnlinkProjectV2FromTeamInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? teamId = _undefined,
  }) =>
      _then(Input$UnlinkProjectV2FromTeamInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (teamId != _undefined && teamId != null)
          'teamId': (teamId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput<TRes>
    implements CopyWith$Input$UnlinkProjectV2FromTeamInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkProjectV2FromTeamInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? teamId,
  }) =>
      _res;
}

class Input$UnlinkRepositoryFromProjectInput {
  factory Input$UnlinkRepositoryFromProjectInput({
    String? clientMutationId,
    required String projectId,
    required String repositoryId,
  }) =>
      Input$UnlinkRepositoryFromProjectInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'projectId': projectId,
        r'repositoryId': repositoryId,
      });

  Input$UnlinkRepositoryFromProjectInput._(this._$data);

  factory Input$UnlinkRepositoryFromProjectInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UnlinkRepositoryFromProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get projectId => (_$data['projectId'] as String);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UnlinkRepositoryFromProjectInput<
          Input$UnlinkRepositoryFromProjectInput>
      get copyWith => CopyWith$Input$UnlinkRepositoryFromProjectInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlinkRepositoryFromProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$projectId = projectId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$projectId,
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  factory CopyWith$Input$UnlinkRepositoryFromProjectInput(
    Input$UnlinkRepositoryFromProjectInput instance,
    TRes Function(Input$UnlinkRepositoryFromProjectInput) then,
  ) = _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput;

  factory CopyWith$Input$UnlinkRepositoryFromProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput;

  TRes call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  });
}

class _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput<TRes>
    implements CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  _CopyWithImpl$Input$UnlinkRepositoryFromProjectInput(
    this._instance,
    this._then,
  );

  final Input$UnlinkRepositoryFromProjectInput _instance;

  final TRes Function(Input$UnlinkRepositoryFromProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? projectId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UnlinkRepositoryFromProjectInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput<TRes>
    implements CopyWith$Input$UnlinkRepositoryFromProjectInput<TRes> {
  _CopyWithStubImpl$Input$UnlinkRepositoryFromProjectInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? projectId,
    String? repositoryId,
  }) =>
      _res;
}

class Input$UnlockLockableInput {
  factory Input$UnlockLockableInput({
    String? clientMutationId,
    required String lockableId,
  }) =>
      Input$UnlockLockableInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'lockableId': lockableId,
      });

  Input$UnlockLockableInput._(this._$data);

  factory Input$UnlockLockableInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$lockableId = data['lockableId'];
    result$data['lockableId'] = (l$lockableId as String);
    return Input$UnlockLockableInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get lockableId => (_$data['lockableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$lockableId = lockableId;
    result$data['lockableId'] = l$lockableId;
    return result$data;
  }

  CopyWith$Input$UnlockLockableInput<Input$UnlockLockableInput> get copyWith =>
      CopyWith$Input$UnlockLockableInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnlockLockableInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$lockableId = lockableId;
    final lOther$lockableId = other.lockableId;
    if (l$lockableId != lOther$lockableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$lockableId = lockableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$lockableId,
    ]);
  }
}

abstract class CopyWith$Input$UnlockLockableInput<TRes> {
  factory CopyWith$Input$UnlockLockableInput(
    Input$UnlockLockableInput instance,
    TRes Function(Input$UnlockLockableInput) then,
  ) = _CopyWithImpl$Input$UnlockLockableInput;

  factory CopyWith$Input$UnlockLockableInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnlockLockableInput;

  TRes call({
    String? clientMutationId,
    String? lockableId,
  });
}

class _CopyWithImpl$Input$UnlockLockableInput<TRes>
    implements CopyWith$Input$UnlockLockableInput<TRes> {
  _CopyWithImpl$Input$UnlockLockableInput(
    this._instance,
    this._then,
  );

  final Input$UnlockLockableInput _instance;

  final TRes Function(Input$UnlockLockableInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? lockableId = _undefined,
  }) =>
      _then(Input$UnlockLockableInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (lockableId != _undefined && lockableId != null)
          'lockableId': (lockableId as String),
      }));
}

class _CopyWithStubImpl$Input$UnlockLockableInput<TRes>
    implements CopyWith$Input$UnlockLockableInput<TRes> {
  _CopyWithStubImpl$Input$UnlockLockableInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? lockableId,
  }) =>
      _res;
}

class Input$UnmarkDiscussionCommentAsAnswerInput {
  factory Input$UnmarkDiscussionCommentAsAnswerInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$UnmarkDiscussionCommentAsAnswerInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$UnmarkDiscussionCommentAsAnswerInput._(this._$data);

  factory Input$UnmarkDiscussionCommentAsAnswerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$UnmarkDiscussionCommentAsAnswerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<
          Input$UnmarkDiscussionCommentAsAnswerInput>
      get copyWith => CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnmarkDiscussionCommentAsAnswerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  factory CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput(
    Input$UnmarkDiscussionCommentAsAnswerInput instance,
    TRes Function(Input$UnmarkDiscussionCommentAsAnswerInput) then,
  ) = _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput;

  factory CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithImpl$Input$UnmarkDiscussionCommentAsAnswerInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkDiscussionCommentAsAnswerInput _instance;

  final TRes Function(Input$UnmarkDiscussionCommentAsAnswerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$UnmarkDiscussionCommentAsAnswerInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput<TRes>
    implements CopyWith$Input$UnmarkDiscussionCommentAsAnswerInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkDiscussionCommentAsAnswerInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$UnmarkFileAsViewedInput {
  factory Input$UnmarkFileAsViewedInput({
    String? clientMutationId,
    required String path,
    required String pullRequestId,
  }) =>
      Input$UnmarkFileAsViewedInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'path': path,
        r'pullRequestId': pullRequestId,
      });

  Input$UnmarkFileAsViewedInput._(this._$data);

  factory Input$UnmarkFileAsViewedInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$path = data['path'];
    result$data['path'] = (l$path as String);
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$UnmarkFileAsViewedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get path => (_$data['path'] as String);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$path = path;
    result$data['path'] = l$path;
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$UnmarkFileAsViewedInput<Input$UnmarkFileAsViewedInput>
      get copyWith => CopyWith$Input$UnmarkFileAsViewedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnmarkFileAsViewedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$path = path;
    final lOther$path = other.path;
    if (l$path != lOther$path) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$path = path;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$path,
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  factory CopyWith$Input$UnmarkFileAsViewedInput(
    Input$UnmarkFileAsViewedInput instance,
    TRes Function(Input$UnmarkFileAsViewedInput) then,
  ) = _CopyWithImpl$Input$UnmarkFileAsViewedInput;

  factory CopyWith$Input$UnmarkFileAsViewedInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkFileAsViewedInput;

  TRes call({
    String? clientMutationId,
    String? path,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$UnmarkFileAsViewedInput<TRes>
    implements CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  _CopyWithImpl$Input$UnmarkFileAsViewedInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkFileAsViewedInput _instance;

  final TRes Function(Input$UnmarkFileAsViewedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? path = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$UnmarkFileAsViewedInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (path != _undefined && path != null) 'path': (path as String),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$UnmarkFileAsViewedInput<TRes>
    implements CopyWith$Input$UnmarkFileAsViewedInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkFileAsViewedInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? path,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$UnmarkIssueAsDuplicateInput {
  factory Input$UnmarkIssueAsDuplicateInput({
    required String canonicalId,
    String? clientMutationId,
    required String duplicateId,
  }) =>
      Input$UnmarkIssueAsDuplicateInput._({
        r'canonicalId': canonicalId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'duplicateId': duplicateId,
      });

  Input$UnmarkIssueAsDuplicateInput._(this._$data);

  factory Input$UnmarkIssueAsDuplicateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$canonicalId = data['canonicalId'];
    result$data['canonicalId'] = (l$canonicalId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$duplicateId = data['duplicateId'];
    result$data['duplicateId'] = (l$duplicateId as String);
    return Input$UnmarkIssueAsDuplicateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get canonicalId => (_$data['canonicalId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get duplicateId => (_$data['duplicateId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$canonicalId = canonicalId;
    result$data['canonicalId'] = l$canonicalId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$duplicateId = duplicateId;
    result$data['duplicateId'] = l$duplicateId;
    return result$data;
  }

  CopyWith$Input$UnmarkIssueAsDuplicateInput<Input$UnmarkIssueAsDuplicateInput>
      get copyWith => CopyWith$Input$UnmarkIssueAsDuplicateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnmarkIssueAsDuplicateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$canonicalId = canonicalId;
    final lOther$canonicalId = other.canonicalId;
    if (l$canonicalId != lOther$canonicalId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$duplicateId = duplicateId;
    final lOther$duplicateId = other.duplicateId;
    if (l$duplicateId != lOther$duplicateId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$canonicalId = canonicalId;
    final l$clientMutationId = clientMutationId;
    final l$duplicateId = duplicateId;
    return Object.hashAll([
      l$canonicalId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$duplicateId,
    ]);
  }
}

abstract class CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  factory CopyWith$Input$UnmarkIssueAsDuplicateInput(
    Input$UnmarkIssueAsDuplicateInput instance,
    TRes Function(Input$UnmarkIssueAsDuplicateInput) then,
  ) = _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput;

  factory CopyWith$Input$UnmarkIssueAsDuplicateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput;

  TRes call({
    String? canonicalId,
    String? clientMutationId,
    String? duplicateId,
  });
}

class _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput<TRes>
    implements CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  _CopyWithImpl$Input$UnmarkIssueAsDuplicateInput(
    this._instance,
    this._then,
  );

  final Input$UnmarkIssueAsDuplicateInput _instance;

  final TRes Function(Input$UnmarkIssueAsDuplicateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? canonicalId = _undefined,
    Object? clientMutationId = _undefined,
    Object? duplicateId = _undefined,
  }) =>
      _then(Input$UnmarkIssueAsDuplicateInput._({
        ..._instance._$data,
        if (canonicalId != _undefined && canonicalId != null)
          'canonicalId': (canonicalId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (duplicateId != _undefined && duplicateId != null)
          'duplicateId': (duplicateId as String),
      }));
}

class _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput<TRes>
    implements CopyWith$Input$UnmarkIssueAsDuplicateInput<TRes> {
  _CopyWithStubImpl$Input$UnmarkIssueAsDuplicateInput(this._res);

  TRes _res;

  call({
    String? canonicalId,
    String? clientMutationId,
    String? duplicateId,
  }) =>
      _res;
}

class Input$UnminimizeCommentInput {
  factory Input$UnminimizeCommentInput({
    String? clientMutationId,
    required String subjectId,
  }) =>
      Input$UnminimizeCommentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'subjectId': subjectId,
      });

  Input$UnminimizeCommentInput._(this._$data);

  factory Input$UnminimizeCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$subjectId = data['subjectId'];
    result$data['subjectId'] = (l$subjectId as String);
    return Input$UnminimizeCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get subjectId => (_$data['subjectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$subjectId = subjectId;
    result$data['subjectId'] = l$subjectId;
    return result$data;
  }

  CopyWith$Input$UnminimizeCommentInput<Input$UnminimizeCommentInput>
      get copyWith => CopyWith$Input$UnminimizeCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnminimizeCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$subjectId = subjectId;
    final lOther$subjectId = other.subjectId;
    if (l$subjectId != lOther$subjectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$subjectId = subjectId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$subjectId,
    ]);
  }
}

abstract class CopyWith$Input$UnminimizeCommentInput<TRes> {
  factory CopyWith$Input$UnminimizeCommentInput(
    Input$UnminimizeCommentInput instance,
    TRes Function(Input$UnminimizeCommentInput) then,
  ) = _CopyWithImpl$Input$UnminimizeCommentInput;

  factory CopyWith$Input$UnminimizeCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnminimizeCommentInput;

  TRes call({
    String? clientMutationId,
    String? subjectId,
  });
}

class _CopyWithImpl$Input$UnminimizeCommentInput<TRes>
    implements CopyWith$Input$UnminimizeCommentInput<TRes> {
  _CopyWithImpl$Input$UnminimizeCommentInput(
    this._instance,
    this._then,
  );

  final Input$UnminimizeCommentInput _instance;

  final TRes Function(Input$UnminimizeCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? subjectId = _undefined,
  }) =>
      _then(Input$UnminimizeCommentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (subjectId != _undefined && subjectId != null)
          'subjectId': (subjectId as String),
      }));
}

class _CopyWithStubImpl$Input$UnminimizeCommentInput<TRes>
    implements CopyWith$Input$UnminimizeCommentInput<TRes> {
  _CopyWithStubImpl$Input$UnminimizeCommentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? subjectId,
  }) =>
      _res;
}

class Input$UnpinIssueInput {
  factory Input$UnpinIssueInput({
    String? clientMutationId,
    required String issueId,
  }) =>
      Input$UnpinIssueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'issueId': issueId,
      });

  Input$UnpinIssueInput._(this._$data);

  factory Input$UnpinIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$issueId = data['issueId'];
    result$data['issueId'] = (l$issueId as String);
    return Input$UnpinIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get issueId => (_$data['issueId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$issueId = issueId;
    result$data['issueId'] = l$issueId;
    return result$data;
  }

  CopyWith$Input$UnpinIssueInput<Input$UnpinIssueInput> get copyWith =>
      CopyWith$Input$UnpinIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnpinIssueInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$issueId = issueId;
    final lOther$issueId = other.issueId;
    if (l$issueId != lOther$issueId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$issueId = issueId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$issueId,
    ]);
  }
}

abstract class CopyWith$Input$UnpinIssueInput<TRes> {
  factory CopyWith$Input$UnpinIssueInput(
    Input$UnpinIssueInput instance,
    TRes Function(Input$UnpinIssueInput) then,
  ) = _CopyWithImpl$Input$UnpinIssueInput;

  factory CopyWith$Input$UnpinIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnpinIssueInput;

  TRes call({
    String? clientMutationId,
    String? issueId,
  });
}

class _CopyWithImpl$Input$UnpinIssueInput<TRes>
    implements CopyWith$Input$UnpinIssueInput<TRes> {
  _CopyWithImpl$Input$UnpinIssueInput(
    this._instance,
    this._then,
  );

  final Input$UnpinIssueInput _instance;

  final TRes Function(Input$UnpinIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? issueId = _undefined,
  }) =>
      _then(Input$UnpinIssueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (issueId != _undefined && issueId != null)
          'issueId': (issueId as String),
      }));
}

class _CopyWithStubImpl$Input$UnpinIssueInput<TRes>
    implements CopyWith$Input$UnpinIssueInput<TRes> {
  _CopyWithStubImpl$Input$UnpinIssueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? issueId,
  }) =>
      _res;
}

class Input$UnresolveReviewThreadInput {
  factory Input$UnresolveReviewThreadInput({
    String? clientMutationId,
    required String threadId,
  }) =>
      Input$UnresolveReviewThreadInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'threadId': threadId,
      });

  Input$UnresolveReviewThreadInput._(this._$data);

  factory Input$UnresolveReviewThreadInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$threadId = data['threadId'];
    result$data['threadId'] = (l$threadId as String);
    return Input$UnresolveReviewThreadInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get threadId => (_$data['threadId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$threadId = threadId;
    result$data['threadId'] = l$threadId;
    return result$data;
  }

  CopyWith$Input$UnresolveReviewThreadInput<Input$UnresolveReviewThreadInput>
      get copyWith => CopyWith$Input$UnresolveReviewThreadInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UnresolveReviewThreadInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$threadId = threadId;
    final lOther$threadId = other.threadId;
    if (l$threadId != lOther$threadId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$threadId = threadId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$threadId,
    ]);
  }
}

abstract class CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  factory CopyWith$Input$UnresolveReviewThreadInput(
    Input$UnresolveReviewThreadInput instance,
    TRes Function(Input$UnresolveReviewThreadInput) then,
  ) = _CopyWithImpl$Input$UnresolveReviewThreadInput;

  factory CopyWith$Input$UnresolveReviewThreadInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UnresolveReviewThreadInput;

  TRes call({
    String? clientMutationId,
    String? threadId,
  });
}

class _CopyWithImpl$Input$UnresolveReviewThreadInput<TRes>
    implements CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  _CopyWithImpl$Input$UnresolveReviewThreadInput(
    this._instance,
    this._then,
  );

  final Input$UnresolveReviewThreadInput _instance;

  final TRes Function(Input$UnresolveReviewThreadInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? threadId = _undefined,
  }) =>
      _then(Input$UnresolveReviewThreadInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (threadId != _undefined && threadId != null)
          'threadId': (threadId as String),
      }));
}

class _CopyWithStubImpl$Input$UnresolveReviewThreadInput<TRes>
    implements CopyWith$Input$UnresolveReviewThreadInput<TRes> {
  _CopyWithStubImpl$Input$UnresolveReviewThreadInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? threadId,
  }) =>
      _res;
}

class Input$UpdateBranchProtectionRuleInput {
  factory Input$UpdateBranchProtectionRuleInput({
    bool? allowsDeletions,
    bool? allowsForcePushes,
    bool? blocksCreations,
    required String branchProtectionRuleId,
    List<String>? bypassForcePushActorIds,
    List<String>? bypassPullRequestActorIds,
    String? clientMutationId,
    bool? dismissesStaleReviews,
    bool? isAdminEnforced,
    bool? lockAllowsFetchAndMerge,
    bool? lockBranch,
    String? pattern,
    List<String>? pushActorIds,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    List<String>? requiredDeploymentEnvironments,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresApprovingReviews,
    bool? requiresCodeOwnerReviews,
    bool? requiresCommitSignatures,
    bool? requiresConversationResolution,
    bool? requiresDeployments,
    bool? requiresLinearHistory,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? restrictsPushes,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
  }) =>
      Input$UpdateBranchProtectionRuleInput._({
        if (allowsDeletions != null) r'allowsDeletions': allowsDeletions,
        if (allowsForcePushes != null) r'allowsForcePushes': allowsForcePushes,
        if (blocksCreations != null) r'blocksCreations': blocksCreations,
        r'branchProtectionRuleId': branchProtectionRuleId,
        if (bypassForcePushActorIds != null)
          r'bypassForcePushActorIds': bypassForcePushActorIds,
        if (bypassPullRequestActorIds != null)
          r'bypassPullRequestActorIds': bypassPullRequestActorIds,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (dismissesStaleReviews != null)
          r'dismissesStaleReviews': dismissesStaleReviews,
        if (isAdminEnforced != null) r'isAdminEnforced': isAdminEnforced,
        if (lockAllowsFetchAndMerge != null)
          r'lockAllowsFetchAndMerge': lockAllowsFetchAndMerge,
        if (lockBranch != null) r'lockBranch': lockBranch,
        if (pattern != null) r'pattern': pattern,
        if (pushActorIds != null) r'pushActorIds': pushActorIds,
        if (requireLastPushApproval != null)
          r'requireLastPushApproval': requireLastPushApproval,
        if (requiredApprovingReviewCount != null)
          r'requiredApprovingReviewCount': requiredApprovingReviewCount,
        if (requiredDeploymentEnvironments != null)
          r'requiredDeploymentEnvironments': requiredDeploymentEnvironments,
        if (requiredStatusCheckContexts != null)
          r'requiredStatusCheckContexts': requiredStatusCheckContexts,
        if (requiredStatusChecks != null)
          r'requiredStatusChecks': requiredStatusChecks,
        if (requiresApprovingReviews != null)
          r'requiresApprovingReviews': requiresApprovingReviews,
        if (requiresCodeOwnerReviews != null)
          r'requiresCodeOwnerReviews': requiresCodeOwnerReviews,
        if (requiresCommitSignatures != null)
          r'requiresCommitSignatures': requiresCommitSignatures,
        if (requiresConversationResolution != null)
          r'requiresConversationResolution': requiresConversationResolution,
        if (requiresDeployments != null)
          r'requiresDeployments': requiresDeployments,
        if (requiresLinearHistory != null)
          r'requiresLinearHistory': requiresLinearHistory,
        if (requiresStatusChecks != null)
          r'requiresStatusChecks': requiresStatusChecks,
        if (requiresStrictStatusChecks != null)
          r'requiresStrictStatusChecks': requiresStrictStatusChecks,
        if (restrictsPushes != null) r'restrictsPushes': restrictsPushes,
        if (restrictsReviewDismissals != null)
          r'restrictsReviewDismissals': restrictsReviewDismissals,
        if (reviewDismissalActorIds != null)
          r'reviewDismissalActorIds': reviewDismissalActorIds,
      });

  Input$UpdateBranchProtectionRuleInput._(this._$data);

  factory Input$UpdateBranchProtectionRuleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = data['allowsDeletions'];
      result$data['allowsDeletions'] = (l$allowsDeletions as bool?);
    }
    if (data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = data['allowsForcePushes'];
      result$data['allowsForcePushes'] = (l$allowsForcePushes as bool?);
    }
    if (data.containsKey('blocksCreations')) {
      final l$blocksCreations = data['blocksCreations'];
      result$data['blocksCreations'] = (l$blocksCreations as bool?);
    }
    final l$branchProtectionRuleId = data['branchProtectionRuleId'];
    result$data['branchProtectionRuleId'] =
        (l$branchProtectionRuleId as String);
    if (data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = data['bypassForcePushActorIds'];
      result$data['bypassForcePushActorIds'] =
          (l$bypassForcePushActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = data['bypassPullRequestActorIds'];
      result$data['bypassPullRequestActorIds'] =
          (l$bypassPullRequestActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = data['dismissesStaleReviews'];
      result$data['dismissesStaleReviews'] = (l$dismissesStaleReviews as bool?);
    }
    if (data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = data['isAdminEnforced'];
      result$data['isAdminEnforced'] = (l$isAdminEnforced as bool?);
    }
    if (data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = data['lockAllowsFetchAndMerge'];
      result$data['lockAllowsFetchAndMerge'] =
          (l$lockAllowsFetchAndMerge as bool?);
    }
    if (data.containsKey('lockBranch')) {
      final l$lockBranch = data['lockBranch'];
      result$data['lockBranch'] = (l$lockBranch as bool?);
    }
    if (data.containsKey('pattern')) {
      final l$pattern = data['pattern'];
      result$data['pattern'] = (l$pattern as String?);
    }
    if (data.containsKey('pushActorIds')) {
      final l$pushActorIds = data['pushActorIds'];
      result$data['pushActorIds'] = (l$pushActorIds as List<dynamic>?)
          ?.map((e) => (e as String))
          .toList();
    }
    if (data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = data['requireLastPushApproval'];
      result$data['requireLastPushApproval'] =
          (l$requireLastPushApproval as bool?);
    }
    if (data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount =
          data['requiredApprovingReviewCount'];
      result$data['requiredApprovingReviewCount'] =
          (l$requiredApprovingReviewCount as int?);
    }
    if (data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments =
          data['requiredDeploymentEnvironments'];
      result$data['requiredDeploymentEnvironments'] =
          (l$requiredDeploymentEnvironments as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = data['requiredStatusCheckContexts'];
      result$data['requiredStatusCheckContexts'] =
          (l$requiredStatusCheckContexts as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    if (data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = data['requiredStatusChecks'];
      result$data['requiredStatusChecks'] =
          (l$requiredStatusChecks as List<dynamic>?)
              ?.map((e) => Input$RequiredStatusCheckInput.fromJson(
                  (e as Map<String, dynamic>)))
              .toList();
    }
    if (data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = data['requiresApprovingReviews'];
      result$data['requiresApprovingReviews'] =
          (l$requiresApprovingReviews as bool?);
    }
    if (data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = data['requiresCodeOwnerReviews'];
      result$data['requiresCodeOwnerReviews'] =
          (l$requiresCodeOwnerReviews as bool?);
    }
    if (data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = data['requiresCommitSignatures'];
      result$data['requiresCommitSignatures'] =
          (l$requiresCommitSignatures as bool?);
    }
    if (data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution =
          data['requiresConversationResolution'];
      result$data['requiresConversationResolution'] =
          (l$requiresConversationResolution as bool?);
    }
    if (data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = data['requiresDeployments'];
      result$data['requiresDeployments'] = (l$requiresDeployments as bool?);
    }
    if (data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = data['requiresLinearHistory'];
      result$data['requiresLinearHistory'] = (l$requiresLinearHistory as bool?);
    }
    if (data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = data['requiresStatusChecks'];
      result$data['requiresStatusChecks'] = (l$requiresStatusChecks as bool?);
    }
    if (data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = data['requiresStrictStatusChecks'];
      result$data['requiresStrictStatusChecks'] =
          (l$requiresStrictStatusChecks as bool?);
    }
    if (data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = data['restrictsPushes'];
      result$data['restrictsPushes'] = (l$restrictsPushes as bool?);
    }
    if (data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = data['restrictsReviewDismissals'];
      result$data['restrictsReviewDismissals'] =
          (l$restrictsReviewDismissals as bool?);
    }
    if (data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = data['reviewDismissalActorIds'];
      result$data['reviewDismissalActorIds'] =
          (l$reviewDismissalActorIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    return Input$UpdateBranchProtectionRuleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  bool? get allowsDeletions => (_$data['allowsDeletions'] as bool?);
  bool? get allowsForcePushes => (_$data['allowsForcePushes'] as bool?);
  bool? get blocksCreations => (_$data['blocksCreations'] as bool?);
  String get branchProtectionRuleId =>
      (_$data['branchProtectionRuleId'] as String);
  List<String>? get bypassForcePushActorIds =>
      (_$data['bypassForcePushActorIds'] as List<String>?);
  List<String>? get bypassPullRequestActorIds =>
      (_$data['bypassPullRequestActorIds'] as List<String>?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get dismissesStaleReviews => (_$data['dismissesStaleReviews'] as bool?);
  bool? get isAdminEnforced => (_$data['isAdminEnforced'] as bool?);
  bool? get lockAllowsFetchAndMerge =>
      (_$data['lockAllowsFetchAndMerge'] as bool?);
  bool? get lockBranch => (_$data['lockBranch'] as bool?);
  String? get pattern => (_$data['pattern'] as String?);
  List<String>? get pushActorIds => (_$data['pushActorIds'] as List<String>?);
  bool? get requireLastPushApproval =>
      (_$data['requireLastPushApproval'] as bool?);
  int? get requiredApprovingReviewCount =>
      (_$data['requiredApprovingReviewCount'] as int?);
  List<String>? get requiredDeploymentEnvironments =>
      (_$data['requiredDeploymentEnvironments'] as List<String>?);
  List<String>? get requiredStatusCheckContexts =>
      (_$data['requiredStatusCheckContexts'] as List<String>?);
  List<Input$RequiredStatusCheckInput>? get requiredStatusChecks =>
      (_$data['requiredStatusChecks'] as List<Input$RequiredStatusCheckInput>?);
  bool? get requiresApprovingReviews =>
      (_$data['requiresApprovingReviews'] as bool?);
  bool? get requiresCodeOwnerReviews =>
      (_$data['requiresCodeOwnerReviews'] as bool?);
  bool? get requiresCommitSignatures =>
      (_$data['requiresCommitSignatures'] as bool?);
  bool? get requiresConversationResolution =>
      (_$data['requiresConversationResolution'] as bool?);
  bool? get requiresDeployments => (_$data['requiresDeployments'] as bool?);
  bool? get requiresLinearHistory => (_$data['requiresLinearHistory'] as bool?);
  bool? get requiresStatusChecks => (_$data['requiresStatusChecks'] as bool?);
  bool? get requiresStrictStatusChecks =>
      (_$data['requiresStrictStatusChecks'] as bool?);
  bool? get restrictsPushes => (_$data['restrictsPushes'] as bool?);
  bool? get restrictsReviewDismissals =>
      (_$data['restrictsReviewDismissals'] as bool?);
  List<String>? get reviewDismissalActorIds =>
      (_$data['reviewDismissalActorIds'] as List<String>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('allowsDeletions')) {
      final l$allowsDeletions = allowsDeletions;
      result$data['allowsDeletions'] = l$allowsDeletions;
    }
    if (_$data.containsKey('allowsForcePushes')) {
      final l$allowsForcePushes = allowsForcePushes;
      result$data['allowsForcePushes'] = l$allowsForcePushes;
    }
    if (_$data.containsKey('blocksCreations')) {
      final l$blocksCreations = blocksCreations;
      result$data['blocksCreations'] = l$blocksCreations;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    result$data['branchProtectionRuleId'] = l$branchProtectionRuleId;
    if (_$data.containsKey('bypassForcePushActorIds')) {
      final l$bypassForcePushActorIds = bypassForcePushActorIds;
      result$data['bypassForcePushActorIds'] =
          l$bypassForcePushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('bypassPullRequestActorIds')) {
      final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
      result$data['bypassPullRequestActorIds'] =
          l$bypassPullRequestActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('dismissesStaleReviews')) {
      final l$dismissesStaleReviews = dismissesStaleReviews;
      result$data['dismissesStaleReviews'] = l$dismissesStaleReviews;
    }
    if (_$data.containsKey('isAdminEnforced')) {
      final l$isAdminEnforced = isAdminEnforced;
      result$data['isAdminEnforced'] = l$isAdminEnforced;
    }
    if (_$data.containsKey('lockAllowsFetchAndMerge')) {
      final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
      result$data['lockAllowsFetchAndMerge'] = l$lockAllowsFetchAndMerge;
    }
    if (_$data.containsKey('lockBranch')) {
      final l$lockBranch = lockBranch;
      result$data['lockBranch'] = l$lockBranch;
    }
    if (_$data.containsKey('pattern')) {
      final l$pattern = pattern;
      result$data['pattern'] = l$pattern;
    }
    if (_$data.containsKey('pushActorIds')) {
      final l$pushActorIds = pushActorIds;
      result$data['pushActorIds'] = l$pushActorIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('requireLastPushApproval')) {
      final l$requireLastPushApproval = requireLastPushApproval;
      result$data['requireLastPushApproval'] = l$requireLastPushApproval;
    }
    if (_$data.containsKey('requiredApprovingReviewCount')) {
      final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
      result$data['requiredApprovingReviewCount'] =
          l$requiredApprovingReviewCount;
    }
    if (_$data.containsKey('requiredDeploymentEnvironments')) {
      final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
      result$data['requiredDeploymentEnvironments'] =
          l$requiredDeploymentEnvironments?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusCheckContexts')) {
      final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
      result$data['requiredStatusCheckContexts'] =
          l$requiredStatusCheckContexts?.map((e) => e).toList();
    }
    if (_$data.containsKey('requiredStatusChecks')) {
      final l$requiredStatusChecks = requiredStatusChecks;
      result$data['requiredStatusChecks'] =
          l$requiredStatusChecks?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('requiresApprovingReviews')) {
      final l$requiresApprovingReviews = requiresApprovingReviews;
      result$data['requiresApprovingReviews'] = l$requiresApprovingReviews;
    }
    if (_$data.containsKey('requiresCodeOwnerReviews')) {
      final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
      result$data['requiresCodeOwnerReviews'] = l$requiresCodeOwnerReviews;
    }
    if (_$data.containsKey('requiresCommitSignatures')) {
      final l$requiresCommitSignatures = requiresCommitSignatures;
      result$data['requiresCommitSignatures'] = l$requiresCommitSignatures;
    }
    if (_$data.containsKey('requiresConversationResolution')) {
      final l$requiresConversationResolution = requiresConversationResolution;
      result$data['requiresConversationResolution'] =
          l$requiresConversationResolution;
    }
    if (_$data.containsKey('requiresDeployments')) {
      final l$requiresDeployments = requiresDeployments;
      result$data['requiresDeployments'] = l$requiresDeployments;
    }
    if (_$data.containsKey('requiresLinearHistory')) {
      final l$requiresLinearHistory = requiresLinearHistory;
      result$data['requiresLinearHistory'] = l$requiresLinearHistory;
    }
    if (_$data.containsKey('requiresStatusChecks')) {
      final l$requiresStatusChecks = requiresStatusChecks;
      result$data['requiresStatusChecks'] = l$requiresStatusChecks;
    }
    if (_$data.containsKey('requiresStrictStatusChecks')) {
      final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
      result$data['requiresStrictStatusChecks'] = l$requiresStrictStatusChecks;
    }
    if (_$data.containsKey('restrictsPushes')) {
      final l$restrictsPushes = restrictsPushes;
      result$data['restrictsPushes'] = l$restrictsPushes;
    }
    if (_$data.containsKey('restrictsReviewDismissals')) {
      final l$restrictsReviewDismissals = restrictsReviewDismissals;
      result$data['restrictsReviewDismissals'] = l$restrictsReviewDismissals;
    }
    if (_$data.containsKey('reviewDismissalActorIds')) {
      final l$reviewDismissalActorIds = reviewDismissalActorIds;
      result$data['reviewDismissalActorIds'] =
          l$reviewDismissalActorIds?.map((e) => e).toList();
    }
    return result$data;
  }

  CopyWith$Input$UpdateBranchProtectionRuleInput<
          Input$UpdateBranchProtectionRuleInput>
      get copyWith => CopyWith$Input$UpdateBranchProtectionRuleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateBranchProtectionRuleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$allowsDeletions = allowsDeletions;
    final lOther$allowsDeletions = other.allowsDeletions;
    if (_$data.containsKey('allowsDeletions') !=
        other._$data.containsKey('allowsDeletions')) {
      return false;
    }
    if (l$allowsDeletions != lOther$allowsDeletions) {
      return false;
    }
    final l$allowsForcePushes = allowsForcePushes;
    final lOther$allowsForcePushes = other.allowsForcePushes;
    if (_$data.containsKey('allowsForcePushes') !=
        other._$data.containsKey('allowsForcePushes')) {
      return false;
    }
    if (l$allowsForcePushes != lOther$allowsForcePushes) {
      return false;
    }
    final l$blocksCreations = blocksCreations;
    final lOther$blocksCreations = other.blocksCreations;
    if (_$data.containsKey('blocksCreations') !=
        other._$data.containsKey('blocksCreations')) {
      return false;
    }
    if (l$blocksCreations != lOther$blocksCreations) {
      return false;
    }
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final lOther$branchProtectionRuleId = other.branchProtectionRuleId;
    if (l$branchProtectionRuleId != lOther$branchProtectionRuleId) {
      return false;
    }
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final lOther$bypassForcePushActorIds = other.bypassForcePushActorIds;
    if (_$data.containsKey('bypassForcePushActorIds') !=
        other._$data.containsKey('bypassForcePushActorIds')) {
      return false;
    }
    if (l$bypassForcePushActorIds != null &&
        lOther$bypassForcePushActorIds != null) {
      if (l$bypassForcePushActorIds.length !=
          lOther$bypassForcePushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassForcePushActorIds.length; i++) {
        final l$bypassForcePushActorIds$entry = l$bypassForcePushActorIds[i];
        final lOther$bypassForcePushActorIds$entry =
            lOther$bypassForcePushActorIds[i];
        if (l$bypassForcePushActorIds$entry !=
            lOther$bypassForcePushActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassForcePushActorIds != lOther$bypassForcePushActorIds) {
      return false;
    }
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final lOther$bypassPullRequestActorIds = other.bypassPullRequestActorIds;
    if (_$data.containsKey('bypassPullRequestActorIds') !=
        other._$data.containsKey('bypassPullRequestActorIds')) {
      return false;
    }
    if (l$bypassPullRequestActorIds != null &&
        lOther$bypassPullRequestActorIds != null) {
      if (l$bypassPullRequestActorIds.length !=
          lOther$bypassPullRequestActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$bypassPullRequestActorIds.length; i++) {
        final l$bypassPullRequestActorIds$entry =
            l$bypassPullRequestActorIds[i];
        final lOther$bypassPullRequestActorIds$entry =
            lOther$bypassPullRequestActorIds[i];
        if (l$bypassPullRequestActorIds$entry !=
            lOther$bypassPullRequestActorIds$entry) {
          return false;
        }
      }
    } else if (l$bypassPullRequestActorIds !=
        lOther$bypassPullRequestActorIds) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final lOther$dismissesStaleReviews = other.dismissesStaleReviews;
    if (_$data.containsKey('dismissesStaleReviews') !=
        other._$data.containsKey('dismissesStaleReviews')) {
      return false;
    }
    if (l$dismissesStaleReviews != lOther$dismissesStaleReviews) {
      return false;
    }
    final l$isAdminEnforced = isAdminEnforced;
    final lOther$isAdminEnforced = other.isAdminEnforced;
    if (_$data.containsKey('isAdminEnforced') !=
        other._$data.containsKey('isAdminEnforced')) {
      return false;
    }
    if (l$isAdminEnforced != lOther$isAdminEnforced) {
      return false;
    }
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final lOther$lockAllowsFetchAndMerge = other.lockAllowsFetchAndMerge;
    if (_$data.containsKey('lockAllowsFetchAndMerge') !=
        other._$data.containsKey('lockAllowsFetchAndMerge')) {
      return false;
    }
    if (l$lockAllowsFetchAndMerge != lOther$lockAllowsFetchAndMerge) {
      return false;
    }
    final l$lockBranch = lockBranch;
    final lOther$lockBranch = other.lockBranch;
    if (_$data.containsKey('lockBranch') !=
        other._$data.containsKey('lockBranch')) {
      return false;
    }
    if (l$lockBranch != lOther$lockBranch) {
      return false;
    }
    final l$pattern = pattern;
    final lOther$pattern = other.pattern;
    if (_$data.containsKey('pattern') != other._$data.containsKey('pattern')) {
      return false;
    }
    if (l$pattern != lOther$pattern) {
      return false;
    }
    final l$pushActorIds = pushActorIds;
    final lOther$pushActorIds = other.pushActorIds;
    if (_$data.containsKey('pushActorIds') !=
        other._$data.containsKey('pushActorIds')) {
      return false;
    }
    if (l$pushActorIds != null && lOther$pushActorIds != null) {
      if (l$pushActorIds.length != lOther$pushActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$pushActorIds.length; i++) {
        final l$pushActorIds$entry = l$pushActorIds[i];
        final lOther$pushActorIds$entry = lOther$pushActorIds[i];
        if (l$pushActorIds$entry != lOther$pushActorIds$entry) {
          return false;
        }
      }
    } else if (l$pushActorIds != lOther$pushActorIds) {
      return false;
    }
    final l$requireLastPushApproval = requireLastPushApproval;
    final lOther$requireLastPushApproval = other.requireLastPushApproval;
    if (_$data.containsKey('requireLastPushApproval') !=
        other._$data.containsKey('requireLastPushApproval')) {
      return false;
    }
    if (l$requireLastPushApproval != lOther$requireLastPushApproval) {
      return false;
    }
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final lOther$requiredApprovingReviewCount =
        other.requiredApprovingReviewCount;
    if (_$data.containsKey('requiredApprovingReviewCount') !=
        other._$data.containsKey('requiredApprovingReviewCount')) {
      return false;
    }
    if (l$requiredApprovingReviewCount != lOther$requiredApprovingReviewCount) {
      return false;
    }
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final lOther$requiredDeploymentEnvironments =
        other.requiredDeploymentEnvironments;
    if (_$data.containsKey('requiredDeploymentEnvironments') !=
        other._$data.containsKey('requiredDeploymentEnvironments')) {
      return false;
    }
    if (l$requiredDeploymentEnvironments != null &&
        lOther$requiredDeploymentEnvironments != null) {
      if (l$requiredDeploymentEnvironments.length !=
          lOther$requiredDeploymentEnvironments.length) {
        return false;
      }
      for (int i = 0; i < l$requiredDeploymentEnvironments.length; i++) {
        final l$requiredDeploymentEnvironments$entry =
            l$requiredDeploymentEnvironments[i];
        final lOther$requiredDeploymentEnvironments$entry =
            lOther$requiredDeploymentEnvironments[i];
        if (l$requiredDeploymentEnvironments$entry !=
            lOther$requiredDeploymentEnvironments$entry) {
          return false;
        }
      }
    } else if (l$requiredDeploymentEnvironments !=
        lOther$requiredDeploymentEnvironments) {
      return false;
    }
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final lOther$requiredStatusCheckContexts =
        other.requiredStatusCheckContexts;
    if (_$data.containsKey('requiredStatusCheckContexts') !=
        other._$data.containsKey('requiredStatusCheckContexts')) {
      return false;
    }
    if (l$requiredStatusCheckContexts != null &&
        lOther$requiredStatusCheckContexts != null) {
      if (l$requiredStatusCheckContexts.length !=
          lOther$requiredStatusCheckContexts.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusCheckContexts.length; i++) {
        final l$requiredStatusCheckContexts$entry =
            l$requiredStatusCheckContexts[i];
        final lOther$requiredStatusCheckContexts$entry =
            lOther$requiredStatusCheckContexts[i];
        if (l$requiredStatusCheckContexts$entry !=
            lOther$requiredStatusCheckContexts$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusCheckContexts !=
        lOther$requiredStatusCheckContexts) {
      return false;
    }
    final l$requiredStatusChecks = requiredStatusChecks;
    final lOther$requiredStatusChecks = other.requiredStatusChecks;
    if (_$data.containsKey('requiredStatusChecks') !=
        other._$data.containsKey('requiredStatusChecks')) {
      return false;
    }
    if (l$requiredStatusChecks != null && lOther$requiredStatusChecks != null) {
      if (l$requiredStatusChecks.length != lOther$requiredStatusChecks.length) {
        return false;
      }
      for (int i = 0; i < l$requiredStatusChecks.length; i++) {
        final l$requiredStatusChecks$entry = l$requiredStatusChecks[i];
        final lOther$requiredStatusChecks$entry =
            lOther$requiredStatusChecks[i];
        if (l$requiredStatusChecks$entry != lOther$requiredStatusChecks$entry) {
          return false;
        }
      }
    } else if (l$requiredStatusChecks != lOther$requiredStatusChecks) {
      return false;
    }
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final lOther$requiresApprovingReviews = other.requiresApprovingReviews;
    if (_$data.containsKey('requiresApprovingReviews') !=
        other._$data.containsKey('requiresApprovingReviews')) {
      return false;
    }
    if (l$requiresApprovingReviews != lOther$requiresApprovingReviews) {
      return false;
    }
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final lOther$requiresCodeOwnerReviews = other.requiresCodeOwnerReviews;
    if (_$data.containsKey('requiresCodeOwnerReviews') !=
        other._$data.containsKey('requiresCodeOwnerReviews')) {
      return false;
    }
    if (l$requiresCodeOwnerReviews != lOther$requiresCodeOwnerReviews) {
      return false;
    }
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final lOther$requiresCommitSignatures = other.requiresCommitSignatures;
    if (_$data.containsKey('requiresCommitSignatures') !=
        other._$data.containsKey('requiresCommitSignatures')) {
      return false;
    }
    if (l$requiresCommitSignatures != lOther$requiresCommitSignatures) {
      return false;
    }
    final l$requiresConversationResolution = requiresConversationResolution;
    final lOther$requiresConversationResolution =
        other.requiresConversationResolution;
    if (_$data.containsKey('requiresConversationResolution') !=
        other._$data.containsKey('requiresConversationResolution')) {
      return false;
    }
    if (l$requiresConversationResolution !=
        lOther$requiresConversationResolution) {
      return false;
    }
    final l$requiresDeployments = requiresDeployments;
    final lOther$requiresDeployments = other.requiresDeployments;
    if (_$data.containsKey('requiresDeployments') !=
        other._$data.containsKey('requiresDeployments')) {
      return false;
    }
    if (l$requiresDeployments != lOther$requiresDeployments) {
      return false;
    }
    final l$requiresLinearHistory = requiresLinearHistory;
    final lOther$requiresLinearHistory = other.requiresLinearHistory;
    if (_$data.containsKey('requiresLinearHistory') !=
        other._$data.containsKey('requiresLinearHistory')) {
      return false;
    }
    if (l$requiresLinearHistory != lOther$requiresLinearHistory) {
      return false;
    }
    final l$requiresStatusChecks = requiresStatusChecks;
    final lOther$requiresStatusChecks = other.requiresStatusChecks;
    if (_$data.containsKey('requiresStatusChecks') !=
        other._$data.containsKey('requiresStatusChecks')) {
      return false;
    }
    if (l$requiresStatusChecks != lOther$requiresStatusChecks) {
      return false;
    }
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final lOther$requiresStrictStatusChecks = other.requiresStrictStatusChecks;
    if (_$data.containsKey('requiresStrictStatusChecks') !=
        other._$data.containsKey('requiresStrictStatusChecks')) {
      return false;
    }
    if (l$requiresStrictStatusChecks != lOther$requiresStrictStatusChecks) {
      return false;
    }
    final l$restrictsPushes = restrictsPushes;
    final lOther$restrictsPushes = other.restrictsPushes;
    if (_$data.containsKey('restrictsPushes') !=
        other._$data.containsKey('restrictsPushes')) {
      return false;
    }
    if (l$restrictsPushes != lOther$restrictsPushes) {
      return false;
    }
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final lOther$restrictsReviewDismissals = other.restrictsReviewDismissals;
    if (_$data.containsKey('restrictsReviewDismissals') !=
        other._$data.containsKey('restrictsReviewDismissals')) {
      return false;
    }
    if (l$restrictsReviewDismissals != lOther$restrictsReviewDismissals) {
      return false;
    }
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    final lOther$reviewDismissalActorIds = other.reviewDismissalActorIds;
    if (_$data.containsKey('reviewDismissalActorIds') !=
        other._$data.containsKey('reviewDismissalActorIds')) {
      return false;
    }
    if (l$reviewDismissalActorIds != null &&
        lOther$reviewDismissalActorIds != null) {
      if (l$reviewDismissalActorIds.length !=
          lOther$reviewDismissalActorIds.length) {
        return false;
      }
      for (int i = 0; i < l$reviewDismissalActorIds.length; i++) {
        final l$reviewDismissalActorIds$entry = l$reviewDismissalActorIds[i];
        final lOther$reviewDismissalActorIds$entry =
            lOther$reviewDismissalActorIds[i];
        if (l$reviewDismissalActorIds$entry !=
            lOther$reviewDismissalActorIds$entry) {
          return false;
        }
      }
    } else if (l$reviewDismissalActorIds != lOther$reviewDismissalActorIds) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$allowsDeletions = allowsDeletions;
    final l$allowsForcePushes = allowsForcePushes;
    final l$blocksCreations = blocksCreations;
    final l$branchProtectionRuleId = branchProtectionRuleId;
    final l$bypassForcePushActorIds = bypassForcePushActorIds;
    final l$bypassPullRequestActorIds = bypassPullRequestActorIds;
    final l$clientMutationId = clientMutationId;
    final l$dismissesStaleReviews = dismissesStaleReviews;
    final l$isAdminEnforced = isAdminEnforced;
    final l$lockAllowsFetchAndMerge = lockAllowsFetchAndMerge;
    final l$lockBranch = lockBranch;
    final l$pattern = pattern;
    final l$pushActorIds = pushActorIds;
    final l$requireLastPushApproval = requireLastPushApproval;
    final l$requiredApprovingReviewCount = requiredApprovingReviewCount;
    final l$requiredDeploymentEnvironments = requiredDeploymentEnvironments;
    final l$requiredStatusCheckContexts = requiredStatusCheckContexts;
    final l$requiredStatusChecks = requiredStatusChecks;
    final l$requiresApprovingReviews = requiresApprovingReviews;
    final l$requiresCodeOwnerReviews = requiresCodeOwnerReviews;
    final l$requiresCommitSignatures = requiresCommitSignatures;
    final l$requiresConversationResolution = requiresConversationResolution;
    final l$requiresDeployments = requiresDeployments;
    final l$requiresLinearHistory = requiresLinearHistory;
    final l$requiresStatusChecks = requiresStatusChecks;
    final l$requiresStrictStatusChecks = requiresStrictStatusChecks;
    final l$restrictsPushes = restrictsPushes;
    final l$restrictsReviewDismissals = restrictsReviewDismissals;
    final l$reviewDismissalActorIds = reviewDismissalActorIds;
    return Object.hashAll([
      _$data.containsKey('allowsDeletions') ? l$allowsDeletions : const {},
      _$data.containsKey('allowsForcePushes') ? l$allowsForcePushes : const {},
      _$data.containsKey('blocksCreations') ? l$blocksCreations : const {},
      l$branchProtectionRuleId,
      _$data.containsKey('bypassForcePushActorIds')
          ? l$bypassForcePushActorIds == null
              ? null
              : Object.hashAll(l$bypassForcePushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('bypassPullRequestActorIds')
          ? l$bypassPullRequestActorIds == null
              ? null
              : Object.hashAll(l$bypassPullRequestActorIds.map((v) => v))
          : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('dismissesStaleReviews')
          ? l$dismissesStaleReviews
          : const {},
      _$data.containsKey('isAdminEnforced') ? l$isAdminEnforced : const {},
      _$data.containsKey('lockAllowsFetchAndMerge')
          ? l$lockAllowsFetchAndMerge
          : const {},
      _$data.containsKey('lockBranch') ? l$lockBranch : const {},
      _$data.containsKey('pattern') ? l$pattern : const {},
      _$data.containsKey('pushActorIds')
          ? l$pushActorIds == null
              ? null
              : Object.hashAll(l$pushActorIds.map((v) => v))
          : const {},
      _$data.containsKey('requireLastPushApproval')
          ? l$requireLastPushApproval
          : const {},
      _$data.containsKey('requiredApprovingReviewCount')
          ? l$requiredApprovingReviewCount
          : const {},
      _$data.containsKey('requiredDeploymentEnvironments')
          ? l$requiredDeploymentEnvironments == null
              ? null
              : Object.hashAll(l$requiredDeploymentEnvironments.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusCheckContexts')
          ? l$requiredStatusCheckContexts == null
              ? null
              : Object.hashAll(l$requiredStatusCheckContexts.map((v) => v))
          : const {},
      _$data.containsKey('requiredStatusChecks')
          ? l$requiredStatusChecks == null
              ? null
              : Object.hashAll(l$requiredStatusChecks.map((v) => v))
          : const {},
      _$data.containsKey('requiresApprovingReviews')
          ? l$requiresApprovingReviews
          : const {},
      _$data.containsKey('requiresCodeOwnerReviews')
          ? l$requiresCodeOwnerReviews
          : const {},
      _$data.containsKey('requiresCommitSignatures')
          ? l$requiresCommitSignatures
          : const {},
      _$data.containsKey('requiresConversationResolution')
          ? l$requiresConversationResolution
          : const {},
      _$data.containsKey('requiresDeployments')
          ? l$requiresDeployments
          : const {},
      _$data.containsKey('requiresLinearHistory')
          ? l$requiresLinearHistory
          : const {},
      _$data.containsKey('requiresStatusChecks')
          ? l$requiresStatusChecks
          : const {},
      _$data.containsKey('requiresStrictStatusChecks')
          ? l$requiresStrictStatusChecks
          : const {},
      _$data.containsKey('restrictsPushes') ? l$restrictsPushes : const {},
      _$data.containsKey('restrictsReviewDismissals')
          ? l$restrictsReviewDismissals
          : const {},
      _$data.containsKey('reviewDismissalActorIds')
          ? l$reviewDismissalActorIds == null
              ? null
              : Object.hashAll(l$reviewDismissalActorIds.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  factory CopyWith$Input$UpdateBranchProtectionRuleInput(
    Input$UpdateBranchProtectionRuleInput instance,
    TRes Function(Input$UpdateBranchProtectionRuleInput) then,
  ) = _CopyWithImpl$Input$UpdateBranchProtectionRuleInput;

  factory CopyWith$Input$UpdateBranchProtectionRuleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput;

  TRes call({
    bool? allowsDeletions,
    bool? allowsForcePushes,
    bool? blocksCreations,
    String? branchProtectionRuleId,
    List<String>? bypassForcePushActorIds,
    List<String>? bypassPullRequestActorIds,
    String? clientMutationId,
    bool? dismissesStaleReviews,
    bool? isAdminEnforced,
    bool? lockAllowsFetchAndMerge,
    bool? lockBranch,
    String? pattern,
    List<String>? pushActorIds,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    List<String>? requiredDeploymentEnvironments,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresApprovingReviews,
    bool? requiresCodeOwnerReviews,
    bool? requiresCommitSignatures,
    bool? requiresConversationResolution,
    bool? requiresDeployments,
    bool? requiresLinearHistory,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? restrictsPushes,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
  });
  TRes requiredStatusChecks(
      Iterable<Input$RequiredStatusCheckInput>? Function(
              Iterable<
                  CopyWith$Input$RequiredStatusCheckInput<
                      Input$RequiredStatusCheckInput>>?)
          _fn);
}

class _CopyWithImpl$Input$UpdateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  _CopyWithImpl$Input$UpdateBranchProtectionRuleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateBranchProtectionRuleInput _instance;

  final TRes Function(Input$UpdateBranchProtectionRuleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? allowsDeletions = _undefined,
    Object? allowsForcePushes = _undefined,
    Object? blocksCreations = _undefined,
    Object? branchProtectionRuleId = _undefined,
    Object? bypassForcePushActorIds = _undefined,
    Object? bypassPullRequestActorIds = _undefined,
    Object? clientMutationId = _undefined,
    Object? dismissesStaleReviews = _undefined,
    Object? isAdminEnforced = _undefined,
    Object? lockAllowsFetchAndMerge = _undefined,
    Object? lockBranch = _undefined,
    Object? pattern = _undefined,
    Object? pushActorIds = _undefined,
    Object? requireLastPushApproval = _undefined,
    Object? requiredApprovingReviewCount = _undefined,
    Object? requiredDeploymentEnvironments = _undefined,
    Object? requiredStatusCheckContexts = _undefined,
    Object? requiredStatusChecks = _undefined,
    Object? requiresApprovingReviews = _undefined,
    Object? requiresCodeOwnerReviews = _undefined,
    Object? requiresCommitSignatures = _undefined,
    Object? requiresConversationResolution = _undefined,
    Object? requiresDeployments = _undefined,
    Object? requiresLinearHistory = _undefined,
    Object? requiresStatusChecks = _undefined,
    Object? requiresStrictStatusChecks = _undefined,
    Object? restrictsPushes = _undefined,
    Object? restrictsReviewDismissals = _undefined,
    Object? reviewDismissalActorIds = _undefined,
  }) =>
      _then(Input$UpdateBranchProtectionRuleInput._({
        ..._instance._$data,
        if (allowsDeletions != _undefined)
          'allowsDeletions': (allowsDeletions as bool?),
        if (allowsForcePushes != _undefined)
          'allowsForcePushes': (allowsForcePushes as bool?),
        if (blocksCreations != _undefined)
          'blocksCreations': (blocksCreations as bool?),
        if (branchProtectionRuleId != _undefined &&
            branchProtectionRuleId != null)
          'branchProtectionRuleId': (branchProtectionRuleId as String),
        if (bypassForcePushActorIds != _undefined)
          'bypassForcePushActorIds': (bypassForcePushActorIds as List<String>?),
        if (bypassPullRequestActorIds != _undefined)
          'bypassPullRequestActorIds':
              (bypassPullRequestActorIds as List<String>?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (dismissesStaleReviews != _undefined)
          'dismissesStaleReviews': (dismissesStaleReviews as bool?),
        if (isAdminEnforced != _undefined)
          'isAdminEnforced': (isAdminEnforced as bool?),
        if (lockAllowsFetchAndMerge != _undefined)
          'lockAllowsFetchAndMerge': (lockAllowsFetchAndMerge as bool?),
        if (lockBranch != _undefined) 'lockBranch': (lockBranch as bool?),
        if (pattern != _undefined) 'pattern': (pattern as String?),
        if (pushActorIds != _undefined)
          'pushActorIds': (pushActorIds as List<String>?),
        if (requireLastPushApproval != _undefined)
          'requireLastPushApproval': (requireLastPushApproval as bool?),
        if (requiredApprovingReviewCount != _undefined)
          'requiredApprovingReviewCount':
              (requiredApprovingReviewCount as int?),
        if (requiredDeploymentEnvironments != _undefined)
          'requiredDeploymentEnvironments':
              (requiredDeploymentEnvironments as List<String>?),
        if (requiredStatusCheckContexts != _undefined)
          'requiredStatusCheckContexts':
              (requiredStatusCheckContexts as List<String>?),
        if (requiredStatusChecks != _undefined)
          'requiredStatusChecks':
              (requiredStatusChecks as List<Input$RequiredStatusCheckInput>?),
        if (requiresApprovingReviews != _undefined)
          'requiresApprovingReviews': (requiresApprovingReviews as bool?),
        if (requiresCodeOwnerReviews != _undefined)
          'requiresCodeOwnerReviews': (requiresCodeOwnerReviews as bool?),
        if (requiresCommitSignatures != _undefined)
          'requiresCommitSignatures': (requiresCommitSignatures as bool?),
        if (requiresConversationResolution != _undefined)
          'requiresConversationResolution':
              (requiresConversationResolution as bool?),
        if (requiresDeployments != _undefined)
          'requiresDeployments': (requiresDeployments as bool?),
        if (requiresLinearHistory != _undefined)
          'requiresLinearHistory': (requiresLinearHistory as bool?),
        if (requiresStatusChecks != _undefined)
          'requiresStatusChecks': (requiresStatusChecks as bool?),
        if (requiresStrictStatusChecks != _undefined)
          'requiresStrictStatusChecks': (requiresStrictStatusChecks as bool?),
        if (restrictsPushes != _undefined)
          'restrictsPushes': (restrictsPushes as bool?),
        if (restrictsReviewDismissals != _undefined)
          'restrictsReviewDismissals': (restrictsReviewDismissals as bool?),
        if (reviewDismissalActorIds != _undefined)
          'reviewDismissalActorIds': (reviewDismissalActorIds as List<String>?),
      }));
  TRes requiredStatusChecks(
          Iterable<Input$RequiredStatusCheckInput>? Function(
                  Iterable<
                      CopyWith$Input$RequiredStatusCheckInput<
                          Input$RequiredStatusCheckInput>>?)
              _fn) =>
      call(
          requiredStatusChecks: _fn(_instance.requiredStatusChecks
              ?.map((e) => CopyWith$Input$RequiredStatusCheckInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput<TRes>
    implements CopyWith$Input$UpdateBranchProtectionRuleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateBranchProtectionRuleInput(this._res);

  TRes _res;

  call({
    bool? allowsDeletions,
    bool? allowsForcePushes,
    bool? blocksCreations,
    String? branchProtectionRuleId,
    List<String>? bypassForcePushActorIds,
    List<String>? bypassPullRequestActorIds,
    String? clientMutationId,
    bool? dismissesStaleReviews,
    bool? isAdminEnforced,
    bool? lockAllowsFetchAndMerge,
    bool? lockBranch,
    String? pattern,
    List<String>? pushActorIds,
    bool? requireLastPushApproval,
    int? requiredApprovingReviewCount,
    List<String>? requiredDeploymentEnvironments,
    List<String>? requiredStatusCheckContexts,
    List<Input$RequiredStatusCheckInput>? requiredStatusChecks,
    bool? requiresApprovingReviews,
    bool? requiresCodeOwnerReviews,
    bool? requiresCommitSignatures,
    bool? requiresConversationResolution,
    bool? requiresDeployments,
    bool? requiresLinearHistory,
    bool? requiresStatusChecks,
    bool? requiresStrictStatusChecks,
    bool? restrictsPushes,
    bool? restrictsReviewDismissals,
    List<String>? reviewDismissalActorIds,
  }) =>
      _res;
  requiredStatusChecks(_fn) => _res;
}

class Input$UpdateCheckRunInput {
  factory Input$UpdateCheckRunInput({
    List<Input$CheckRunAction>? actions,
    required String checkRunId,
    String? clientMutationId,
    DateTime? completedAt,
    Enum$CheckConclusionState? conclusion,
    String? detailsUrl,
    String? externalId,
    String? name,
    Input$CheckRunOutput? output,
    required String repositoryId,
    DateTime? startedAt,
    Enum$RequestableCheckStatusState? status,
  }) =>
      Input$UpdateCheckRunInput._({
        if (actions != null) r'actions': actions,
        r'checkRunId': checkRunId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (completedAt != null) r'completedAt': completedAt,
        if (conclusion != null) r'conclusion': conclusion,
        if (detailsUrl != null) r'detailsUrl': detailsUrl,
        if (externalId != null) r'externalId': externalId,
        if (name != null) r'name': name,
        if (output != null) r'output': output,
        r'repositoryId': repositoryId,
        if (startedAt != null) r'startedAt': startedAt,
        if (status != null) r'status': status,
      });

  Input$UpdateCheckRunInput._(this._$data);

  factory Input$UpdateCheckRunInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('actions')) {
      final l$actions = data['actions'];
      result$data['actions'] = (l$actions as List<dynamic>?)
          ?.map(
              (e) => Input$CheckRunAction.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    final l$checkRunId = data['checkRunId'];
    result$data['checkRunId'] = (l$checkRunId as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('completedAt')) {
      final l$completedAt = data['completedAt'];
      result$data['completedAt'] = l$completedAt == null
          ? null
          : DateTime.parse((l$completedAt as String));
    }
    if (data.containsKey('conclusion')) {
      final l$conclusion = data['conclusion'];
      result$data['conclusion'] = l$conclusion == null
          ? null
          : fromJson$Enum$CheckConclusionState((l$conclusion as String));
    }
    if (data.containsKey('detailsUrl')) {
      final l$detailsUrl = data['detailsUrl'];
      result$data['detailsUrl'] = (l$detailsUrl as String?);
    }
    if (data.containsKey('externalId')) {
      final l$externalId = data['externalId'];
      result$data['externalId'] = (l$externalId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('output')) {
      final l$output = data['output'];
      result$data['output'] = l$output == null
          ? null
          : Input$CheckRunOutput.fromJson((l$output as Map<String, dynamic>));
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('startedAt')) {
      final l$startedAt = data['startedAt'];
      result$data['startedAt'] =
          l$startedAt == null ? null : DateTime.parse((l$startedAt as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : fromJson$Enum$RequestableCheckStatusState((l$status as String));
    }
    return Input$UpdateCheckRunInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CheckRunAction>? get actions =>
      (_$data['actions'] as List<Input$CheckRunAction>?);
  String get checkRunId => (_$data['checkRunId'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  DateTime? get completedAt => (_$data['completedAt'] as DateTime?);
  Enum$CheckConclusionState? get conclusion =>
      (_$data['conclusion'] as Enum$CheckConclusionState?);
  String? get detailsUrl => (_$data['detailsUrl'] as String?);
  String? get externalId => (_$data['externalId'] as String?);
  String? get name => (_$data['name'] as String?);
  Input$CheckRunOutput? get output =>
      (_$data['output'] as Input$CheckRunOutput?);
  String get repositoryId => (_$data['repositoryId'] as String);
  DateTime? get startedAt => (_$data['startedAt'] as DateTime?);
  Enum$RequestableCheckStatusState? get status =>
      (_$data['status'] as Enum$RequestableCheckStatusState?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('actions')) {
      final l$actions = actions;
      result$data['actions'] = l$actions?.map((e) => e.toJson()).toList();
    }
    final l$checkRunId = checkRunId;
    result$data['checkRunId'] = l$checkRunId;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('completedAt')) {
      final l$completedAt = completedAt;
      result$data['completedAt'] = l$completedAt?.toIso8601String();
    }
    if (_$data.containsKey('conclusion')) {
      final l$conclusion = conclusion;
      result$data['conclusion'] = l$conclusion == null
          ? null
          : toJson$Enum$CheckConclusionState(l$conclusion);
    }
    if (_$data.containsKey('detailsUrl')) {
      final l$detailsUrl = detailsUrl;
      result$data['detailsUrl'] = l$detailsUrl;
    }
    if (_$data.containsKey('externalId')) {
      final l$externalId = externalId;
      result$data['externalId'] = l$externalId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('output')) {
      final l$output = output;
      result$data['output'] = l$output?.toJson();
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('startedAt')) {
      final l$startedAt = startedAt;
      result$data['startedAt'] = l$startedAt?.toIso8601String();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status == null
          ? null
          : toJson$Enum$RequestableCheckStatusState(l$status);
    }
    return result$data;
  }

  CopyWith$Input$UpdateCheckRunInput<Input$UpdateCheckRunInput> get copyWith =>
      CopyWith$Input$UpdateCheckRunInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateCheckRunInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$actions = actions;
    final lOther$actions = other.actions;
    if (_$data.containsKey('actions') != other._$data.containsKey('actions')) {
      return false;
    }
    if (l$actions != null && lOther$actions != null) {
      if (l$actions.length != lOther$actions.length) {
        return false;
      }
      for (int i = 0; i < l$actions.length; i++) {
        final l$actions$entry = l$actions[i];
        final lOther$actions$entry = lOther$actions[i];
        if (l$actions$entry != lOther$actions$entry) {
          return false;
        }
      }
    } else if (l$actions != lOther$actions) {
      return false;
    }
    final l$checkRunId = checkRunId;
    final lOther$checkRunId = other.checkRunId;
    if (l$checkRunId != lOther$checkRunId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$completedAt = completedAt;
    final lOther$completedAt = other.completedAt;
    if (_$data.containsKey('completedAt') !=
        other._$data.containsKey('completedAt')) {
      return false;
    }
    if (l$completedAt != lOther$completedAt) {
      return false;
    }
    final l$conclusion = conclusion;
    final lOther$conclusion = other.conclusion;
    if (_$data.containsKey('conclusion') !=
        other._$data.containsKey('conclusion')) {
      return false;
    }
    if (l$conclusion != lOther$conclusion) {
      return false;
    }
    final l$detailsUrl = detailsUrl;
    final lOther$detailsUrl = other.detailsUrl;
    if (_$data.containsKey('detailsUrl') !=
        other._$data.containsKey('detailsUrl')) {
      return false;
    }
    if (l$detailsUrl != lOther$detailsUrl) {
      return false;
    }
    final l$externalId = externalId;
    final lOther$externalId = other.externalId;
    if (_$data.containsKey('externalId') !=
        other._$data.containsKey('externalId')) {
      return false;
    }
    if (l$externalId != lOther$externalId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$output = output;
    final lOther$output = other.output;
    if (_$data.containsKey('output') != other._$data.containsKey('output')) {
      return false;
    }
    if (l$output != lOther$output) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$startedAt = startedAt;
    final lOther$startedAt = other.startedAt;
    if (_$data.containsKey('startedAt') !=
        other._$data.containsKey('startedAt')) {
      return false;
    }
    if (l$startedAt != lOther$startedAt) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$actions = actions;
    final l$checkRunId = checkRunId;
    final l$clientMutationId = clientMutationId;
    final l$completedAt = completedAt;
    final l$conclusion = conclusion;
    final l$detailsUrl = detailsUrl;
    final l$externalId = externalId;
    final l$name = name;
    final l$output = output;
    final l$repositoryId = repositoryId;
    final l$startedAt = startedAt;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('actions')
          ? l$actions == null
              ? null
              : Object.hashAll(l$actions.map((v) => v))
          : const {},
      l$checkRunId,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('completedAt') ? l$completedAt : const {},
      _$data.containsKey('conclusion') ? l$conclusion : const {},
      _$data.containsKey('detailsUrl') ? l$detailsUrl : const {},
      _$data.containsKey('externalId') ? l$externalId : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('output') ? l$output : const {},
      l$repositoryId,
      _$data.containsKey('startedAt') ? l$startedAt : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateCheckRunInput<TRes> {
  factory CopyWith$Input$UpdateCheckRunInput(
    Input$UpdateCheckRunInput instance,
    TRes Function(Input$UpdateCheckRunInput) then,
  ) = _CopyWithImpl$Input$UpdateCheckRunInput;

  factory CopyWith$Input$UpdateCheckRunInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCheckRunInput;

  TRes call({
    List<Input$CheckRunAction>? actions,
    String? checkRunId,
    String? clientMutationId,
    DateTime? completedAt,
    Enum$CheckConclusionState? conclusion,
    String? detailsUrl,
    String? externalId,
    String? name,
    Input$CheckRunOutput? output,
    String? repositoryId,
    DateTime? startedAt,
    Enum$RequestableCheckStatusState? status,
  });
  TRes actions(
      Iterable<Input$CheckRunAction>? Function(
              Iterable<CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
          _fn);
  CopyWith$Input$CheckRunOutput<TRes> get output;
}

class _CopyWithImpl$Input$UpdateCheckRunInput<TRes>
    implements CopyWith$Input$UpdateCheckRunInput<TRes> {
  _CopyWithImpl$Input$UpdateCheckRunInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCheckRunInput _instance;

  final TRes Function(Input$UpdateCheckRunInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? actions = _undefined,
    Object? checkRunId = _undefined,
    Object? clientMutationId = _undefined,
    Object? completedAt = _undefined,
    Object? conclusion = _undefined,
    Object? detailsUrl = _undefined,
    Object? externalId = _undefined,
    Object? name = _undefined,
    Object? output = _undefined,
    Object? repositoryId = _undefined,
    Object? startedAt = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$UpdateCheckRunInput._({
        ..._instance._$data,
        if (actions != _undefined)
          'actions': (actions as List<Input$CheckRunAction>?),
        if (checkRunId != _undefined && checkRunId != null)
          'checkRunId': (checkRunId as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (completedAt != _undefined)
          'completedAt': (completedAt as DateTime?),
        if (conclusion != _undefined)
          'conclusion': (conclusion as Enum$CheckConclusionState?),
        if (detailsUrl != _undefined) 'detailsUrl': (detailsUrl as String?),
        if (externalId != _undefined) 'externalId': (externalId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (output != _undefined) 'output': (output as Input$CheckRunOutput?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (startedAt != _undefined) 'startedAt': (startedAt as DateTime?),
        if (status != _undefined)
          'status': (status as Enum$RequestableCheckStatusState?),
      }));
  TRes actions(
          Iterable<Input$CheckRunAction>? Function(
                  Iterable<
                      CopyWith$Input$CheckRunAction<Input$CheckRunAction>>?)
              _fn) =>
      call(
          actions:
              _fn(_instance.actions?.map((e) => CopyWith$Input$CheckRunAction(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$CheckRunOutput<TRes> get output {
    final local$output = _instance.output;
    return local$output == null
        ? CopyWith$Input$CheckRunOutput.stub(_then(_instance))
        : CopyWith$Input$CheckRunOutput(local$output, (e) => call(output: e));
  }
}

class _CopyWithStubImpl$Input$UpdateCheckRunInput<TRes>
    implements CopyWith$Input$UpdateCheckRunInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCheckRunInput(this._res);

  TRes _res;

  call({
    List<Input$CheckRunAction>? actions,
    String? checkRunId,
    String? clientMutationId,
    DateTime? completedAt,
    Enum$CheckConclusionState? conclusion,
    String? detailsUrl,
    String? externalId,
    String? name,
    Input$CheckRunOutput? output,
    String? repositoryId,
    DateTime? startedAt,
    Enum$RequestableCheckStatusState? status,
  }) =>
      _res;
  actions(_fn) => _res;
  CopyWith$Input$CheckRunOutput<TRes> get output =>
      CopyWith$Input$CheckRunOutput.stub(_res);
}

class Input$UpdateCheckSuitePreferencesInput {
  factory Input$UpdateCheckSuitePreferencesInput({
    required List<Input$CheckSuiteAutoTriggerPreference> autoTriggerPreferences,
    String? clientMutationId,
    required String repositoryId,
  }) =>
      Input$UpdateCheckSuitePreferencesInput._({
        r'autoTriggerPreferences': autoTriggerPreferences,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
      });

  Input$UpdateCheckSuitePreferencesInput._(this._$data);

  factory Input$UpdateCheckSuitePreferencesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$autoTriggerPreferences = data['autoTriggerPreferences'];
    result$data['autoTriggerPreferences'] =
        (l$autoTriggerPreferences as List<dynamic>)
            .map((e) => Input$CheckSuiteAutoTriggerPreference.fromJson(
                (e as Map<String, dynamic>)))
            .toList();
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UpdateCheckSuitePreferencesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CheckSuiteAutoTriggerPreference> get autoTriggerPreferences =>
      (_$data['autoTriggerPreferences']
          as List<Input$CheckSuiteAutoTriggerPreference>);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$autoTriggerPreferences = autoTriggerPreferences;
    result$data['autoTriggerPreferences'] =
        l$autoTriggerPreferences.map((e) => e.toJson()).toList();
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UpdateCheckSuitePreferencesInput<
          Input$UpdateCheckSuitePreferencesInput>
      get copyWith => CopyWith$Input$UpdateCheckSuitePreferencesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateCheckSuitePreferencesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$autoTriggerPreferences = autoTriggerPreferences;
    final lOther$autoTriggerPreferences = other.autoTriggerPreferences;
    if (l$autoTriggerPreferences.length !=
        lOther$autoTriggerPreferences.length) {
      return false;
    }
    for (int i = 0; i < l$autoTriggerPreferences.length; i++) {
      final l$autoTriggerPreferences$entry = l$autoTriggerPreferences[i];
      final lOther$autoTriggerPreferences$entry =
          lOther$autoTriggerPreferences[i];
      if (l$autoTriggerPreferences$entry !=
          lOther$autoTriggerPreferences$entry) {
        return false;
      }
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$autoTriggerPreferences = autoTriggerPreferences;
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      Object.hashAll(l$autoTriggerPreferences.map((v) => v)),
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  factory CopyWith$Input$UpdateCheckSuitePreferencesInput(
    Input$UpdateCheckSuitePreferencesInput instance,
    TRes Function(Input$UpdateCheckSuitePreferencesInput) then,
  ) = _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput;

  factory CopyWith$Input$UpdateCheckSuitePreferencesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput;

  TRes call({
    List<Input$CheckSuiteAutoTriggerPreference>? autoTriggerPreferences,
    String? clientMutationId,
    String? repositoryId,
  });
  TRes autoTriggerPreferences(
      Iterable<Input$CheckSuiteAutoTriggerPreference> Function(
              Iterable<
                  CopyWith$Input$CheckSuiteAutoTriggerPreference<
                      Input$CheckSuiteAutoTriggerPreference>>)
          _fn);
}

class _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput<TRes>
    implements CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  _CopyWithImpl$Input$UpdateCheckSuitePreferencesInput(
    this._instance,
    this._then,
  );

  final Input$UpdateCheckSuitePreferencesInput _instance;

  final TRes Function(Input$UpdateCheckSuitePreferencesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? autoTriggerPreferences = _undefined,
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UpdateCheckSuitePreferencesInput._({
        ..._instance._$data,
        if (autoTriggerPreferences != _undefined &&
            autoTriggerPreferences != null)
          'autoTriggerPreferences': (autoTriggerPreferences
              as List<Input$CheckSuiteAutoTriggerPreference>),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
  TRes autoTriggerPreferences(
          Iterable<Input$CheckSuiteAutoTriggerPreference> Function(
                  Iterable<
                      CopyWith$Input$CheckSuiteAutoTriggerPreference<
                          Input$CheckSuiteAutoTriggerPreference>>)
              _fn) =>
      call(
          autoTriggerPreferences: _fn(_instance.autoTriggerPreferences
              .map((e) => CopyWith$Input$CheckSuiteAutoTriggerPreference(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput<TRes>
    implements CopyWith$Input$UpdateCheckSuitePreferencesInput<TRes> {
  _CopyWithStubImpl$Input$UpdateCheckSuitePreferencesInput(this._res);

  TRes _res;

  call({
    List<Input$CheckSuiteAutoTriggerPreference>? autoTriggerPreferences,
    String? clientMutationId,
    String? repositoryId,
  }) =>
      _res;
  autoTriggerPreferences(_fn) => _res;
}

class Input$UpdateDiscussionCommentInput {
  factory Input$UpdateDiscussionCommentInput({
    required String body,
    String? clientMutationId,
    required String commentId,
  }) =>
      Input$UpdateDiscussionCommentInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'commentId': commentId,
      });

  Input$UpdateDiscussionCommentInput._(this._$data);

  factory Input$UpdateDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$commentId = data['commentId'];
    result$data['commentId'] = (l$commentId as String);
    return Input$UpdateDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get commentId => (_$data['commentId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$commentId = commentId;
    result$data['commentId'] = l$commentId;
    return result$data;
  }

  CopyWith$Input$UpdateDiscussionCommentInput<
          Input$UpdateDiscussionCommentInput>
      get copyWith => CopyWith$Input$UpdateDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$commentId = commentId;
    final lOther$commentId = other.commentId;
    if (l$commentId != lOther$commentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$commentId = commentId;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$commentId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  factory CopyWith$Input$UpdateDiscussionCommentInput(
    Input$UpdateDiscussionCommentInput instance,
    TRes Function(Input$UpdateDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateDiscussionCommentInput;

  factory CopyWith$Input$UpdateDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDiscussionCommentInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? commentId,
  });
}

class _CopyWithImpl$Input$UpdateDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDiscussionCommentInput _instance;

  final TRes Function(Input$UpdateDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? commentId = _undefined,
  }) =>
      _then(Input$UpdateDiscussionCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (commentId != _undefined && commentId != null)
          'commentId': (commentId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? commentId,
  }) =>
      _res;
}

class Input$UpdateDiscussionInput {
  factory Input$UpdateDiscussionInput({
    String? body,
    String? categoryId,
    String? clientMutationId,
    required String discussionId,
    String? title,
  }) =>
      Input$UpdateDiscussionInput._({
        if (body != null) r'body': body,
        if (categoryId != null) r'categoryId': categoryId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'discussionId': discussionId,
        if (title != null) r'title': title,
      });

  Input$UpdateDiscussionInput._(this._$data);

  factory Input$UpdateDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('categoryId')) {
      final l$categoryId = data['categoryId'];
      result$data['categoryId'] = (l$categoryId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$discussionId = data['discussionId'];
    result$data['discussionId'] = (l$discussionId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$UpdateDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get categoryId => (_$data['categoryId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get discussionId => (_$data['discussionId'] as String);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('categoryId')) {
      final l$categoryId = categoryId;
      result$data['categoryId'] = l$categoryId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$discussionId = discussionId;
    result$data['discussionId'] = l$discussionId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$UpdateDiscussionInput<Input$UpdateDiscussionInput>
      get copyWith => CopyWith$Input$UpdateDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$categoryId = categoryId;
    final lOther$categoryId = other.categoryId;
    if (_$data.containsKey('categoryId') !=
        other._$data.containsKey('categoryId')) {
      return false;
    }
    if (l$categoryId != lOther$categoryId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$discussionId = discussionId;
    final lOther$discussionId = other.discussionId;
    if (l$discussionId != lOther$discussionId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$categoryId = categoryId;
    final l$clientMutationId = clientMutationId;
    final l$discussionId = discussionId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('categoryId') ? l$categoryId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$discussionId,
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateDiscussionInput<TRes> {
  factory CopyWith$Input$UpdateDiscussionInput(
    Input$UpdateDiscussionInput instance,
    TRes Function(Input$UpdateDiscussionInput) then,
  ) = _CopyWithImpl$Input$UpdateDiscussionInput;

  factory CopyWith$Input$UpdateDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateDiscussionInput;

  TRes call({
    String? body,
    String? categoryId,
    String? clientMutationId,
    String? discussionId,
    String? title,
  });
}

class _CopyWithImpl$Input$UpdateDiscussionInput<TRes>
    implements CopyWith$Input$UpdateDiscussionInput<TRes> {
  _CopyWithImpl$Input$UpdateDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateDiscussionInput _instance;

  final TRes Function(Input$UpdateDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? categoryId = _undefined,
    Object? clientMutationId = _undefined,
    Object? discussionId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$UpdateDiscussionInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (categoryId != _undefined) 'categoryId': (categoryId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (discussionId != _undefined && discussionId != null)
          'discussionId': (discussionId as String),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateDiscussionInput<TRes>
    implements CopyWith$Input$UpdateDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateDiscussionInput(this._res);

  TRes _res;

  call({
    String? body,
    String? categoryId,
    String? clientMutationId,
    String? discussionId,
    String? title,
  }) =>
      _res;
}

class Input$UpdateEnterpriseAdministratorRoleInput {
  factory Input$UpdateEnterpriseAdministratorRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String login,
    required Enum$EnterpriseAdministratorRole role,
  }) =>
      Input$UpdateEnterpriseAdministratorRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'login': login,
        r'role': role,
      });

  Input$UpdateEnterpriseAdministratorRoleInput._(this._$data);

  factory Input$UpdateEnterpriseAdministratorRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$login = data['login'];
    result$data['login'] = (l$login as String);
    final l$role = data['role'];
    result$data['role'] =
        fromJson$Enum$EnterpriseAdministratorRole((l$role as String));
    return Input$UpdateEnterpriseAdministratorRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get login => (_$data['login'] as String);
  Enum$EnterpriseAdministratorRole get role =>
      (_$data['role'] as Enum$EnterpriseAdministratorRole);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$login = login;
    result$data['login'] = l$login;
    final l$role = role;
    result$data['role'] = toJson$Enum$EnterpriseAdministratorRole(l$role);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<
          Input$UpdateEnterpriseAdministratorRoleInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseAdministratorRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseAdministratorRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$login = login;
    final lOther$login = other.login;
    if (l$login != lOther$login) {
      return false;
    }
    final l$role = role;
    final lOther$role = other.role;
    if (l$role != lOther$role) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$login = login;
    final l$role = role;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$login,
      l$role,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseAdministratorRoleInput(
    Input$UpdateEnterpriseAdministratorRoleInput instance,
    TRes Function(Input$UpdateEnterpriseAdministratorRoleInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput;

  factory CopyWith$Input$UpdateEnterpriseAdministratorRoleInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    Enum$EnterpriseAdministratorRole? role,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseAdministratorRoleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseAdministratorRoleInput _instance;

  final TRes Function(Input$UpdateEnterpriseAdministratorRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? login = _undefined,
    Object? role = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseAdministratorRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (login != _undefined && login != null) 'login': (login as String),
        if (role != _undefined && role != null)
          'role': (role as Enum$EnterpriseAdministratorRole),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseAdministratorRoleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseAdministratorRoleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? login,
    Enum$EnterpriseAdministratorRole? role,
  }) =>
      _res;
}

class Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  factory Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        if (policyValue != null) r'policyValue': policyValue,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('policyValue')) {
      final l$policyValue = data['policyValue'];
      result$data['policyValue'] = l$policyValue == null
          ? null
          : fromJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
              (l$policyValue as String));
    }
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? get policyValue =>
      (_$data['policyValue']
          as Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue?);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('policyValue')) {
      final l$policyValue = policyValue;
      result$data['policyValue'] = l$policyValue == null
          ? null
          : toJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
              l$policyValue);
    }
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
          Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$policyValue = policyValue;
    final lOther$policyValue = other.policyValue;
    if (_$data.containsKey('policyValue') !=
        other._$data.containsKey('policyValue')) {
      return false;
    }
    if (l$policyValue != lOther$policyValue) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$policyValue = policyValue;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      _$data.containsKey('policyValue') ? l$policyValue : const {},
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
    Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;

  factory CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? policyValue = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (policyValue != _undefined)
          'policyValue': (policyValue
              as Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue?),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue? policyValue,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  factory Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseDefaultRepositoryPermissionSettingValue
        settingValue,
  }) =>
      Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._(this._$data);

  factory Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseDefaultRepositoryPermissionSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseDefaultRepositoryPermissionSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
            l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
          Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
    Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput instance,
    TRes Function(Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput;

  factory CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput _instance;

  final TRes Function(
      Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$EnterpriseDefaultRepositoryPermissionSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseDefaultRepositoryPermissionSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  factory Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
    Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
        instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
      _instance;

  final TRes Function(
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
              ._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  factory Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    bool? membersCanCreateInternalRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        if (membersCanCreateInternalRepositories != null)
          r'membersCanCreateInternalRepositories':
              membersCanCreateInternalRepositories,
        if (membersCanCreatePrivateRepositories != null)
          r'membersCanCreatePrivateRepositories':
              membersCanCreatePrivateRepositories,
        if (membersCanCreatePublicRepositories != null)
          r'membersCanCreatePublicRepositories':
              membersCanCreatePublicRepositories,
        if (membersCanCreateRepositoriesPolicyEnabled != null)
          r'membersCanCreateRepositoriesPolicyEnabled':
              membersCanCreateRepositoriesPolicyEnabled,
        if (settingValue != null) r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('membersCanCreateInternalRepositories')) {
      final l$membersCanCreateInternalRepositories =
          data['membersCanCreateInternalRepositories'];
      result$data['membersCanCreateInternalRepositories'] =
          (l$membersCanCreateInternalRepositories as bool?);
    }
    if (data.containsKey('membersCanCreatePrivateRepositories')) {
      final l$membersCanCreatePrivateRepositories =
          data['membersCanCreatePrivateRepositories'];
      result$data['membersCanCreatePrivateRepositories'] =
          (l$membersCanCreatePrivateRepositories as bool?);
    }
    if (data.containsKey('membersCanCreatePublicRepositories')) {
      final l$membersCanCreatePublicRepositories =
          data['membersCanCreatePublicRepositories'];
      result$data['membersCanCreatePublicRepositories'] =
          (l$membersCanCreatePublicRepositories as bool?);
    }
    if (data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      final l$membersCanCreateRepositoriesPolicyEnabled =
          data['membersCanCreateRepositoriesPolicyEnabled'];
      result$data['membersCanCreateRepositoriesPolicyEnabled'] =
          (l$membersCanCreateRepositoriesPolicyEnabled as bool?);
    }
    if (data.containsKey('settingValue')) {
      final l$settingValue = data['settingValue'];
      result$data['settingValue'] = l$settingValue == null
          ? null
          : fromJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
              (l$settingValue as String));
    }
    return Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  bool? get membersCanCreateInternalRepositories =>
      (_$data['membersCanCreateInternalRepositories'] as bool?);
  bool? get membersCanCreatePrivateRepositories =>
      (_$data['membersCanCreatePrivateRepositories'] as bool?);
  bool? get membersCanCreatePublicRepositories =>
      (_$data['membersCanCreatePublicRepositories'] as bool?);
  bool? get membersCanCreateRepositoriesPolicyEnabled =>
      (_$data['membersCanCreateRepositoriesPolicyEnabled'] as bool?);
  Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseMembersCanCreateRepositoriesSettingValue?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('membersCanCreateInternalRepositories')) {
      final l$membersCanCreateInternalRepositories =
          membersCanCreateInternalRepositories;
      result$data['membersCanCreateInternalRepositories'] =
          l$membersCanCreateInternalRepositories;
    }
    if (_$data.containsKey('membersCanCreatePrivateRepositories')) {
      final l$membersCanCreatePrivateRepositories =
          membersCanCreatePrivateRepositories;
      result$data['membersCanCreatePrivateRepositories'] =
          l$membersCanCreatePrivateRepositories;
    }
    if (_$data.containsKey('membersCanCreatePublicRepositories')) {
      final l$membersCanCreatePublicRepositories =
          membersCanCreatePublicRepositories;
      result$data['membersCanCreatePublicRepositories'] =
          l$membersCanCreatePublicRepositories;
    }
    if (_$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      final l$membersCanCreateRepositoriesPolicyEnabled =
          membersCanCreateRepositoriesPolicyEnabled;
      result$data['membersCanCreateRepositoriesPolicyEnabled'] =
          l$membersCanCreateRepositoriesPolicyEnabled;
    }
    if (_$data.containsKey('settingValue')) {
      final l$settingValue = settingValue;
      result$data['settingValue'] = l$settingValue == null
          ? null
          : toJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
              l$settingValue);
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
          Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$membersCanCreateInternalRepositories =
        membersCanCreateInternalRepositories;
    final lOther$membersCanCreateInternalRepositories =
        other.membersCanCreateInternalRepositories;
    if (_$data.containsKey('membersCanCreateInternalRepositories') !=
        other._$data.containsKey('membersCanCreateInternalRepositories')) {
      return false;
    }
    if (l$membersCanCreateInternalRepositories !=
        lOther$membersCanCreateInternalRepositories) {
      return false;
    }
    final l$membersCanCreatePrivateRepositories =
        membersCanCreatePrivateRepositories;
    final lOther$membersCanCreatePrivateRepositories =
        other.membersCanCreatePrivateRepositories;
    if (_$data.containsKey('membersCanCreatePrivateRepositories') !=
        other._$data.containsKey('membersCanCreatePrivateRepositories')) {
      return false;
    }
    if (l$membersCanCreatePrivateRepositories !=
        lOther$membersCanCreatePrivateRepositories) {
      return false;
    }
    final l$membersCanCreatePublicRepositories =
        membersCanCreatePublicRepositories;
    final lOther$membersCanCreatePublicRepositories =
        other.membersCanCreatePublicRepositories;
    if (_$data.containsKey('membersCanCreatePublicRepositories') !=
        other._$data.containsKey('membersCanCreatePublicRepositories')) {
      return false;
    }
    if (l$membersCanCreatePublicRepositories !=
        lOther$membersCanCreatePublicRepositories) {
      return false;
    }
    final l$membersCanCreateRepositoriesPolicyEnabled =
        membersCanCreateRepositoriesPolicyEnabled;
    final lOther$membersCanCreateRepositoriesPolicyEnabled =
        other.membersCanCreateRepositoriesPolicyEnabled;
    if (_$data.containsKey('membersCanCreateRepositoriesPolicyEnabled') !=
        other._$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')) {
      return false;
    }
    if (l$membersCanCreateRepositoriesPolicyEnabled !=
        lOther$membersCanCreateRepositoriesPolicyEnabled) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (_$data.containsKey('settingValue') !=
        other._$data.containsKey('settingValue')) {
      return false;
    }
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$membersCanCreateInternalRepositories =
        membersCanCreateInternalRepositories;
    final l$membersCanCreatePrivateRepositories =
        membersCanCreatePrivateRepositories;
    final l$membersCanCreatePublicRepositories =
        membersCanCreatePublicRepositories;
    final l$membersCanCreateRepositoriesPolicyEnabled =
        membersCanCreateRepositoriesPolicyEnabled;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      _$data.containsKey('membersCanCreateInternalRepositories')
          ? l$membersCanCreateInternalRepositories
          : const {},
      _$data.containsKey('membersCanCreatePrivateRepositories')
          ? l$membersCanCreatePrivateRepositories
          : const {},
      _$data.containsKey('membersCanCreatePublicRepositories')
          ? l$membersCanCreatePublicRepositories
          : const {},
      _$data.containsKey('membersCanCreateRepositoriesPolicyEnabled')
          ? l$membersCanCreateRepositoriesPolicyEnabled
          : const {},
      _$data.containsKey('settingValue') ? l$settingValue : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
    Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    bool? membersCanCreateInternalRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? membersCanCreateInternalRepositories = _undefined,
    Object? membersCanCreatePrivateRepositories = _undefined,
    Object? membersCanCreatePublicRepositories = _undefined,
    Object? membersCanCreateRepositoriesPolicyEnabled = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (membersCanCreateInternalRepositories != _undefined)
          'membersCanCreateInternalRepositories':
              (membersCanCreateInternalRepositories as bool?),
        if (membersCanCreatePrivateRepositories != _undefined)
          'membersCanCreatePrivateRepositories':
              (membersCanCreatePrivateRepositories as bool?),
        if (membersCanCreatePublicRepositories != _undefined)
          'membersCanCreatePublicRepositories':
              (membersCanCreatePublicRepositories as bool?),
        if (membersCanCreateRepositoriesPolicyEnabled != _undefined)
          'membersCanCreateRepositoriesPolicyEnabled':
              (membersCanCreateRepositoriesPolicyEnabled as bool?),
        if (settingValue != _undefined)
          'settingValue': (settingValue
              as Enum$EnterpriseMembersCanCreateRepositoriesSettingValue?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanCreateRepositoriesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    bool? membersCanCreateInternalRepositories,
    bool? membersCanCreatePrivateRepositories,
    bool? membersCanCreatePublicRepositories,
    bool? membersCanCreateRepositoriesPolicyEnabled,
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  factory Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
          Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
    Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput instance,
    TRes Function(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteIssuesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  factory Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
          Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
    Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  factory Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
          Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
    Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  factory Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseMembersCanMakePurchasesSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._(this._$data);

  factory Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseMembersCanMakePurchasesSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$EnterpriseMembersCanMakePurchasesSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
            l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
          Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
    Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput instance,
    TRes Function(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseMembersCanMakePurchasesSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$EnterpriseMembersCanMakePurchasesSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanMakePurchasesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseMembersCanMakePurchasesSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  factory Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
          Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
    Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
        instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
      _instance;

  final TRes Function(
          Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
          ._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  factory Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
          Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
    Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseOrganizationProjectsSettingInput {
  factory Input$UpdateEnterpriseOrganizationProjectsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseOrganizationProjectsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseOrganizationProjectsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseOrganizationProjectsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseOrganizationProjectsSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
          Input$UpdateEnterpriseOrganizationProjectsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseOrganizationProjectsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
    Input$UpdateEnterpriseOrganizationProjectsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseOrganizationProjectsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseOrganizationProjectsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseOrganizationProjectsSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseOrganizationProjectsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseOrganizationProjectsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseOrganizationProjectsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseOwnerOrganizationRoleInput {
  factory Input$UpdateEnterpriseOwnerOrganizationRoleInput({
    String? clientMutationId,
    required String enterpriseId,
    required String organizationId,
    required Enum$RoleInOrganization organizationRole,
  }) =>
      Input$UpdateEnterpriseOwnerOrganizationRoleInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'organizationId': organizationId,
        r'organizationRole': organizationRole,
      });

  Input$UpdateEnterpriseOwnerOrganizationRoleInput._(this._$data);

  factory Input$UpdateEnterpriseOwnerOrganizationRoleInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$organizationRole = data['organizationRole'];
    result$data['organizationRole'] =
        fromJson$Enum$RoleInOrganization((l$organizationRole as String));
    return Input$UpdateEnterpriseOwnerOrganizationRoleInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String get organizationId => (_$data['organizationId'] as String);
  Enum$RoleInOrganization get organizationRole =>
      (_$data['organizationRole'] as Enum$RoleInOrganization);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$organizationRole = organizationRole;
    result$data['organizationRole'] =
        toJson$Enum$RoleInOrganization(l$organizationRole);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<
          Input$UpdateEnterpriseOwnerOrganizationRoleInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseOwnerOrganizationRoleInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$organizationRole = organizationRole;
    final lOther$organizationRole = other.organizationRole;
    if (l$organizationRole != lOther$organizationRole) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$organizationId = organizationId;
    final l$organizationRole = organizationRole;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$organizationId,
      l$organizationRole,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
    Input$UpdateEnterpriseOwnerOrganizationRoleInput instance,
    TRes Function(Input$UpdateEnterpriseOwnerOrganizationRoleInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput;

  factory CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    Enum$RoleInOrganization? organizationRole,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseOwnerOrganizationRoleInput _instance;

  final TRes Function(Input$UpdateEnterpriseOwnerOrganizationRoleInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? organizationId = _undefined,
    Object? organizationRole = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseOwnerOrganizationRoleInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (organizationRole != _undefined && organizationRole != null)
          'organizationRole': (organizationRole as Enum$RoleInOrganization),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseOwnerOrganizationRoleInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseOwnerOrganizationRoleInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    String? organizationId,
    Enum$RoleInOrganization? organizationRole,
  }) =>
      _res;
}

class Input$UpdateEnterpriseProfileInput {
  factory Input$UpdateEnterpriseProfileInput({
    String? clientMutationId,
    String? description,
    required String enterpriseId,
    String? location,
    String? name,
    String? websiteUrl,
  }) =>
      Input$UpdateEnterpriseProfileInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (description != null) r'description': description,
        r'enterpriseId': enterpriseId,
        if (location != null) r'location': location,
        if (name != null) r'name': name,
        if (websiteUrl != null) r'websiteUrl': websiteUrl,
      });

  Input$UpdateEnterpriseProfileInput._(this._$data);

  factory Input$UpdateEnterpriseProfileInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    if (data.containsKey('location')) {
      final l$location = data['location'];
      result$data['location'] = (l$location as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    if (data.containsKey('websiteUrl')) {
      final l$websiteUrl = data['websiteUrl'];
      result$data['websiteUrl'] = (l$websiteUrl as String?);
    }
    return Input$UpdateEnterpriseProfileInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get description => (_$data['description'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  String? get location => (_$data['location'] as String?);
  String? get name => (_$data['name'] as String?);
  String? get websiteUrl => (_$data['websiteUrl'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    if (_$data.containsKey('location')) {
      final l$location = location;
      result$data['location'] = l$location;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    if (_$data.containsKey('websiteUrl')) {
      final l$websiteUrl = websiteUrl;
      result$data['websiteUrl'] = l$websiteUrl;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseProfileInput<
          Input$UpdateEnterpriseProfileInput>
      get copyWith => CopyWith$Input$UpdateEnterpriseProfileInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseProfileInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$location = location;
    final lOther$location = other.location;
    if (_$data.containsKey('location') !=
        other._$data.containsKey('location')) {
      return false;
    }
    if (l$location != lOther$location) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$websiteUrl = websiteUrl;
    final lOther$websiteUrl = other.websiteUrl;
    if (_$data.containsKey('websiteUrl') !=
        other._$data.containsKey('websiteUrl')) {
      return false;
    }
    if (l$websiteUrl != lOther$websiteUrl) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$enterpriseId = enterpriseId;
    final l$location = location;
    final l$name = name;
    final l$websiteUrl = websiteUrl;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('description') ? l$description : const {},
      l$enterpriseId,
      _$data.containsKey('location') ? l$location : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('websiteUrl') ? l$websiteUrl : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  factory CopyWith$Input$UpdateEnterpriseProfileInput(
    Input$UpdateEnterpriseProfileInput instance,
    TRes Function(Input$UpdateEnterpriseProfileInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseProfileInput;

  factory CopyWith$Input$UpdateEnterpriseProfileInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput;

  TRes call({
    String? clientMutationId,
    String? description,
    String? enterpriseId,
    String? location,
    String? name,
    String? websiteUrl,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseProfileInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseProfileInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseProfileInput _instance;

  final TRes Function(Input$UpdateEnterpriseProfileInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? enterpriseId = _undefined,
    Object? location = _undefined,
    Object? name = _undefined,
    Object? websiteUrl = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseProfileInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (location != _undefined) 'location': (location as String?),
        if (name != _undefined) 'name': (name as String?),
        if (websiteUrl != _undefined) 'websiteUrl': (websiteUrl as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput<TRes>
    implements CopyWith$Input$UpdateEnterpriseProfileInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseProfileInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? description,
    String? enterpriseId,
    String? location,
    String? name,
    String? websiteUrl,
  }) =>
      _res;
}

class Input$UpdateEnterpriseRepositoryProjectsSettingInput {
  factory Input$UpdateEnterpriseRepositoryProjectsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseRepositoryProjectsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseRepositoryProjectsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseRepositoryProjectsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseRepositoryProjectsSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
          Input$UpdateEnterpriseRepositoryProjectsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseRepositoryProjectsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
    Input$UpdateEnterpriseRepositoryProjectsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseRepositoryProjectsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseRepositoryProjectsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseRepositoryProjectsSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseRepositoryProjectsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseRepositoryProjectsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseRepositoryProjectsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseTeamDiscussionsSettingInput {
  factory Input$UpdateEnterpriseTeamDiscussionsSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledDisabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseTeamDiscussionsSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseTeamDiscussionsSettingInput._(this._$data);

  factory Input$UpdateEnterpriseTeamDiscussionsSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledDisabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateEnterpriseTeamDiscussionsSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledDisabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledDisabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledDisabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<
          Input$UpdateEnterpriseTeamDiscussionsSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnterpriseTeamDiscussionsSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
    Input$UpdateEnterpriseTeamDiscussionsSettingInput instance,
    TRes Function(Input$UpdateEnterpriseTeamDiscussionsSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput;

  factory CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseTeamDiscussionsSettingInput _instance;

  final TRes Function(Input$UpdateEnterpriseTeamDiscussionsSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateEnterpriseTeamDiscussionsSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$EnterpriseEnabledDisabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTeamDiscussionsSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseTeamDiscussionsSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledDisabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  factory Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput({
    String? clientMutationId,
    required String enterpriseId,
    required Enum$EnterpriseEnabledSettingValue settingValue,
  }) =>
      Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enterpriseId': enterpriseId,
        r'settingValue': settingValue,
      });

  Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._(
      this._$data);

  factory Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enterpriseId = data['enterpriseId'];
    result$data['enterpriseId'] = (l$enterpriseId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$EnterpriseEnabledSettingValue((l$settingValue as String));
    return Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get enterpriseId => (_$data['enterpriseId'] as String);
  Enum$EnterpriseEnabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$EnterpriseEnabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enterpriseId = enterpriseId;
    result$data['enterpriseId'] = l$enterpriseId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$EnterpriseEnabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
          Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enterpriseId = enterpriseId;
    final lOther$enterpriseId = other.enterpriseId;
    if (l$enterpriseId != lOther$enterpriseId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$enterpriseId = enterpriseId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enterpriseId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
    Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput instance,
    TRes Function(
            Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;

  factory CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;

  TRes call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput
      _instance;

  final TRes Function(
      Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? enterpriseId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(
          Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enterpriseId != _undefined && enterpriseId != null)
          'enterpriseId': (enterpriseId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue as Enum$EnterpriseEnabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? enterpriseId,
    Enum$EnterpriseEnabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateEnvironmentInput {
  factory Input$UpdateEnvironmentInput({
    String? clientMutationId,
    required String environmentId,
    List<String>? reviewers,
    int? waitTimer,
  }) =>
      Input$UpdateEnvironmentInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'environmentId': environmentId,
        if (reviewers != null) r'reviewers': reviewers,
        if (waitTimer != null) r'waitTimer': waitTimer,
      });

  Input$UpdateEnvironmentInput._(this._$data);

  factory Input$UpdateEnvironmentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$environmentId = data['environmentId'];
    result$data['environmentId'] = (l$environmentId as String);
    if (data.containsKey('reviewers')) {
      final l$reviewers = data['reviewers'];
      result$data['reviewers'] =
          (l$reviewers as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('waitTimer')) {
      final l$waitTimer = data['waitTimer'];
      result$data['waitTimer'] = (l$waitTimer as int?);
    }
    return Input$UpdateEnvironmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get environmentId => (_$data['environmentId'] as String);
  List<String>? get reviewers => (_$data['reviewers'] as List<String>?);
  int? get waitTimer => (_$data['waitTimer'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$environmentId = environmentId;
    result$data['environmentId'] = l$environmentId;
    if (_$data.containsKey('reviewers')) {
      final l$reviewers = reviewers;
      result$data['reviewers'] = l$reviewers?.map((e) => e).toList();
    }
    if (_$data.containsKey('waitTimer')) {
      final l$waitTimer = waitTimer;
      result$data['waitTimer'] = l$waitTimer;
    }
    return result$data;
  }

  CopyWith$Input$UpdateEnvironmentInput<Input$UpdateEnvironmentInput>
      get copyWith => CopyWith$Input$UpdateEnvironmentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateEnvironmentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$environmentId = environmentId;
    final lOther$environmentId = other.environmentId;
    if (l$environmentId != lOther$environmentId) {
      return false;
    }
    final l$reviewers = reviewers;
    final lOther$reviewers = other.reviewers;
    if (_$data.containsKey('reviewers') !=
        other._$data.containsKey('reviewers')) {
      return false;
    }
    if (l$reviewers != null && lOther$reviewers != null) {
      if (l$reviewers.length != lOther$reviewers.length) {
        return false;
      }
      for (int i = 0; i < l$reviewers.length; i++) {
        final l$reviewers$entry = l$reviewers[i];
        final lOther$reviewers$entry = lOther$reviewers[i];
        if (l$reviewers$entry != lOther$reviewers$entry) {
          return false;
        }
      }
    } else if (l$reviewers != lOther$reviewers) {
      return false;
    }
    final l$waitTimer = waitTimer;
    final lOther$waitTimer = other.waitTimer;
    if (_$data.containsKey('waitTimer') !=
        other._$data.containsKey('waitTimer')) {
      return false;
    }
    if (l$waitTimer != lOther$waitTimer) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$environmentId = environmentId;
    final l$reviewers = reviewers;
    final l$waitTimer = waitTimer;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$environmentId,
      _$data.containsKey('reviewers')
          ? l$reviewers == null
              ? null
              : Object.hashAll(l$reviewers.map((v) => v))
          : const {},
      _$data.containsKey('waitTimer') ? l$waitTimer : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateEnvironmentInput<TRes> {
  factory CopyWith$Input$UpdateEnvironmentInput(
    Input$UpdateEnvironmentInput instance,
    TRes Function(Input$UpdateEnvironmentInput) then,
  ) = _CopyWithImpl$Input$UpdateEnvironmentInput;

  factory CopyWith$Input$UpdateEnvironmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateEnvironmentInput;

  TRes call({
    String? clientMutationId,
    String? environmentId,
    List<String>? reviewers,
    int? waitTimer,
  });
}

class _CopyWithImpl$Input$UpdateEnvironmentInput<TRes>
    implements CopyWith$Input$UpdateEnvironmentInput<TRes> {
  _CopyWithImpl$Input$UpdateEnvironmentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateEnvironmentInput _instance;

  final TRes Function(Input$UpdateEnvironmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? environmentId = _undefined,
    Object? reviewers = _undefined,
    Object? waitTimer = _undefined,
  }) =>
      _then(Input$UpdateEnvironmentInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (environmentId != _undefined && environmentId != null)
          'environmentId': (environmentId as String),
        if (reviewers != _undefined) 'reviewers': (reviewers as List<String>?),
        if (waitTimer != _undefined) 'waitTimer': (waitTimer as int?),
      }));
}

class _CopyWithStubImpl$Input$UpdateEnvironmentInput<TRes>
    implements CopyWith$Input$UpdateEnvironmentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateEnvironmentInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? environmentId,
    List<String>? reviewers,
    int? waitTimer,
  }) =>
      _res;
}

class Input$UpdateIpAllowListEnabledSettingInput {
  factory Input$UpdateIpAllowListEnabledSettingInput({
    String? clientMutationId,
    required String ownerId,
    required Enum$IpAllowListEnabledSettingValue settingValue,
  }) =>
      Input$UpdateIpAllowListEnabledSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'settingValue': settingValue,
      });

  Input$UpdateIpAllowListEnabledSettingInput._(this._$data);

  factory Input$UpdateIpAllowListEnabledSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] = fromJson$Enum$IpAllowListEnabledSettingValue(
        (l$settingValue as String));
    return Input$UpdateIpAllowListEnabledSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  Enum$IpAllowListEnabledSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$IpAllowListEnabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$IpAllowListEnabledSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListEnabledSettingInput<
          Input$UpdateIpAllowListEnabledSettingInput>
      get copyWith => CopyWith$Input$UpdateIpAllowListEnabledSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIpAllowListEnabledSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  factory CopyWith$Input$UpdateIpAllowListEnabledSettingInput(
    Input$UpdateIpAllowListEnabledSettingInput instance,
    TRes Function(Input$UpdateIpAllowListEnabledSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput;

  factory CopyWith$Input$UpdateIpAllowListEnabledSettingInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListEnabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListEnabledSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListEnabledSettingInput _instance;

  final TRes Function(Input$UpdateIpAllowListEnabledSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListEnabledSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue as Enum$IpAllowListEnabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEnabledSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListEnabledSettingInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListEnabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateIpAllowListEntryInput {
  factory Input$UpdateIpAllowListEntryInput({
    required String allowListValue,
    String? clientMutationId,
    required String ipAllowListEntryId,
    required bool isActive,
    String? name,
  }) =>
      Input$UpdateIpAllowListEntryInput._({
        r'allowListValue': allowListValue,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ipAllowListEntryId': ipAllowListEntryId,
        r'isActive': isActive,
        if (name != null) r'name': name,
      });

  Input$UpdateIpAllowListEntryInput._(this._$data);

  factory Input$UpdateIpAllowListEntryInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$allowListValue = data['allowListValue'];
    result$data['allowListValue'] = (l$allowListValue as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ipAllowListEntryId = data['ipAllowListEntryId'];
    result$data['ipAllowListEntryId'] = (l$ipAllowListEntryId as String);
    final l$isActive = data['isActive'];
    result$data['isActive'] = (l$isActive as bool);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$UpdateIpAllowListEntryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get allowListValue => (_$data['allowListValue'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ipAllowListEntryId => (_$data['ipAllowListEntryId'] as String);
  bool get isActive => (_$data['isActive'] as bool);
  String? get name => (_$data['name'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$allowListValue = allowListValue;
    result$data['allowListValue'] = l$allowListValue;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    result$data['ipAllowListEntryId'] = l$ipAllowListEntryId;
    final l$isActive = isActive;
    result$data['isActive'] = l$isActive;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListEntryInput<Input$UpdateIpAllowListEntryInput>
      get copyWith => CopyWith$Input$UpdateIpAllowListEntryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIpAllowListEntryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$allowListValue = allowListValue;
    final lOther$allowListValue = other.allowListValue;
    if (l$allowListValue != lOther$allowListValue) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final lOther$ipAllowListEntryId = other.ipAllowListEntryId;
    if (l$ipAllowListEntryId != lOther$ipAllowListEntryId) {
      return false;
    }
    final l$isActive = isActive;
    final lOther$isActive = other.isActive;
    if (l$isActive != lOther$isActive) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$allowListValue = allowListValue;
    final l$clientMutationId = clientMutationId;
    final l$ipAllowListEntryId = ipAllowListEntryId;
    final l$isActive = isActive;
    final l$name = name;
    return Object.hashAll([
      l$allowListValue,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ipAllowListEntryId,
      l$isActive,
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  factory CopyWith$Input$UpdateIpAllowListEntryInput(
    Input$UpdateIpAllowListEntryInput instance,
    TRes Function(Input$UpdateIpAllowListEntryInput) then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListEntryInput;

  factory CopyWith$Input$UpdateIpAllowListEntryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput;

  TRes call({
    String? allowListValue,
    String? clientMutationId,
    String? ipAllowListEntryId,
    bool? isActive,
    String? name,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListEntryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListEntryInput _instance;

  final TRes Function(Input$UpdateIpAllowListEntryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? allowListValue = _undefined,
    Object? clientMutationId = _undefined,
    Object? ipAllowListEntryId = _undefined,
    Object? isActive = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListEntryInput._({
        ..._instance._$data,
        if (allowListValue != _undefined && allowListValue != null)
          'allowListValue': (allowListValue as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ipAllowListEntryId != _undefined && ipAllowListEntryId != null)
          'ipAllowListEntryId': (ipAllowListEntryId as String),
        if (isActive != _undefined && isActive != null)
          'isActive': (isActive as bool),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput<TRes>
    implements CopyWith$Input$UpdateIpAllowListEntryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListEntryInput(this._res);

  TRes _res;

  call({
    String? allowListValue,
    String? clientMutationId,
    String? ipAllowListEntryId,
    bool? isActive,
    String? name,
  }) =>
      _res;
}

class Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput {
  factory Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput({
    String? clientMutationId,
    required String ownerId,
    required Enum$IpAllowListForInstalledAppsEnabledSettingValue settingValue,
  }) =>
      Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'settingValue': settingValue,
      });

  Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._(this._$data);

  factory Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
            (l$settingValue as String));
    return Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  Enum$IpAllowListForInstalledAppsEnabledSettingValue get settingValue =>
      (_$data['settingValue']
          as Enum$IpAllowListForInstalledAppsEnabledSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
            l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
          Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
    Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput instance,
    TRes Function(Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput;

  factory CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListForInstalledAppsEnabledSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput _instance;

  final TRes Function(
      Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue': (settingValue
              as Enum$IpAllowListForInstalledAppsEnabledSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateIpAllowListForInstalledAppsEnabledSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    Enum$IpAllowListForInstalledAppsEnabledSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateIssueCommentInput {
  factory Input$UpdateIssueCommentInput({
    required String body,
    String? clientMutationId,
    required String id,
  }) =>
      Input$UpdateIssueCommentInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$UpdateIssueCommentInput._(this._$data);

  factory Input$UpdateIssueCommentInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$UpdateIssueCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$UpdateIssueCommentInput<Input$UpdateIssueCommentInput>
      get copyWith => CopyWith$Input$UpdateIssueCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIssueCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueCommentInput<TRes> {
  factory CopyWith$Input$UpdateIssueCommentInput(
    Input$UpdateIssueCommentInput instance,
    TRes Function(Input$UpdateIssueCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueCommentInput;

  factory CopyWith$Input$UpdateIssueCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueCommentInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$UpdateIssueCommentInput<TRes>
    implements CopyWith$Input$UpdateIssueCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueCommentInput _instance;

  final TRes Function(Input$UpdateIssueCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$UpdateIssueCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueCommentInput<TRes>
    implements CopyWith$Input$UpdateIssueCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$UpdateIssueInput {
  factory Input$UpdateIssueInput({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    required String id,
    List<String>? labelIds,
    String? milestoneId,
    List<String>? projectIds,
    Enum$IssueState? state,
    String? title,
  }) =>
      Input$UpdateIssueInput._({
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (labelIds != null) r'labelIds': labelIds,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (projectIds != null) r'projectIds': projectIds,
        if (state != null) r'state': state,
        if (title != null) r'title': title,
      });

  Input$UpdateIssueInput._(this._$data);

  factory Input$UpdateIssueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$IssueState((l$state as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$UpdateIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);
  Enum$IssueState? get state => (_$data['state'] as Enum$IssueState?);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$IssueState(l$state);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$UpdateIssueInput<Input$UpdateIssueInput> get copyWith =>
      CopyWith$Input$UpdateIssueInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assigneeIds = assigneeIds;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$labelIds = labelIds;
    final l$milestoneId = milestoneId;
    final l$projectIds = projectIds;
    final l$state = state;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateIssueInput<TRes> {
  factory CopyWith$Input$UpdateIssueInput(
    Input$UpdateIssueInput instance,
    TRes Function(Input$UpdateIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateIssueInput;

  factory CopyWith$Input$UpdateIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateIssueInput;

  TRes call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? id,
    List<String>? labelIds,
    String? milestoneId,
    List<String>? projectIds,
    Enum$IssueState? state,
    String? title,
  });
}

class _CopyWithImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateIssueInput _instance;

  final TRes Function(Input$UpdateIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assigneeIds = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? labelIds = _undefined,
    Object? milestoneId = _undefined,
    Object? projectIds = _undefined,
    Object? state = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$UpdateIssueInput._({
        ..._instance._$data,
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (state != _undefined) 'state': (state as Enum$IssueState?),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateIssueInput<TRes>
    implements CopyWith$Input$UpdateIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateIssueInput(this._res);

  TRes _res;

  call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? id,
    List<String>? labelIds,
    String? milestoneId,
    List<String>? projectIds,
    Enum$IssueState? state,
    String? title,
  }) =>
      _res;
}

class Input$UpdateLabelInput {
  factory Input$UpdateLabelInput({
    String? clientMutationId,
    String? color,
    String? description,
    required String id,
    String? name,
  }) =>
      Input$UpdateLabelInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (color != null) r'color': color,
        if (description != null) r'description': description,
        r'id': id,
        if (name != null) r'name': name,
      });

  Input$UpdateLabelInput._(this._$data);

  factory Input$UpdateLabelInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = (l$color as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    return Input$UpdateLabelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get color => (_$data['color'] as String?);
  String? get description => (_$data['description'] as String?);
  String get id => (_$data['id'] as String);
  String? get name => (_$data['name'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    return result$data;
  }

  CopyWith$Input$UpdateLabelInput<Input$UpdateLabelInput> get copyWith =>
      CopyWith$Input$UpdateLabelInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateLabelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$color = color;
    final l$description = description;
    final l$id = id;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('description') ? l$description : const {},
      l$id,
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateLabelInput<TRes> {
  factory CopyWith$Input$UpdateLabelInput(
    Input$UpdateLabelInput instance,
    TRes Function(Input$UpdateLabelInput) then,
  ) = _CopyWithImpl$Input$UpdateLabelInput;

  factory CopyWith$Input$UpdateLabelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateLabelInput;

  TRes call({
    String? clientMutationId,
    String? color,
    String? description,
    String? id,
    String? name,
  });
}

class _CopyWithImpl$Input$UpdateLabelInput<TRes>
    implements CopyWith$Input$UpdateLabelInput<TRes> {
  _CopyWithImpl$Input$UpdateLabelInput(
    this._instance,
    this._then,
  );

  final Input$UpdateLabelInput _instance;

  final TRes Function(Input$UpdateLabelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? color = _undefined,
    Object? description = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$UpdateLabelInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (color != _undefined) 'color': (color as String?),
        if (description != _undefined) 'description': (description as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (name != _undefined) 'name': (name as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateLabelInput<TRes>
    implements CopyWith$Input$UpdateLabelInput<TRes> {
  _CopyWithStubImpl$Input$UpdateLabelInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? color,
    String? description,
    String? id,
    String? name,
  }) =>
      _res;
}

class Input$UpdateNotificationRestrictionSettingInput {
  factory Input$UpdateNotificationRestrictionSettingInput({
    String? clientMutationId,
    required String ownerId,
    required Enum$NotificationRestrictionSettingValue settingValue,
  }) =>
      Input$UpdateNotificationRestrictionSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'ownerId': ownerId,
        r'settingValue': settingValue,
      });

  Input$UpdateNotificationRestrictionSettingInput._(this._$data);

  factory Input$UpdateNotificationRestrictionSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$ownerId = data['ownerId'];
    result$data['ownerId'] = (l$ownerId as String);
    final l$settingValue = data['settingValue'];
    result$data['settingValue'] =
        fromJson$Enum$NotificationRestrictionSettingValue(
            (l$settingValue as String));
    return Input$UpdateNotificationRestrictionSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get ownerId => (_$data['ownerId'] as String);
  Enum$NotificationRestrictionSettingValue get settingValue =>
      (_$data['settingValue'] as Enum$NotificationRestrictionSettingValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$ownerId = ownerId;
    result$data['ownerId'] = l$ownerId;
    final l$settingValue = settingValue;
    result$data['settingValue'] =
        toJson$Enum$NotificationRestrictionSettingValue(l$settingValue);
    return result$data;
  }

  CopyWith$Input$UpdateNotificationRestrictionSettingInput<
          Input$UpdateNotificationRestrictionSettingInput>
      get copyWith => CopyWith$Input$UpdateNotificationRestrictionSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateNotificationRestrictionSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$ownerId = ownerId;
    final lOther$ownerId = other.ownerId;
    if (l$ownerId != lOther$ownerId) {
      return false;
    }
    final l$settingValue = settingValue;
    final lOther$settingValue = other.settingValue;
    if (l$settingValue != lOther$settingValue) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$ownerId = ownerId;
    final l$settingValue = settingValue;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$ownerId,
      l$settingValue,
    ]);
  }
}

abstract class CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  factory CopyWith$Input$UpdateNotificationRestrictionSettingInput(
    Input$UpdateNotificationRestrictionSettingInput instance,
    TRes Function(Input$UpdateNotificationRestrictionSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput;

  factory CopyWith$Input$UpdateNotificationRestrictionSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput;

  TRes call({
    String? clientMutationId,
    String? ownerId,
    Enum$NotificationRestrictionSettingValue? settingValue,
  });
}

class _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput<TRes>
    implements CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateNotificationRestrictionSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateNotificationRestrictionSettingInput _instance;

  final TRes Function(Input$UpdateNotificationRestrictionSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? ownerId = _undefined,
    Object? settingValue = _undefined,
  }) =>
      _then(Input$UpdateNotificationRestrictionSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (ownerId != _undefined && ownerId != null)
          'ownerId': (ownerId as String),
        if (settingValue != _undefined && settingValue != null)
          'settingValue':
              (settingValue as Enum$NotificationRestrictionSettingValue),
      }));
}

class _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput<TRes>
    implements CopyWith$Input$UpdateNotificationRestrictionSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateNotificationRestrictionSettingInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? ownerId,
    Enum$NotificationRestrictionSettingValue? settingValue,
  }) =>
      _res;
}

class Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput {
  factory Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput({
    String? clientMutationId,
    required bool forkingEnabled,
    required String organizationId,
  }) =>
      Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'forkingEnabled': forkingEnabled,
        r'organizationId': organizationId,
      });

  Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._(
      this._$data);

  factory Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$forkingEnabled = data['forkingEnabled'];
    result$data['forkingEnabled'] = (l$forkingEnabled as bool);
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    return Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get forkingEnabled => (_$data['forkingEnabled'] as bool);
  String get organizationId => (_$data['organizationId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$forkingEnabled = forkingEnabled;
    result$data['forkingEnabled'] = l$forkingEnabled;
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    return result$data;
  }

  CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
          Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$forkingEnabled = forkingEnabled;
    final lOther$forkingEnabled = other.forkingEnabled;
    if (l$forkingEnabled != lOther$forkingEnabled) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$forkingEnabled = forkingEnabled;
    final l$organizationId = organizationId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$forkingEnabled,
      l$organizationId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
    Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput instance,
    TRes Function(
            Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput)
        then,
  ) = _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;

  factory CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;

  TRes call({
    String? clientMutationId,
    bool? forkingEnabled,
    String? organizationId,
  });
}

class _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput
      _instance;

  final TRes Function(
      Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? forkingEnabled = _undefined,
    Object? organizationId = _undefined,
  }) =>
      _then(
          Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (forkingEnabled != _undefined && forkingEnabled != null)
          'forkingEnabled': (forkingEnabled as bool),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput<
            TRes> {
  _CopyWithStubImpl$Input$UpdateOrganizationAllowPrivateRepositoryForkingSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? forkingEnabled,
    String? organizationId,
  }) =>
      _res;
}

class Input$UpdateOrganizationWebCommitSignoffSettingInput {
  factory Input$UpdateOrganizationWebCommitSignoffSettingInput({
    String? clientMutationId,
    required String organizationId,
    required bool webCommitSignoffRequired,
  }) =>
      Input$UpdateOrganizationWebCommitSignoffSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'organizationId': organizationId,
        r'webCommitSignoffRequired': webCommitSignoffRequired,
      });

  Input$UpdateOrganizationWebCommitSignoffSettingInput._(this._$data);

  factory Input$UpdateOrganizationWebCommitSignoffSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$organizationId = data['organizationId'];
    result$data['organizationId'] = (l$organizationId as String);
    final l$webCommitSignoffRequired = data['webCommitSignoffRequired'];
    result$data['webCommitSignoffRequired'] =
        (l$webCommitSignoffRequired as bool);
    return Input$UpdateOrganizationWebCommitSignoffSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get organizationId => (_$data['organizationId'] as String);
  bool get webCommitSignoffRequired =>
      (_$data['webCommitSignoffRequired'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$organizationId = organizationId;
    result$data['organizationId'] = l$organizationId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    result$data['webCommitSignoffRequired'] = l$webCommitSignoffRequired;
    return result$data;
  }

  CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<
          Input$UpdateOrganizationWebCommitSignoffSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateOrganizationWebCommitSignoffSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$organizationId = organizationId;
    final lOther$organizationId = other.organizationId;
    if (l$organizationId != lOther$organizationId) {
      return false;
    }
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final lOther$webCommitSignoffRequired = other.webCommitSignoffRequired;
    if (l$webCommitSignoffRequired != lOther$webCommitSignoffRequired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$organizationId = organizationId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$organizationId,
      l$webCommitSignoffRequired,
    ]);
  }
}

abstract class CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput(
    Input$UpdateOrganizationWebCommitSignoffSettingInput instance,
    TRes Function(Input$UpdateOrganizationWebCommitSignoffSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput;

  factory CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput;

  TRes call({
    String? clientMutationId,
    String? organizationId,
    bool? webCommitSignoffRequired,
  });
}

class _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateOrganizationWebCommitSignoffSettingInput _instance;

  final TRes Function(Input$UpdateOrganizationWebCommitSignoffSettingInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? organizationId = _undefined,
    Object? webCommitSignoffRequired = _undefined,
  }) =>
      _then(Input$UpdateOrganizationWebCommitSignoffSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (organizationId != _undefined && organizationId != null)
          'organizationId': (organizationId as String),
        if (webCommitSignoffRequired != _undefined &&
            webCommitSignoffRequired != null)
          'webCommitSignoffRequired': (webCommitSignoffRequired as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput<
        TRes>
    implements
        CopyWith$Input$UpdateOrganizationWebCommitSignoffSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateOrganizationWebCommitSignoffSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? organizationId,
    bool? webCommitSignoffRequired,
  }) =>
      _res;
}

class Input$UpdateProjectCardInput {
  factory Input$UpdateProjectCardInput({
    String? clientMutationId,
    bool? isArchived,
    String? note,
    required String projectCardId,
  }) =>
      Input$UpdateProjectCardInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (isArchived != null) r'isArchived': isArchived,
        if (note != null) r'note': note,
        r'projectCardId': projectCardId,
      });

  Input$UpdateProjectCardInput._(this._$data);

  factory Input$UpdateProjectCardInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('isArchived')) {
      final l$isArchived = data['isArchived'];
      result$data['isArchived'] = (l$isArchived as bool?);
    }
    if (data.containsKey('note')) {
      final l$note = data['note'];
      result$data['note'] = (l$note as String?);
    }
    final l$projectCardId = data['projectCardId'];
    result$data['projectCardId'] = (l$projectCardId as String);
    return Input$UpdateProjectCardInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get isArchived => (_$data['isArchived'] as bool?);
  String? get note => (_$data['note'] as String?);
  String get projectCardId => (_$data['projectCardId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('isArchived')) {
      final l$isArchived = isArchived;
      result$data['isArchived'] = l$isArchived;
    }
    if (_$data.containsKey('note')) {
      final l$note = note;
      result$data['note'] = l$note;
    }
    final l$projectCardId = projectCardId;
    result$data['projectCardId'] = l$projectCardId;
    return result$data;
  }

  CopyWith$Input$UpdateProjectCardInput<Input$UpdateProjectCardInput>
      get copyWith => CopyWith$Input$UpdateProjectCardInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectCardInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$isArchived = isArchived;
    final lOther$isArchived = other.isArchived;
    if (_$data.containsKey('isArchived') !=
        other._$data.containsKey('isArchived')) {
      return false;
    }
    if (l$isArchived != lOther$isArchived) {
      return false;
    }
    final l$note = note;
    final lOther$note = other.note;
    if (_$data.containsKey('note') != other._$data.containsKey('note')) {
      return false;
    }
    if (l$note != lOther$note) {
      return false;
    }
    final l$projectCardId = projectCardId;
    final lOther$projectCardId = other.projectCardId;
    if (l$projectCardId != lOther$projectCardId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$isArchived = isArchived;
    final l$note = note;
    final l$projectCardId = projectCardId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('isArchived') ? l$isArchived : const {},
      _$data.containsKey('note') ? l$note : const {},
      l$projectCardId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectCardInput<TRes> {
  factory CopyWith$Input$UpdateProjectCardInput(
    Input$UpdateProjectCardInput instance,
    TRes Function(Input$UpdateProjectCardInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectCardInput;

  factory CopyWith$Input$UpdateProjectCardInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectCardInput;

  TRes call({
    String? clientMutationId,
    bool? isArchived,
    String? note,
    String? projectCardId,
  });
}

class _CopyWithImpl$Input$UpdateProjectCardInput<TRes>
    implements CopyWith$Input$UpdateProjectCardInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectCardInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectCardInput _instance;

  final TRes Function(Input$UpdateProjectCardInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? isArchived = _undefined,
    Object? note = _undefined,
    Object? projectCardId = _undefined,
  }) =>
      _then(Input$UpdateProjectCardInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (isArchived != _undefined) 'isArchived': (isArchived as bool?),
        if (note != _undefined) 'note': (note as String?),
        if (projectCardId != _undefined && projectCardId != null)
          'projectCardId': (projectCardId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectCardInput<TRes>
    implements CopyWith$Input$UpdateProjectCardInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectCardInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? isArchived,
    String? note,
    String? projectCardId,
  }) =>
      _res;
}

class Input$UpdateProjectColumnInput {
  factory Input$UpdateProjectColumnInput({
    String? clientMutationId,
    required String name,
    required String projectColumnId,
  }) =>
      Input$UpdateProjectColumnInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'name': name,
        r'projectColumnId': projectColumnId,
      });

  Input$UpdateProjectColumnInput._(this._$data);

  factory Input$UpdateProjectColumnInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$projectColumnId = data['projectColumnId'];
    result$data['projectColumnId'] = (l$projectColumnId as String);
    return Input$UpdateProjectColumnInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get name => (_$data['name'] as String);
  String get projectColumnId => (_$data['projectColumnId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$name = name;
    result$data['name'] = l$name;
    final l$projectColumnId = projectColumnId;
    result$data['projectColumnId'] = l$projectColumnId;
    return result$data;
  }

  CopyWith$Input$UpdateProjectColumnInput<Input$UpdateProjectColumnInput>
      get copyWith => CopyWith$Input$UpdateProjectColumnInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectColumnInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$projectColumnId = projectColumnId;
    final lOther$projectColumnId = other.projectColumnId;
    if (l$projectColumnId != lOther$projectColumnId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$projectColumnId = projectColumnId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$name,
      l$projectColumnId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectColumnInput<TRes> {
  factory CopyWith$Input$UpdateProjectColumnInput(
    Input$UpdateProjectColumnInput instance,
    TRes Function(Input$UpdateProjectColumnInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectColumnInput;

  factory CopyWith$Input$UpdateProjectColumnInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectColumnInput;

  TRes call({
    String? clientMutationId,
    String? name,
    String? projectColumnId,
  });
}

class _CopyWithImpl$Input$UpdateProjectColumnInput<TRes>
    implements CopyWith$Input$UpdateProjectColumnInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectColumnInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectColumnInput _instance;

  final TRes Function(Input$UpdateProjectColumnInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? projectColumnId = _undefined,
  }) =>
      _then(Input$UpdateProjectColumnInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined && name != null) 'name': (name as String),
        if (projectColumnId != _undefined && projectColumnId != null)
          'projectColumnId': (projectColumnId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectColumnInput<TRes>
    implements CopyWith$Input$UpdateProjectColumnInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectColumnInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? name,
    String? projectColumnId,
  }) =>
      _res;
}

class Input$UpdateProjectInput {
  factory Input$UpdateProjectInput({
    String? body,
    String? clientMutationId,
    String? name,
    required String projectId,
    bool? public,
    Enum$ProjectState? state,
  }) =>
      Input$UpdateProjectInput._({
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (name != null) r'name': name,
        r'projectId': projectId,
        if (public != null) r'public': public,
        if (state != null) r'state': state,
      });

  Input$UpdateProjectInput._(this._$data);

  factory Input$UpdateProjectInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$ProjectState((l$state as String));
    }
    return Input$UpdateProjectInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get name => (_$data['name'] as String?);
  String get projectId => (_$data['projectId'] as String);
  bool? get public => (_$data['public'] as bool?);
  Enum$ProjectState? get state => (_$data['state'] as Enum$ProjectState?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$ProjectState(l$state);
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectInput<Input$UpdateProjectInput> get copyWith =>
      CopyWith$Input$UpdateProjectInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$name = name;
    final l$projectId = projectId;
    final l$public = public;
    final l$state = state;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('name') ? l$name : const {},
      l$projectId,
      _$data.containsKey('public') ? l$public : const {},
      _$data.containsKey('state') ? l$state : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectInput<TRes> {
  factory CopyWith$Input$UpdateProjectInput(
    Input$UpdateProjectInput instance,
    TRes Function(Input$UpdateProjectInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectInput;

  factory CopyWith$Input$UpdateProjectInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? name,
    String? projectId,
    bool? public,
    Enum$ProjectState? state,
  });
}

class _CopyWithImpl$Input$UpdateProjectInput<TRes>
    implements CopyWith$Input$UpdateProjectInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectInput _instance;

  final TRes Function(Input$UpdateProjectInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? name = _undefined,
    Object? projectId = _undefined,
    Object? public = _undefined,
    Object? state = _undefined,
  }) =>
      _then(Input$UpdateProjectInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (name != _undefined) 'name': (name as String?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (public != _undefined) 'public': (public as bool?),
        if (state != _undefined) 'state': (state as Enum$ProjectState?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectInput<TRes>
    implements CopyWith$Input$UpdateProjectInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? name,
    String? projectId,
    bool? public,
    Enum$ProjectState? state,
  }) =>
      _res;
}

class Input$UpdateProjectV2DraftIssueInput {
  factory Input$UpdateProjectV2DraftIssueInput({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    required String draftIssueId,
    String? title,
  }) =>
      Input$UpdateProjectV2DraftIssueInput._({
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'draftIssueId': draftIssueId,
        if (title != null) r'title': title,
      });

  Input$UpdateProjectV2DraftIssueInput._(this._$data);

  factory Input$UpdateProjectV2DraftIssueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$draftIssueId = data['draftIssueId'];
    result$data['draftIssueId'] = (l$draftIssueId as String);
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$UpdateProjectV2DraftIssueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get draftIssueId => (_$data['draftIssueId'] as String);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$draftIssueId = draftIssueId;
    result$data['draftIssueId'] = l$draftIssueId;
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2DraftIssueInput<
          Input$UpdateProjectV2DraftIssueInput>
      get copyWith => CopyWith$Input$UpdateProjectV2DraftIssueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2DraftIssueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$draftIssueId = draftIssueId;
    final lOther$draftIssueId = other.draftIssueId;
    if (l$draftIssueId != lOther$draftIssueId) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assigneeIds = assigneeIds;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$draftIssueId = draftIssueId;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$draftIssueId,
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2DraftIssueInput(
    Input$UpdateProjectV2DraftIssueInput instance,
    TRes Function(Input$UpdateProjectV2DraftIssueInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput;

  factory CopyWith$Input$UpdateProjectV2DraftIssueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput;

  TRes call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? draftIssueId,
    String? title,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2DraftIssueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2DraftIssueInput _instance;

  final TRes Function(Input$UpdateProjectV2DraftIssueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assigneeIds = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? draftIssueId = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$UpdateProjectV2DraftIssueInput._({
        ..._instance._$data,
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (draftIssueId != _undefined && draftIssueId != null)
          'draftIssueId': (draftIssueId as String),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2DraftIssueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2DraftIssueInput(this._res);

  TRes _res;

  call({
    List<String>? assigneeIds,
    String? body,
    String? clientMutationId,
    String? draftIssueId,
    String? title,
  }) =>
      _res;
}

class Input$UpdateProjectV2Input {
  factory Input$UpdateProjectV2Input({
    String? clientMutationId,
    bool? closed,
    required String projectId,
    bool? public,
    String? readme,
    String? shortDescription,
    String? title,
  }) =>
      Input$UpdateProjectV2Input._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (closed != null) r'closed': closed,
        r'projectId': projectId,
        if (public != null) r'public': public,
        if (readme != null) r'readme': readme,
        if (shortDescription != null) r'shortDescription': shortDescription,
        if (title != null) r'title': title,
      });

  Input$UpdateProjectV2Input._(this._$data);

  factory Input$UpdateProjectV2Input.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('closed')) {
      final l$closed = data['closed'];
      result$data['closed'] = (l$closed as bool?);
    }
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    if (data.containsKey('public')) {
      final l$public = data['public'];
      result$data['public'] = (l$public as bool?);
    }
    if (data.containsKey('readme')) {
      final l$readme = data['readme'];
      result$data['readme'] = (l$readme as String?);
    }
    if (data.containsKey('shortDescription')) {
      final l$shortDescription = data['shortDescription'];
      result$data['shortDescription'] = (l$shortDescription as String?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$UpdateProjectV2Input._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get closed => (_$data['closed'] as bool?);
  String get projectId => (_$data['projectId'] as String);
  bool? get public => (_$data['public'] as bool?);
  String? get readme => (_$data['readme'] as String?);
  String? get shortDescription => (_$data['shortDescription'] as String?);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('closed')) {
      final l$closed = closed;
      result$data['closed'] = l$closed;
    }
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    if (_$data.containsKey('public')) {
      final l$public = public;
      result$data['public'] = l$public;
    }
    if (_$data.containsKey('readme')) {
      final l$readme = readme;
      result$data['readme'] = l$readme;
    }
    if (_$data.containsKey('shortDescription')) {
      final l$shortDescription = shortDescription;
      result$data['shortDescription'] = l$shortDescription;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2Input<Input$UpdateProjectV2Input>
      get copyWith => CopyWith$Input$UpdateProjectV2Input(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2Input) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$closed = closed;
    final lOther$closed = other.closed;
    if (_$data.containsKey('closed') != other._$data.containsKey('closed')) {
      return false;
    }
    if (l$closed != lOther$closed) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$public = public;
    final lOther$public = other.public;
    if (_$data.containsKey('public') != other._$data.containsKey('public')) {
      return false;
    }
    if (l$public != lOther$public) {
      return false;
    }
    final l$readme = readme;
    final lOther$readme = other.readme;
    if (_$data.containsKey('readme') != other._$data.containsKey('readme')) {
      return false;
    }
    if (l$readme != lOther$readme) {
      return false;
    }
    final l$shortDescription = shortDescription;
    final lOther$shortDescription = other.shortDescription;
    if (_$data.containsKey('shortDescription') !=
        other._$data.containsKey('shortDescription')) {
      return false;
    }
    if (l$shortDescription != lOther$shortDescription) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$closed = closed;
    final l$projectId = projectId;
    final l$public = public;
    final l$readme = readme;
    final l$shortDescription = shortDescription;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('closed') ? l$closed : const {},
      l$projectId,
      _$data.containsKey('public') ? l$public : const {},
      _$data.containsKey('readme') ? l$readme : const {},
      _$data.containsKey('shortDescription') ? l$shortDescription : const {},
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2Input<TRes> {
  factory CopyWith$Input$UpdateProjectV2Input(
    Input$UpdateProjectV2Input instance,
    TRes Function(Input$UpdateProjectV2Input) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2Input;

  factory CopyWith$Input$UpdateProjectV2Input.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2Input;

  TRes call({
    String? clientMutationId,
    bool? closed,
    String? projectId,
    bool? public,
    String? readme,
    String? shortDescription,
    String? title,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2Input<TRes>
    implements CopyWith$Input$UpdateProjectV2Input<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2Input(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2Input _instance;

  final TRes Function(Input$UpdateProjectV2Input) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? closed = _undefined,
    Object? projectId = _undefined,
    Object? public = _undefined,
    Object? readme = _undefined,
    Object? shortDescription = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$UpdateProjectV2Input._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (closed != _undefined) 'closed': (closed as bool?),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (public != _undefined) 'public': (public as bool?),
        if (readme != _undefined) 'readme': (readme as String?),
        if (shortDescription != _undefined)
          'shortDescription': (shortDescription as String?),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2Input<TRes>
    implements CopyWith$Input$UpdateProjectV2Input<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2Input(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? closed,
    String? projectId,
    bool? public,
    String? readme,
    String? shortDescription,
    String? title,
  }) =>
      _res;
}

class Input$UpdateProjectV2ItemFieldValueInput {
  factory Input$UpdateProjectV2ItemFieldValueInput({
    String? clientMutationId,
    required String fieldId,
    required String itemId,
    required String projectId,
    required Input$ProjectV2FieldValue value,
  }) =>
      Input$UpdateProjectV2ItemFieldValueInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'fieldId': fieldId,
        r'itemId': itemId,
        r'projectId': projectId,
        r'value': value,
      });

  Input$UpdateProjectV2ItemFieldValueInput._(this._$data);

  factory Input$UpdateProjectV2ItemFieldValueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$fieldId = data['fieldId'];
    result$data['fieldId'] = (l$fieldId as String);
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    final l$value = data['value'];
    result$data['value'] =
        Input$ProjectV2FieldValue.fromJson((l$value as Map<String, dynamic>));
    return Input$UpdateProjectV2ItemFieldValueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get fieldId => (_$data['fieldId'] as String);
  String get itemId => (_$data['itemId'] as String);
  String get projectId => (_$data['projectId'] as String);
  Input$ProjectV2FieldValue get value =>
      (_$data['value'] as Input$ProjectV2FieldValue);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$fieldId = fieldId;
    result$data['fieldId'] = l$fieldId;
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    final l$value = value;
    result$data['value'] = l$value.toJson();
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2ItemFieldValueInput<
          Input$UpdateProjectV2ItemFieldValueInput>
      get copyWith => CopyWith$Input$UpdateProjectV2ItemFieldValueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2ItemFieldValueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$fieldId = fieldId;
    final lOther$fieldId = other.fieldId;
    if (l$fieldId != lOther$fieldId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    final l$value = value;
    final lOther$value = other.value;
    if (l$value != lOther$value) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$fieldId = fieldId;
    final l$itemId = itemId;
    final l$projectId = projectId;
    final l$value = value;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$fieldId,
      l$itemId,
      l$projectId,
      l$value,
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2ItemFieldValueInput(
    Input$UpdateProjectV2ItemFieldValueInput instance,
    TRes Function(Input$UpdateProjectV2ItemFieldValueInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput;

  factory CopyWith$Input$UpdateProjectV2ItemFieldValueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput;

  TRes call({
    String? clientMutationId,
    String? fieldId,
    String? itemId,
    String? projectId,
    Input$ProjectV2FieldValue? value,
  });
  CopyWith$Input$ProjectV2FieldValue<TRes> get value;
}

class _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2ItemFieldValueInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2ItemFieldValueInput _instance;

  final TRes Function(Input$UpdateProjectV2ItemFieldValueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? fieldId = _undefined,
    Object? itemId = _undefined,
    Object? projectId = _undefined,
    Object? value = _undefined,
  }) =>
      _then(Input$UpdateProjectV2ItemFieldValueInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (fieldId != _undefined && fieldId != null)
          'fieldId': (fieldId as String),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
        if (value != _undefined && value != null)
          'value': (value as Input$ProjectV2FieldValue),
      }));
  CopyWith$Input$ProjectV2FieldValue<TRes> get value {
    final local$value = _instance.value;
    return CopyWith$Input$ProjectV2FieldValue(
        local$value, (e) => call(value: e));
  }
}

class _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemFieldValueInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2ItemFieldValueInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? fieldId,
    String? itemId,
    String? projectId,
    Input$ProjectV2FieldValue? value,
  }) =>
      _res;
  CopyWith$Input$ProjectV2FieldValue<TRes> get value =>
      CopyWith$Input$ProjectV2FieldValue.stub(_res);
}

class Input$UpdateProjectV2ItemPositionInput {
  factory Input$UpdateProjectV2ItemPositionInput({
    String? afterId,
    String? clientMutationId,
    required String itemId,
    required String projectId,
  }) =>
      Input$UpdateProjectV2ItemPositionInput._({
        if (afterId != null) r'afterId': afterId,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'itemId': itemId,
        r'projectId': projectId,
      });

  Input$UpdateProjectV2ItemPositionInput._(this._$data);

  factory Input$UpdateProjectV2ItemPositionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('afterId')) {
      final l$afterId = data['afterId'];
      result$data['afterId'] = (l$afterId as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$itemId = data['itemId'];
    result$data['itemId'] = (l$itemId as String);
    final l$projectId = data['projectId'];
    result$data['projectId'] = (l$projectId as String);
    return Input$UpdateProjectV2ItemPositionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get afterId => (_$data['afterId'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get itemId => (_$data['itemId'] as String);
  String get projectId => (_$data['projectId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('afterId')) {
      final l$afterId = afterId;
      result$data['afterId'] = l$afterId;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$itemId = itemId;
    result$data['itemId'] = l$itemId;
    final l$projectId = projectId;
    result$data['projectId'] = l$projectId;
    return result$data;
  }

  CopyWith$Input$UpdateProjectV2ItemPositionInput<
          Input$UpdateProjectV2ItemPositionInput>
      get copyWith => CopyWith$Input$UpdateProjectV2ItemPositionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateProjectV2ItemPositionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$afterId = afterId;
    final lOther$afterId = other.afterId;
    if (_$data.containsKey('afterId') != other._$data.containsKey('afterId')) {
      return false;
    }
    if (l$afterId != lOther$afterId) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$itemId = itemId;
    final lOther$itemId = other.itemId;
    if (l$itemId != lOther$itemId) {
      return false;
    }
    final l$projectId = projectId;
    final lOther$projectId = other.projectId;
    if (l$projectId != lOther$projectId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$afterId = afterId;
    final l$clientMutationId = clientMutationId;
    final l$itemId = itemId;
    final l$projectId = projectId;
    return Object.hashAll([
      _$data.containsKey('afterId') ? l$afterId : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$itemId,
      l$projectId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  factory CopyWith$Input$UpdateProjectV2ItemPositionInput(
    Input$UpdateProjectV2ItemPositionInput instance,
    TRes Function(Input$UpdateProjectV2ItemPositionInput) then,
  ) = _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput;

  factory CopyWith$Input$UpdateProjectV2ItemPositionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput;

  TRes call({
    String? afterId,
    String? clientMutationId,
    String? itemId,
    String? projectId,
  });
}

class _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  _CopyWithImpl$Input$UpdateProjectV2ItemPositionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateProjectV2ItemPositionInput _instance;

  final TRes Function(Input$UpdateProjectV2ItemPositionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? afterId = _undefined,
    Object? clientMutationId = _undefined,
    Object? itemId = _undefined,
    Object? projectId = _undefined,
  }) =>
      _then(Input$UpdateProjectV2ItemPositionInput._({
        ..._instance._$data,
        if (afterId != _undefined) 'afterId': (afterId as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (itemId != _undefined && itemId != null)
          'itemId': (itemId as String),
        if (projectId != _undefined && projectId != null)
          'projectId': (projectId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput<TRes>
    implements CopyWith$Input$UpdateProjectV2ItemPositionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateProjectV2ItemPositionInput(this._res);

  TRes _res;

  call({
    String? afterId,
    String? clientMutationId,
    String? itemId,
    String? projectId,
  }) =>
      _res;
}

class Input$UpdatePullRequestBranchInput {
  factory Input$UpdatePullRequestBranchInput({
    String? clientMutationId,
    String? expectedHeadOid,
    required String pullRequestId,
  }) =>
      Input$UpdatePullRequestBranchInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (expectedHeadOid != null) r'expectedHeadOid': expectedHeadOid,
        r'pullRequestId': pullRequestId,
      });

  Input$UpdatePullRequestBranchInput._(this._$data);

  factory Input$UpdatePullRequestBranchInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = data['expectedHeadOid'];
      result$data['expectedHeadOid'] = (l$expectedHeadOid as String?);
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    return Input$UpdatePullRequestBranchInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get expectedHeadOid => (_$data['expectedHeadOid'] as String?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('expectedHeadOid')) {
      final l$expectedHeadOid = expectedHeadOid;
      result$data['expectedHeadOid'] = l$expectedHeadOid;
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestBranchInput<
          Input$UpdatePullRequestBranchInput>
      get copyWith => CopyWith$Input$UpdatePullRequestBranchInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestBranchInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$expectedHeadOid = expectedHeadOid;
    final lOther$expectedHeadOid = other.expectedHeadOid;
    if (_$data.containsKey('expectedHeadOid') !=
        other._$data.containsKey('expectedHeadOid')) {
      return false;
    }
    if (l$expectedHeadOid != lOther$expectedHeadOid) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$expectedHeadOid = expectedHeadOid;
    final l$pullRequestId = pullRequestId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('expectedHeadOid') ? l$expectedHeadOid : const {},
      l$pullRequestId,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestBranchInput(
    Input$UpdatePullRequestBranchInput instance,
    TRes Function(Input$UpdatePullRequestBranchInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestBranchInput;

  factory CopyWith$Input$UpdatePullRequestBranchInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestBranchInput;

  TRes call({
    String? clientMutationId,
    String? expectedHeadOid,
    String? pullRequestId,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestBranchInput<TRes>
    implements CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestBranchInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestBranchInput _instance;

  final TRes Function(Input$UpdatePullRequestBranchInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? expectedHeadOid = _undefined,
    Object? pullRequestId = _undefined,
  }) =>
      _then(Input$UpdatePullRequestBranchInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (expectedHeadOid != _undefined)
          'expectedHeadOid': (expectedHeadOid as String?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestBranchInput<TRes>
    implements CopyWith$Input$UpdatePullRequestBranchInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestBranchInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? expectedHeadOid,
    String? pullRequestId,
  }) =>
      _res;
}

class Input$UpdatePullRequestInput {
  factory Input$UpdatePullRequestInput({
    List<String>? assigneeIds,
    String? baseRefName,
    String? body,
    String? clientMutationId,
    List<String>? labelIds,
    bool? maintainerCanModify,
    String? milestoneId,
    List<String>? projectIds,
    required String pullRequestId,
    Enum$PullRequestUpdateState? state,
    String? title,
  }) =>
      Input$UpdatePullRequestInput._({
        if (assigneeIds != null) r'assigneeIds': assigneeIds,
        if (baseRefName != null) r'baseRefName': baseRefName,
        if (body != null) r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (labelIds != null) r'labelIds': labelIds,
        if (maintainerCanModify != null)
          r'maintainerCanModify': maintainerCanModify,
        if (milestoneId != null) r'milestoneId': milestoneId,
        if (projectIds != null) r'projectIds': projectIds,
        r'pullRequestId': pullRequestId,
        if (state != null) r'state': state,
        if (title != null) r'title': title,
      });

  Input$UpdatePullRequestInput._(this._$data);

  factory Input$UpdatePullRequestInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('assigneeIds')) {
      final l$assigneeIds = data['assigneeIds'];
      result$data['assigneeIds'] =
          (l$assigneeIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('baseRefName')) {
      final l$baseRefName = data['baseRefName'];
      result$data['baseRefName'] = (l$baseRefName as String?);
    }
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('labelIds')) {
      final l$labelIds = data['labelIds'];
      result$data['labelIds'] =
          (l$labelIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = data['maintainerCanModify'];
      result$data['maintainerCanModify'] = (l$maintainerCanModify as bool?);
    }
    if (data.containsKey('milestoneId')) {
      final l$milestoneId = data['milestoneId'];
      result$data['milestoneId'] = (l$milestoneId as String?);
    }
    if (data.containsKey('projectIds')) {
      final l$projectIds = data['projectIds'];
      result$data['projectIds'] =
          (l$projectIds as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    final l$pullRequestId = data['pullRequestId'];
    result$data['pullRequestId'] = (l$pullRequestId as String);
    if (data.containsKey('state')) {
      final l$state = data['state'];
      result$data['state'] = l$state == null
          ? null
          : fromJson$Enum$PullRequestUpdateState((l$state as String));
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$UpdatePullRequestInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<String>? get assigneeIds => (_$data['assigneeIds'] as List<String>?);
  String? get baseRefName => (_$data['baseRefName'] as String?);
  String? get body => (_$data['body'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<String>? get labelIds => (_$data['labelIds'] as List<String>?);
  bool? get maintainerCanModify => (_$data['maintainerCanModify'] as bool?);
  String? get milestoneId => (_$data['milestoneId'] as String?);
  List<String>? get projectIds => (_$data['projectIds'] as List<String>?);
  String get pullRequestId => (_$data['pullRequestId'] as String);
  Enum$PullRequestUpdateState? get state =>
      (_$data['state'] as Enum$PullRequestUpdateState?);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('assigneeIds')) {
      final l$assigneeIds = assigneeIds;
      result$data['assigneeIds'] = l$assigneeIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('baseRefName')) {
      final l$baseRefName = baseRefName;
      result$data['baseRefName'] = l$baseRefName;
    }
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('labelIds')) {
      final l$labelIds = labelIds;
      result$data['labelIds'] = l$labelIds?.map((e) => e).toList();
    }
    if (_$data.containsKey('maintainerCanModify')) {
      final l$maintainerCanModify = maintainerCanModify;
      result$data['maintainerCanModify'] = l$maintainerCanModify;
    }
    if (_$data.containsKey('milestoneId')) {
      final l$milestoneId = milestoneId;
      result$data['milestoneId'] = l$milestoneId;
    }
    if (_$data.containsKey('projectIds')) {
      final l$projectIds = projectIds;
      result$data['projectIds'] = l$projectIds?.map((e) => e).toList();
    }
    final l$pullRequestId = pullRequestId;
    result$data['pullRequestId'] = l$pullRequestId;
    if (_$data.containsKey('state')) {
      final l$state = state;
      result$data['state'] =
          l$state == null ? null : toJson$Enum$PullRequestUpdateState(l$state);
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestInput<Input$UpdatePullRequestInput>
      get copyWith => CopyWith$Input$UpdatePullRequestInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$assigneeIds = assigneeIds;
    final lOther$assigneeIds = other.assigneeIds;
    if (_$data.containsKey('assigneeIds') !=
        other._$data.containsKey('assigneeIds')) {
      return false;
    }
    if (l$assigneeIds != null && lOther$assigneeIds != null) {
      if (l$assigneeIds.length != lOther$assigneeIds.length) {
        return false;
      }
      for (int i = 0; i < l$assigneeIds.length; i++) {
        final l$assigneeIds$entry = l$assigneeIds[i];
        final lOther$assigneeIds$entry = lOther$assigneeIds[i];
        if (l$assigneeIds$entry != lOther$assigneeIds$entry) {
          return false;
        }
      }
    } else if (l$assigneeIds != lOther$assigneeIds) {
      return false;
    }
    final l$baseRefName = baseRefName;
    final lOther$baseRefName = other.baseRefName;
    if (_$data.containsKey('baseRefName') !=
        other._$data.containsKey('baseRefName')) {
      return false;
    }
    if (l$baseRefName != lOther$baseRefName) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$labelIds = labelIds;
    final lOther$labelIds = other.labelIds;
    if (_$data.containsKey('labelIds') !=
        other._$data.containsKey('labelIds')) {
      return false;
    }
    if (l$labelIds != null && lOther$labelIds != null) {
      if (l$labelIds.length != lOther$labelIds.length) {
        return false;
      }
      for (int i = 0; i < l$labelIds.length; i++) {
        final l$labelIds$entry = l$labelIds[i];
        final lOther$labelIds$entry = lOther$labelIds[i];
        if (l$labelIds$entry != lOther$labelIds$entry) {
          return false;
        }
      }
    } else if (l$labelIds != lOther$labelIds) {
      return false;
    }
    final l$maintainerCanModify = maintainerCanModify;
    final lOther$maintainerCanModify = other.maintainerCanModify;
    if (_$data.containsKey('maintainerCanModify') !=
        other._$data.containsKey('maintainerCanModify')) {
      return false;
    }
    if (l$maintainerCanModify != lOther$maintainerCanModify) {
      return false;
    }
    final l$milestoneId = milestoneId;
    final lOther$milestoneId = other.milestoneId;
    if (_$data.containsKey('milestoneId') !=
        other._$data.containsKey('milestoneId')) {
      return false;
    }
    if (l$milestoneId != lOther$milestoneId) {
      return false;
    }
    final l$projectIds = projectIds;
    final lOther$projectIds = other.projectIds;
    if (_$data.containsKey('projectIds') !=
        other._$data.containsKey('projectIds')) {
      return false;
    }
    if (l$projectIds != null && lOther$projectIds != null) {
      if (l$projectIds.length != lOther$projectIds.length) {
        return false;
      }
      for (int i = 0; i < l$projectIds.length; i++) {
        final l$projectIds$entry = l$projectIds[i];
        final lOther$projectIds$entry = lOther$projectIds[i];
        if (l$projectIds$entry != lOther$projectIds$entry) {
          return false;
        }
      }
    } else if (l$projectIds != lOther$projectIds) {
      return false;
    }
    final l$pullRequestId = pullRequestId;
    final lOther$pullRequestId = other.pullRequestId;
    if (l$pullRequestId != lOther$pullRequestId) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (_$data.containsKey('state') != other._$data.containsKey('state')) {
      return false;
    }
    if (l$state != lOther$state) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$assigneeIds = assigneeIds;
    final l$baseRefName = baseRefName;
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$labelIds = labelIds;
    final l$maintainerCanModify = maintainerCanModify;
    final l$milestoneId = milestoneId;
    final l$projectIds = projectIds;
    final l$pullRequestId = pullRequestId;
    final l$state = state;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('assigneeIds')
          ? l$assigneeIds == null
              ? null
              : Object.hashAll(l$assigneeIds.map((v) => v))
          : const {},
      _$data.containsKey('baseRefName') ? l$baseRefName : const {},
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('labelIds')
          ? l$labelIds == null
              ? null
              : Object.hashAll(l$labelIds.map((v) => v))
          : const {},
      _$data.containsKey('maintainerCanModify')
          ? l$maintainerCanModify
          : const {},
      _$data.containsKey('milestoneId') ? l$milestoneId : const {},
      _$data.containsKey('projectIds')
          ? l$projectIds == null
              ? null
              : Object.hashAll(l$projectIds.map((v) => v))
          : const {},
      l$pullRequestId,
      _$data.containsKey('state') ? l$state : const {},
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestInput(
    Input$UpdatePullRequestInput instance,
    TRes Function(Input$UpdatePullRequestInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestInput;

  factory CopyWith$Input$UpdatePullRequestInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestInput;

  TRes call({
    List<String>? assigneeIds,
    String? baseRefName,
    String? body,
    String? clientMutationId,
    List<String>? labelIds,
    bool? maintainerCanModify,
    String? milestoneId,
    List<String>? projectIds,
    String? pullRequestId,
    Enum$PullRequestUpdateState? state,
    String? title,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestInput<TRes>
    implements CopyWith$Input$UpdatePullRequestInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestInput _instance;

  final TRes Function(Input$UpdatePullRequestInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? assigneeIds = _undefined,
    Object? baseRefName = _undefined,
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? labelIds = _undefined,
    Object? maintainerCanModify = _undefined,
    Object? milestoneId = _undefined,
    Object? projectIds = _undefined,
    Object? pullRequestId = _undefined,
    Object? state = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$UpdatePullRequestInput._({
        ..._instance._$data,
        if (assigneeIds != _undefined)
          'assigneeIds': (assigneeIds as List<String>?),
        if (baseRefName != _undefined) 'baseRefName': (baseRefName as String?),
        if (body != _undefined) 'body': (body as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (labelIds != _undefined) 'labelIds': (labelIds as List<String>?),
        if (maintainerCanModify != _undefined)
          'maintainerCanModify': (maintainerCanModify as bool?),
        if (milestoneId != _undefined) 'milestoneId': (milestoneId as String?),
        if (projectIds != _undefined)
          'projectIds': (projectIds as List<String>?),
        if (pullRequestId != _undefined && pullRequestId != null)
          'pullRequestId': (pullRequestId as String),
        if (state != _undefined)
          'state': (state as Enum$PullRequestUpdateState?),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestInput<TRes>
    implements CopyWith$Input$UpdatePullRequestInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestInput(this._res);

  TRes _res;

  call({
    List<String>? assigneeIds,
    String? baseRefName,
    String? body,
    String? clientMutationId,
    List<String>? labelIds,
    bool? maintainerCanModify,
    String? milestoneId,
    List<String>? projectIds,
    String? pullRequestId,
    Enum$PullRequestUpdateState? state,
    String? title,
  }) =>
      _res;
}

class Input$UpdatePullRequestReviewCommentInput {
  factory Input$UpdatePullRequestReviewCommentInput({
    required String body,
    String? clientMutationId,
    required String pullRequestReviewCommentId,
  }) =>
      Input$UpdatePullRequestReviewCommentInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestReviewCommentId': pullRequestReviewCommentId,
      });

  Input$UpdatePullRequestReviewCommentInput._(this._$data);

  factory Input$UpdatePullRequestReviewCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestReviewCommentId = data['pullRequestReviewCommentId'];
    result$data['pullRequestReviewCommentId'] =
        (l$pullRequestReviewCommentId as String);
    return Input$UpdatePullRequestReviewCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestReviewCommentId =>
      (_$data['pullRequestReviewCommentId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    result$data['pullRequestReviewCommentId'] = l$pullRequestReviewCommentId;
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestReviewCommentInput<
          Input$UpdatePullRequestReviewCommentInput>
      get copyWith => CopyWith$Input$UpdatePullRequestReviewCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestReviewCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    final lOther$pullRequestReviewCommentId = other.pullRequestReviewCommentId;
    if (l$pullRequestReviewCommentId != lOther$pullRequestReviewCommentId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewCommentId = pullRequestReviewCommentId;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestReviewCommentId,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestReviewCommentInput(
    Input$UpdatePullRequestReviewCommentInput instance,
    TRes Function(Input$UpdatePullRequestReviewCommentInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput;

  factory CopyWith$Input$UpdatePullRequestReviewCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? pullRequestReviewCommentId,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestReviewCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestReviewCommentInput _instance;

  final TRes Function(Input$UpdatePullRequestReviewCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewCommentId = _undefined,
  }) =>
      _then(Input$UpdatePullRequestReviewCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewCommentId != _undefined &&
            pullRequestReviewCommentId != null)
          'pullRequestReviewCommentId': (pullRequestReviewCommentId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestReviewCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? pullRequestReviewCommentId,
  }) =>
      _res;
}

class Input$UpdatePullRequestReviewInput {
  factory Input$UpdatePullRequestReviewInput({
    required String body,
    String? clientMutationId,
    required String pullRequestReviewId,
  }) =>
      Input$UpdatePullRequestReviewInput._({
        r'body': body,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'pullRequestReviewId': pullRequestReviewId,
      });

  Input$UpdatePullRequestReviewInput._(this._$data);

  factory Input$UpdatePullRequestReviewInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$pullRequestReviewId = data['pullRequestReviewId'];
    result$data['pullRequestReviewId'] = (l$pullRequestReviewId as String);
    return Input$UpdatePullRequestReviewInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get pullRequestReviewId => (_$data['pullRequestReviewId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    result$data['pullRequestReviewId'] = l$pullRequestReviewId;
    return result$data;
  }

  CopyWith$Input$UpdatePullRequestReviewInput<
          Input$UpdatePullRequestReviewInput>
      get copyWith => CopyWith$Input$UpdatePullRequestReviewInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdatePullRequestReviewInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$pullRequestReviewId = pullRequestReviewId;
    final lOther$pullRequestReviewId = other.pullRequestReviewId;
    if (l$pullRequestReviewId != lOther$pullRequestReviewId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$clientMutationId = clientMutationId;
    final l$pullRequestReviewId = pullRequestReviewId;
    return Object.hashAll([
      l$body,
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$pullRequestReviewId,
    ]);
  }
}

abstract class CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  factory CopyWith$Input$UpdatePullRequestReviewInput(
    Input$UpdatePullRequestReviewInput instance,
    TRes Function(Input$UpdatePullRequestReviewInput) then,
  ) = _CopyWithImpl$Input$UpdatePullRequestReviewInput;

  factory CopyWith$Input$UpdatePullRequestReviewInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdatePullRequestReviewInput;

  TRes call({
    String? body,
    String? clientMutationId,
    String? pullRequestReviewId,
  });
}

class _CopyWithImpl$Input$UpdatePullRequestReviewInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  _CopyWithImpl$Input$UpdatePullRequestReviewInput(
    this._instance,
    this._then,
  );

  final Input$UpdatePullRequestReviewInput _instance;

  final TRes Function(Input$UpdatePullRequestReviewInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? clientMutationId = _undefined,
    Object? pullRequestReviewId = _undefined,
  }) =>
      _then(Input$UpdatePullRequestReviewInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (pullRequestReviewId != _undefined && pullRequestReviewId != null)
          'pullRequestReviewId': (pullRequestReviewId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdatePullRequestReviewInput<TRes>
    implements CopyWith$Input$UpdatePullRequestReviewInput<TRes> {
  _CopyWithStubImpl$Input$UpdatePullRequestReviewInput(this._res);

  TRes _res;

  call({
    String? body,
    String? clientMutationId,
    String? pullRequestReviewId,
  }) =>
      _res;
}

class Input$UpdateRefInput {
  factory Input$UpdateRefInput({
    String? clientMutationId,
    bool? force,
    required String oid,
    required String refId,
  }) =>
      Input$UpdateRefInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (force != null) r'force': force,
        r'oid': oid,
        r'refId': refId,
      });

  Input$UpdateRefInput._(this._$data);

  factory Input$UpdateRefInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('force')) {
      final l$force = data['force'];
      result$data['force'] = (l$force as bool?);
    }
    final l$oid = data['oid'];
    result$data['oid'] = (l$oid as String);
    final l$refId = data['refId'];
    result$data['refId'] = (l$refId as String);
    return Input$UpdateRefInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool? get force => (_$data['force'] as bool?);
  String get oid => (_$data['oid'] as String);
  String get refId => (_$data['refId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('force')) {
      final l$force = force;
      result$data['force'] = l$force;
    }
    final l$oid = oid;
    result$data['oid'] = l$oid;
    final l$refId = refId;
    result$data['refId'] = l$refId;
    return result$data;
  }

  CopyWith$Input$UpdateRefInput<Input$UpdateRefInput> get copyWith =>
      CopyWith$Input$UpdateRefInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRefInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$force = force;
    final lOther$force = other.force;
    if (_$data.containsKey('force') != other._$data.containsKey('force')) {
      return false;
    }
    if (l$force != lOther$force) {
      return false;
    }
    final l$oid = oid;
    final lOther$oid = other.oid;
    if (l$oid != lOther$oid) {
      return false;
    }
    final l$refId = refId;
    final lOther$refId = other.refId;
    if (l$refId != lOther$refId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$force = force;
    final l$oid = oid;
    final l$refId = refId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('force') ? l$force : const {},
      l$oid,
      l$refId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateRefInput<TRes> {
  factory CopyWith$Input$UpdateRefInput(
    Input$UpdateRefInput instance,
    TRes Function(Input$UpdateRefInput) then,
  ) = _CopyWithImpl$Input$UpdateRefInput;

  factory CopyWith$Input$UpdateRefInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRefInput;

  TRes call({
    String? clientMutationId,
    bool? force,
    String? oid,
    String? refId,
  });
}

class _CopyWithImpl$Input$UpdateRefInput<TRes>
    implements CopyWith$Input$UpdateRefInput<TRes> {
  _CopyWithImpl$Input$UpdateRefInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRefInput _instance;

  final TRes Function(Input$UpdateRefInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? force = _undefined,
    Object? oid = _undefined,
    Object? refId = _undefined,
  }) =>
      _then(Input$UpdateRefInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (force != _undefined) 'force': (force as bool?),
        if (oid != _undefined && oid != null) 'oid': (oid as String),
        if (refId != _undefined && refId != null) 'refId': (refId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateRefInput<TRes>
    implements CopyWith$Input$UpdateRefInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRefInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    bool? force,
    String? oid,
    String? refId,
  }) =>
      _res;
}

class Input$UpdateRefsInput {
  factory Input$UpdateRefsInput({
    String? clientMutationId,
    required List<Input$RefUpdate> refUpdates,
    required String repositoryId,
  }) =>
      Input$UpdateRefsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'refUpdates': refUpdates,
        r'repositoryId': repositoryId,
      });

  Input$UpdateRefsInput._(this._$data);

  factory Input$UpdateRefsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$refUpdates = data['refUpdates'];
    result$data['refUpdates'] = (l$refUpdates as List<dynamic>)
        .map((e) => Input$RefUpdate.fromJson((e as Map<String, dynamic>)))
        .toList();
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    return Input$UpdateRefsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  List<Input$RefUpdate> get refUpdates =>
      (_$data['refUpdates'] as List<Input$RefUpdate>);
  String get repositoryId => (_$data['repositoryId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$refUpdates = refUpdates;
    result$data['refUpdates'] = l$refUpdates.map((e) => e.toJson()).toList();
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    return result$data;
  }

  CopyWith$Input$UpdateRefsInput<Input$UpdateRefsInput> get copyWith =>
      CopyWith$Input$UpdateRefsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRefsInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$refUpdates = refUpdates;
    final lOther$refUpdates = other.refUpdates;
    if (l$refUpdates.length != lOther$refUpdates.length) {
      return false;
    }
    for (int i = 0; i < l$refUpdates.length; i++) {
      final l$refUpdates$entry = l$refUpdates[i];
      final lOther$refUpdates$entry = lOther$refUpdates[i];
      if (l$refUpdates$entry != lOther$refUpdates$entry) {
        return false;
      }
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$refUpdates = refUpdates;
    final l$repositoryId = repositoryId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      Object.hashAll(l$refUpdates.map((v) => v)),
      l$repositoryId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateRefsInput<TRes> {
  factory CopyWith$Input$UpdateRefsInput(
    Input$UpdateRefsInput instance,
    TRes Function(Input$UpdateRefsInput) then,
  ) = _CopyWithImpl$Input$UpdateRefsInput;

  factory CopyWith$Input$UpdateRefsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRefsInput;

  TRes call({
    String? clientMutationId,
    List<Input$RefUpdate>? refUpdates,
    String? repositoryId,
  });
  TRes refUpdates(
      Iterable<Input$RefUpdate> Function(
              Iterable<CopyWith$Input$RefUpdate<Input$RefUpdate>>)
          _fn);
}

class _CopyWithImpl$Input$UpdateRefsInput<TRes>
    implements CopyWith$Input$UpdateRefsInput<TRes> {
  _CopyWithImpl$Input$UpdateRefsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRefsInput _instance;

  final TRes Function(Input$UpdateRefsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? refUpdates = _undefined,
    Object? repositoryId = _undefined,
  }) =>
      _then(Input$UpdateRefsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (refUpdates != _undefined && refUpdates != null)
          'refUpdates': (refUpdates as List<Input$RefUpdate>),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
      }));
  TRes refUpdates(
          Iterable<Input$RefUpdate> Function(
                  Iterable<CopyWith$Input$RefUpdate<Input$RefUpdate>>)
              _fn) =>
      call(
          refUpdates:
              _fn(_instance.refUpdates.map((e) => CopyWith$Input$RefUpdate(
                    e,
                    (i) => i,
                  ))).toList());
}

class _CopyWithStubImpl$Input$UpdateRefsInput<TRes>
    implements CopyWith$Input$UpdateRefsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRefsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    List<Input$RefUpdate>? refUpdates,
    String? repositoryId,
  }) =>
      _res;
  refUpdates(_fn) => _res;
}

class Input$UpdateRepositoryInput {
  factory Input$UpdateRepositoryInput({
    String? clientMutationId,
    String? description,
    bool? hasDiscussionsEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasWikiEnabled,
    String? homepageUrl,
    String? name,
    required String repositoryId,
    bool? template,
  }) =>
      Input$UpdateRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (description != null) r'description': description,
        if (hasDiscussionsEnabled != null)
          r'hasDiscussionsEnabled': hasDiscussionsEnabled,
        if (hasIssuesEnabled != null) r'hasIssuesEnabled': hasIssuesEnabled,
        if (hasProjectsEnabled != null)
          r'hasProjectsEnabled': hasProjectsEnabled,
        if (hasWikiEnabled != null) r'hasWikiEnabled': hasWikiEnabled,
        if (homepageUrl != null) r'homepageUrl': homepageUrl,
        if (name != null) r'name': name,
        r'repositoryId': repositoryId,
        if (template != null) r'template': template,
      });

  Input$UpdateRepositoryInput._(this._$data);

  factory Input$UpdateRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = (l$description as String?);
    }
    if (data.containsKey('hasDiscussionsEnabled')) {
      final l$hasDiscussionsEnabled = data['hasDiscussionsEnabled'];
      result$data['hasDiscussionsEnabled'] = (l$hasDiscussionsEnabled as bool?);
    }
    if (data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = data['hasIssuesEnabled'];
      result$data['hasIssuesEnabled'] = (l$hasIssuesEnabled as bool?);
    }
    if (data.containsKey('hasProjectsEnabled')) {
      final l$hasProjectsEnabled = data['hasProjectsEnabled'];
      result$data['hasProjectsEnabled'] = (l$hasProjectsEnabled as bool?);
    }
    if (data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = data['hasWikiEnabled'];
      result$data['hasWikiEnabled'] = (l$hasWikiEnabled as bool?);
    }
    if (data.containsKey('homepageUrl')) {
      final l$homepageUrl = data['homepageUrl'];
      result$data['homepageUrl'] = (l$homepageUrl as String?);
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = (l$name as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    if (data.containsKey('template')) {
      final l$template = data['template'];
      result$data['template'] = (l$template as bool?);
    }
    return Input$UpdateRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String? get description => (_$data['description'] as String?);
  bool? get hasDiscussionsEnabled => (_$data['hasDiscussionsEnabled'] as bool?);
  bool? get hasIssuesEnabled => (_$data['hasIssuesEnabled'] as bool?);
  bool? get hasProjectsEnabled => (_$data['hasProjectsEnabled'] as bool?);
  bool? get hasWikiEnabled => (_$data['hasWikiEnabled'] as bool?);
  String? get homepageUrl => (_$data['homepageUrl'] as String?);
  String? get name => (_$data['name'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  bool? get template => (_$data['template'] as bool?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description;
    }
    if (_$data.containsKey('hasDiscussionsEnabled')) {
      final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
      result$data['hasDiscussionsEnabled'] = l$hasDiscussionsEnabled;
    }
    if (_$data.containsKey('hasIssuesEnabled')) {
      final l$hasIssuesEnabled = hasIssuesEnabled;
      result$data['hasIssuesEnabled'] = l$hasIssuesEnabled;
    }
    if (_$data.containsKey('hasProjectsEnabled')) {
      final l$hasProjectsEnabled = hasProjectsEnabled;
      result$data['hasProjectsEnabled'] = l$hasProjectsEnabled;
    }
    if (_$data.containsKey('hasWikiEnabled')) {
      final l$hasWikiEnabled = hasWikiEnabled;
      result$data['hasWikiEnabled'] = l$hasWikiEnabled;
    }
    if (_$data.containsKey('homepageUrl')) {
      final l$homepageUrl = homepageUrl;
      result$data['homepageUrl'] = l$homepageUrl;
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    if (_$data.containsKey('template')) {
      final l$template = template;
      result$data['template'] = l$template;
    }
    return result$data;
  }

  CopyWith$Input$UpdateRepositoryInput<Input$UpdateRepositoryInput>
      get copyWith => CopyWith$Input$UpdateRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
    final lOther$hasDiscussionsEnabled = other.hasDiscussionsEnabled;
    if (_$data.containsKey('hasDiscussionsEnabled') !=
        other._$data.containsKey('hasDiscussionsEnabled')) {
      return false;
    }
    if (l$hasDiscussionsEnabled != lOther$hasDiscussionsEnabled) {
      return false;
    }
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final lOther$hasIssuesEnabled = other.hasIssuesEnabled;
    if (_$data.containsKey('hasIssuesEnabled') !=
        other._$data.containsKey('hasIssuesEnabled')) {
      return false;
    }
    if (l$hasIssuesEnabled != lOther$hasIssuesEnabled) {
      return false;
    }
    final l$hasProjectsEnabled = hasProjectsEnabled;
    final lOther$hasProjectsEnabled = other.hasProjectsEnabled;
    if (_$data.containsKey('hasProjectsEnabled') !=
        other._$data.containsKey('hasProjectsEnabled')) {
      return false;
    }
    if (l$hasProjectsEnabled != lOther$hasProjectsEnabled) {
      return false;
    }
    final l$hasWikiEnabled = hasWikiEnabled;
    final lOther$hasWikiEnabled = other.hasWikiEnabled;
    if (_$data.containsKey('hasWikiEnabled') !=
        other._$data.containsKey('hasWikiEnabled')) {
      return false;
    }
    if (l$hasWikiEnabled != lOther$hasWikiEnabled) {
      return false;
    }
    final l$homepageUrl = homepageUrl;
    final lOther$homepageUrl = other.homepageUrl;
    if (_$data.containsKey('homepageUrl') !=
        other._$data.containsKey('homepageUrl')) {
      return false;
    }
    if (l$homepageUrl != lOther$homepageUrl) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$template = template;
    final lOther$template = other.template;
    if (_$data.containsKey('template') !=
        other._$data.containsKey('template')) {
      return false;
    }
    if (l$template != lOther$template) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$description = description;
    final l$hasDiscussionsEnabled = hasDiscussionsEnabled;
    final l$hasIssuesEnabled = hasIssuesEnabled;
    final l$hasProjectsEnabled = hasProjectsEnabled;
    final l$hasWikiEnabled = hasWikiEnabled;
    final l$homepageUrl = homepageUrl;
    final l$name = name;
    final l$repositoryId = repositoryId;
    final l$template = template;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('hasDiscussionsEnabled')
          ? l$hasDiscussionsEnabled
          : const {},
      _$data.containsKey('hasIssuesEnabled') ? l$hasIssuesEnabled : const {},
      _$data.containsKey('hasProjectsEnabled')
          ? l$hasProjectsEnabled
          : const {},
      _$data.containsKey('hasWikiEnabled') ? l$hasWikiEnabled : const {},
      _$data.containsKey('homepageUrl') ? l$homepageUrl : const {},
      _$data.containsKey('name') ? l$name : const {},
      l$repositoryId,
      _$data.containsKey('template') ? l$template : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateRepositoryInput<TRes> {
  factory CopyWith$Input$UpdateRepositoryInput(
    Input$UpdateRepositoryInput instance,
    TRes Function(Input$UpdateRepositoryInput) then,
  ) = _CopyWithImpl$Input$UpdateRepositoryInput;

  factory CopyWith$Input$UpdateRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateRepositoryInput;

  TRes call({
    String? clientMutationId,
    String? description,
    bool? hasDiscussionsEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasWikiEnabled,
    String? homepageUrl,
    String? name,
    String? repositoryId,
    bool? template,
  });
}

class _CopyWithImpl$Input$UpdateRepositoryInput<TRes>
    implements CopyWith$Input$UpdateRepositoryInput<TRes> {
  _CopyWithImpl$Input$UpdateRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRepositoryInput _instance;

  final TRes Function(Input$UpdateRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? description = _undefined,
    Object? hasDiscussionsEnabled = _undefined,
    Object? hasIssuesEnabled = _undefined,
    Object? hasProjectsEnabled = _undefined,
    Object? hasWikiEnabled = _undefined,
    Object? homepageUrl = _undefined,
    Object? name = _undefined,
    Object? repositoryId = _undefined,
    Object? template = _undefined,
  }) =>
      _then(Input$UpdateRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (description != _undefined) 'description': (description as String?),
        if (hasDiscussionsEnabled != _undefined)
          'hasDiscussionsEnabled': (hasDiscussionsEnabled as bool?),
        if (hasIssuesEnabled != _undefined)
          'hasIssuesEnabled': (hasIssuesEnabled as bool?),
        if (hasProjectsEnabled != _undefined)
          'hasProjectsEnabled': (hasProjectsEnabled as bool?),
        if (hasWikiEnabled != _undefined)
          'hasWikiEnabled': (hasWikiEnabled as bool?),
        if (homepageUrl != _undefined) 'homepageUrl': (homepageUrl as String?),
        if (name != _undefined) 'name': (name as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (template != _undefined) 'template': (template as bool?),
      }));
}

class _CopyWithStubImpl$Input$UpdateRepositoryInput<TRes>
    implements CopyWith$Input$UpdateRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? description,
    bool? hasDiscussionsEnabled,
    bool? hasIssuesEnabled,
    bool? hasProjectsEnabled,
    bool? hasWikiEnabled,
    String? homepageUrl,
    String? name,
    String? repositoryId,
    bool? template,
  }) =>
      _res;
}

class Input$UpdateRepositoryWebCommitSignoffSettingInput {
  factory Input$UpdateRepositoryWebCommitSignoffSettingInput({
    String? clientMutationId,
    required String repositoryId,
    required bool webCommitSignoffRequired,
  }) =>
      Input$UpdateRepositoryWebCommitSignoffSettingInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'webCommitSignoffRequired': webCommitSignoffRequired,
      });

  Input$UpdateRepositoryWebCommitSignoffSettingInput._(this._$data);

  factory Input$UpdateRepositoryWebCommitSignoffSettingInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$webCommitSignoffRequired = data['webCommitSignoffRequired'];
    result$data['webCommitSignoffRequired'] =
        (l$webCommitSignoffRequired as bool);
    return Input$UpdateRepositoryWebCommitSignoffSettingInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  bool get webCommitSignoffRequired =>
      (_$data['webCommitSignoffRequired'] as bool);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    result$data['webCommitSignoffRequired'] = l$webCommitSignoffRequired;
    return result$data;
  }

  CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<
          Input$UpdateRepositoryWebCommitSignoffSettingInput>
      get copyWith =>
          CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateRepositoryWebCommitSignoffSettingInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    final lOther$webCommitSignoffRequired = other.webCommitSignoffRequired;
    if (l$webCommitSignoffRequired != lOther$webCommitSignoffRequired) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$webCommitSignoffRequired = webCommitSignoffRequired;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      l$webCommitSignoffRequired,
    ]);
  }
}

abstract class CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<
    TRes> {
  factory CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput(
    Input$UpdateRepositoryWebCommitSignoffSettingInput instance,
    TRes Function(Input$UpdateRepositoryWebCommitSignoffSettingInput) then,
  ) = _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput;

  factory CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    bool? webCommitSignoffRequired,
  });
}

class _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes> {
  _CopyWithImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput(
    this._instance,
    this._then,
  );

  final Input$UpdateRepositoryWebCommitSignoffSettingInput _instance;

  final TRes Function(Input$UpdateRepositoryWebCommitSignoffSettingInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? webCommitSignoffRequired = _undefined,
  }) =>
      _then(Input$UpdateRepositoryWebCommitSignoffSettingInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (webCommitSignoffRequired != _undefined &&
            webCommitSignoffRequired != null)
          'webCommitSignoffRequired': (webCommitSignoffRequired as bool),
      }));
}

class _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes>
    implements
        CopyWith$Input$UpdateRepositoryWebCommitSignoffSettingInput<TRes> {
  _CopyWithStubImpl$Input$UpdateRepositoryWebCommitSignoffSettingInput(
      this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    bool? webCommitSignoffRequired,
  }) =>
      _res;
}

class Input$UpdateSponsorshipPreferencesInput {
  factory Input$UpdateSponsorshipPreferencesInput({
    String? clientMutationId,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? receiveEmails,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  }) =>
      Input$UpdateSponsorshipPreferencesInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        if (privacyLevel != null) r'privacyLevel': privacyLevel,
        if (receiveEmails != null) r'receiveEmails': receiveEmails,
        if (sponsorId != null) r'sponsorId': sponsorId,
        if (sponsorLogin != null) r'sponsorLogin': sponsorLogin,
        if (sponsorableId != null) r'sponsorableId': sponsorableId,
        if (sponsorableLogin != null) r'sponsorableLogin': sponsorableLogin,
      });

  Input$UpdateSponsorshipPreferencesInput._(this._$data);

  factory Input$UpdateSponsorshipPreferencesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    if (data.containsKey('privacyLevel')) {
      final l$privacyLevel = data['privacyLevel'];
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : fromJson$Enum$SponsorshipPrivacy((l$privacyLevel as String));
    }
    if (data.containsKey('receiveEmails')) {
      final l$receiveEmails = data['receiveEmails'];
      result$data['receiveEmails'] = (l$receiveEmails as bool?);
    }
    if (data.containsKey('sponsorId')) {
      final l$sponsorId = data['sponsorId'];
      result$data['sponsorId'] = (l$sponsorId as String?);
    }
    if (data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = data['sponsorLogin'];
      result$data['sponsorLogin'] = (l$sponsorLogin as String?);
    }
    if (data.containsKey('sponsorableId')) {
      final l$sponsorableId = data['sponsorableId'];
      result$data['sponsorableId'] = (l$sponsorableId as String?);
    }
    if (data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = data['sponsorableLogin'];
      result$data['sponsorableLogin'] = (l$sponsorableLogin as String?);
    }
    return Input$UpdateSponsorshipPreferencesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$SponsorshipPrivacy? get privacyLevel =>
      (_$data['privacyLevel'] as Enum$SponsorshipPrivacy?);
  bool? get receiveEmails => (_$data['receiveEmails'] as bool?);
  String? get sponsorId => (_$data['sponsorId'] as String?);
  String? get sponsorLogin => (_$data['sponsorLogin'] as String?);
  String? get sponsorableId => (_$data['sponsorableId'] as String?);
  String? get sponsorableLogin => (_$data['sponsorableLogin'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    if (_$data.containsKey('privacyLevel')) {
      final l$privacyLevel = privacyLevel;
      result$data['privacyLevel'] = l$privacyLevel == null
          ? null
          : toJson$Enum$SponsorshipPrivacy(l$privacyLevel);
    }
    if (_$data.containsKey('receiveEmails')) {
      final l$receiveEmails = receiveEmails;
      result$data['receiveEmails'] = l$receiveEmails;
    }
    if (_$data.containsKey('sponsorId')) {
      final l$sponsorId = sponsorId;
      result$data['sponsorId'] = l$sponsorId;
    }
    if (_$data.containsKey('sponsorLogin')) {
      final l$sponsorLogin = sponsorLogin;
      result$data['sponsorLogin'] = l$sponsorLogin;
    }
    if (_$data.containsKey('sponsorableId')) {
      final l$sponsorableId = sponsorableId;
      result$data['sponsorableId'] = l$sponsorableId;
    }
    if (_$data.containsKey('sponsorableLogin')) {
      final l$sponsorableLogin = sponsorableLogin;
      result$data['sponsorableLogin'] = l$sponsorableLogin;
    }
    return result$data;
  }

  CopyWith$Input$UpdateSponsorshipPreferencesInput<
          Input$UpdateSponsorshipPreferencesInput>
      get copyWith => CopyWith$Input$UpdateSponsorshipPreferencesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateSponsorshipPreferencesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$privacyLevel = privacyLevel;
    final lOther$privacyLevel = other.privacyLevel;
    if (_$data.containsKey('privacyLevel') !=
        other._$data.containsKey('privacyLevel')) {
      return false;
    }
    if (l$privacyLevel != lOther$privacyLevel) {
      return false;
    }
    final l$receiveEmails = receiveEmails;
    final lOther$receiveEmails = other.receiveEmails;
    if (_$data.containsKey('receiveEmails') !=
        other._$data.containsKey('receiveEmails')) {
      return false;
    }
    if (l$receiveEmails != lOther$receiveEmails) {
      return false;
    }
    final l$sponsorId = sponsorId;
    final lOther$sponsorId = other.sponsorId;
    if (_$data.containsKey('sponsorId') !=
        other._$data.containsKey('sponsorId')) {
      return false;
    }
    if (l$sponsorId != lOther$sponsorId) {
      return false;
    }
    final l$sponsorLogin = sponsorLogin;
    final lOther$sponsorLogin = other.sponsorLogin;
    if (_$data.containsKey('sponsorLogin') !=
        other._$data.containsKey('sponsorLogin')) {
      return false;
    }
    if (l$sponsorLogin != lOther$sponsorLogin) {
      return false;
    }
    final l$sponsorableId = sponsorableId;
    final lOther$sponsorableId = other.sponsorableId;
    if (_$data.containsKey('sponsorableId') !=
        other._$data.containsKey('sponsorableId')) {
      return false;
    }
    if (l$sponsorableId != lOther$sponsorableId) {
      return false;
    }
    final l$sponsorableLogin = sponsorableLogin;
    final lOther$sponsorableLogin = other.sponsorableLogin;
    if (_$data.containsKey('sponsorableLogin') !=
        other._$data.containsKey('sponsorableLogin')) {
      return false;
    }
    if (l$sponsorableLogin != lOther$sponsorableLogin) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$privacyLevel = privacyLevel;
    final l$receiveEmails = receiveEmails;
    final l$sponsorId = sponsorId;
    final l$sponsorLogin = sponsorLogin;
    final l$sponsorableId = sponsorableId;
    final l$sponsorableLogin = sponsorableLogin;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      _$data.containsKey('privacyLevel') ? l$privacyLevel : const {},
      _$data.containsKey('receiveEmails') ? l$receiveEmails : const {},
      _$data.containsKey('sponsorId') ? l$sponsorId : const {},
      _$data.containsKey('sponsorLogin') ? l$sponsorLogin : const {},
      _$data.containsKey('sponsorableId') ? l$sponsorableId : const {},
      _$data.containsKey('sponsorableLogin') ? l$sponsorableLogin : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  factory CopyWith$Input$UpdateSponsorshipPreferencesInput(
    Input$UpdateSponsorshipPreferencesInput instance,
    TRes Function(Input$UpdateSponsorshipPreferencesInput) then,
  ) = _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput;

  factory CopyWith$Input$UpdateSponsorshipPreferencesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput;

  TRes call({
    String? clientMutationId,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? receiveEmails,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  });
}

class _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput<TRes>
    implements CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  _CopyWithImpl$Input$UpdateSponsorshipPreferencesInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSponsorshipPreferencesInput _instance;

  final TRes Function(Input$UpdateSponsorshipPreferencesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? privacyLevel = _undefined,
    Object? receiveEmails = _undefined,
    Object? sponsorId = _undefined,
    Object? sponsorLogin = _undefined,
    Object? sponsorableId = _undefined,
    Object? sponsorableLogin = _undefined,
  }) =>
      _then(Input$UpdateSponsorshipPreferencesInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (privacyLevel != _undefined)
          'privacyLevel': (privacyLevel as Enum$SponsorshipPrivacy?),
        if (receiveEmails != _undefined)
          'receiveEmails': (receiveEmails as bool?),
        if (sponsorId != _undefined) 'sponsorId': (sponsorId as String?),
        if (sponsorLogin != _undefined)
          'sponsorLogin': (sponsorLogin as String?),
        if (sponsorableId != _undefined)
          'sponsorableId': (sponsorableId as String?),
        if (sponsorableLogin != _undefined)
          'sponsorableLogin': (sponsorableLogin as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput<TRes>
    implements CopyWith$Input$UpdateSponsorshipPreferencesInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSponsorshipPreferencesInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$SponsorshipPrivacy? privacyLevel,
    bool? receiveEmails,
    String? sponsorId,
    String? sponsorLogin,
    String? sponsorableId,
    String? sponsorableLogin,
  }) =>
      _res;
}

class Input$UpdateSubscriptionInput {
  factory Input$UpdateSubscriptionInput({
    String? clientMutationId,
    required Enum$SubscriptionState state,
    required String subscribableId,
  }) =>
      Input$UpdateSubscriptionInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'state': state,
        r'subscribableId': subscribableId,
      });

  Input$UpdateSubscriptionInput._(this._$data);

  factory Input$UpdateSubscriptionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$state = data['state'];
    result$data['state'] = fromJson$Enum$SubscriptionState((l$state as String));
    final l$subscribableId = data['subscribableId'];
    result$data['subscribableId'] = (l$subscribableId as String);
    return Input$UpdateSubscriptionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$SubscriptionState get state =>
      (_$data['state'] as Enum$SubscriptionState);
  String get subscribableId => (_$data['subscribableId'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$state = state;
    result$data['state'] = toJson$Enum$SubscriptionState(l$state);
    final l$subscribableId = subscribableId;
    result$data['subscribableId'] = l$subscribableId;
    return result$data;
  }

  CopyWith$Input$UpdateSubscriptionInput<Input$UpdateSubscriptionInput>
      get copyWith => CopyWith$Input$UpdateSubscriptionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateSubscriptionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$state = state;
    final lOther$state = other.state;
    if (l$state != lOther$state) {
      return false;
    }
    final l$subscribableId = subscribableId;
    final lOther$subscribableId = other.subscribableId;
    if (l$subscribableId != lOther$subscribableId) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$state = state;
    final l$subscribableId = subscribableId;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$state,
      l$subscribableId,
    ]);
  }
}

abstract class CopyWith$Input$UpdateSubscriptionInput<TRes> {
  factory CopyWith$Input$UpdateSubscriptionInput(
    Input$UpdateSubscriptionInput instance,
    TRes Function(Input$UpdateSubscriptionInput) then,
  ) = _CopyWithImpl$Input$UpdateSubscriptionInput;

  factory CopyWith$Input$UpdateSubscriptionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateSubscriptionInput;

  TRes call({
    String? clientMutationId,
    Enum$SubscriptionState? state,
    String? subscribableId,
  });
}

class _CopyWithImpl$Input$UpdateSubscriptionInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionInput<TRes> {
  _CopyWithImpl$Input$UpdateSubscriptionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateSubscriptionInput _instance;

  final TRes Function(Input$UpdateSubscriptionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? state = _undefined,
    Object? subscribableId = _undefined,
  }) =>
      _then(Input$UpdateSubscriptionInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (state != _undefined && state != null)
          'state': (state as Enum$SubscriptionState),
        if (subscribableId != _undefined && subscribableId != null)
          'subscribableId': (subscribableId as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateSubscriptionInput<TRes>
    implements CopyWith$Input$UpdateSubscriptionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateSubscriptionInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$SubscriptionState? state,
    String? subscribableId,
  }) =>
      _res;
}

class Input$UpdateTeamDiscussionCommentInput {
  factory Input$UpdateTeamDiscussionCommentInput({
    required String body,
    String? bodyVersion,
    String? clientMutationId,
    required String id,
  }) =>
      Input$UpdateTeamDiscussionCommentInput._({
        r'body': body,
        if (bodyVersion != null) r'bodyVersion': bodyVersion,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$UpdateTeamDiscussionCommentInput._(this._$data);

  factory Input$UpdateTeamDiscussionCommentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$body = data['body'];
    result$data['body'] = (l$body as String);
    if (data.containsKey('bodyVersion')) {
      final l$bodyVersion = data['bodyVersion'];
      result$data['bodyVersion'] = (l$bodyVersion as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$UpdateTeamDiscussionCommentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get body => (_$data['body'] as String);
  String? get bodyVersion => (_$data['bodyVersion'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$body = body;
    result$data['body'] = l$body;
    if (_$data.containsKey('bodyVersion')) {
      final l$bodyVersion = bodyVersion;
      result$data['bodyVersion'] = l$bodyVersion;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$UpdateTeamDiscussionCommentInput<
          Input$UpdateTeamDiscussionCommentInput>
      get copyWith => CopyWith$Input$UpdateTeamDiscussionCommentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTeamDiscussionCommentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (l$body != lOther$body) {
      return false;
    }
    final l$bodyVersion = bodyVersion;
    final lOther$bodyVersion = other.bodyVersion;
    if (_$data.containsKey('bodyVersion') !=
        other._$data.containsKey('bodyVersion')) {
      return false;
    }
    if (l$bodyVersion != lOther$bodyVersion) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$bodyVersion = bodyVersion;
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      l$body,
      _$data.containsKey('bodyVersion') ? l$bodyVersion : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  factory CopyWith$Input$UpdateTeamDiscussionCommentInput(
    Input$UpdateTeamDiscussionCommentInput instance,
    TRes Function(Input$UpdateTeamDiscussionCommentInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput;

  factory CopyWith$Input$UpdateTeamDiscussionCommentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput;

  TRes call({
    String? body,
    String? bodyVersion,
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamDiscussionCommentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamDiscussionCommentInput _instance;

  final TRes Function(Input$UpdateTeamDiscussionCommentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? bodyVersion = _undefined,
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$UpdateTeamDiscussionCommentInput._({
        ..._instance._$data,
        if (body != _undefined && body != null) 'body': (body as String),
        if (bodyVersion != _undefined) 'bodyVersion': (bodyVersion as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionCommentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamDiscussionCommentInput(this._res);

  TRes _res;

  call({
    String? body,
    String? bodyVersion,
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$UpdateTeamDiscussionInput {
  factory Input$UpdateTeamDiscussionInput({
    String? body,
    String? bodyVersion,
    String? clientMutationId,
    required String id,
    bool? pinned,
    String? title,
  }) =>
      Input$UpdateTeamDiscussionInput._({
        if (body != null) r'body': body,
        if (bodyVersion != null) r'bodyVersion': bodyVersion,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
        if (pinned != null) r'pinned': pinned,
        if (title != null) r'title': title,
      });

  Input$UpdateTeamDiscussionInput._(this._$data);

  factory Input$UpdateTeamDiscussionInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('body')) {
      final l$body = data['body'];
      result$data['body'] = (l$body as String?);
    }
    if (data.containsKey('bodyVersion')) {
      final l$bodyVersion = data['bodyVersion'];
      result$data['bodyVersion'] = (l$bodyVersion as String?);
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('pinned')) {
      final l$pinned = data['pinned'];
      result$data['pinned'] = (l$pinned as bool?);
    }
    if (data.containsKey('title')) {
      final l$title = data['title'];
      result$data['title'] = (l$title as String?);
    }
    return Input$UpdateTeamDiscussionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get body => (_$data['body'] as String?);
  String? get bodyVersion => (_$data['bodyVersion'] as String?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  bool? get pinned => (_$data['pinned'] as bool?);
  String? get title => (_$data['title'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('body')) {
      final l$body = body;
      result$data['body'] = l$body;
    }
    if (_$data.containsKey('bodyVersion')) {
      final l$bodyVersion = bodyVersion;
      result$data['bodyVersion'] = l$bodyVersion;
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('pinned')) {
      final l$pinned = pinned;
      result$data['pinned'] = l$pinned;
    }
    if (_$data.containsKey('title')) {
      final l$title = title;
      result$data['title'] = l$title;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamDiscussionInput<Input$UpdateTeamDiscussionInput>
      get copyWith => CopyWith$Input$UpdateTeamDiscussionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTeamDiscussionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$body = body;
    final lOther$body = other.body;
    if (_$data.containsKey('body') != other._$data.containsKey('body')) {
      return false;
    }
    if (l$body != lOther$body) {
      return false;
    }
    final l$bodyVersion = bodyVersion;
    final lOther$bodyVersion = other.bodyVersion;
    if (_$data.containsKey('bodyVersion') !=
        other._$data.containsKey('bodyVersion')) {
      return false;
    }
    if (l$bodyVersion != lOther$bodyVersion) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$pinned = pinned;
    final lOther$pinned = other.pinned;
    if (_$data.containsKey('pinned') != other._$data.containsKey('pinned')) {
      return false;
    }
    if (l$pinned != lOther$pinned) {
      return false;
    }
    final l$title = title;
    final lOther$title = other.title;
    if (_$data.containsKey('title') != other._$data.containsKey('title')) {
      return false;
    }
    if (l$title != lOther$title) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$body = body;
    final l$bodyVersion = bodyVersion;
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    final l$pinned = pinned;
    final l$title = title;
    return Object.hashAll([
      _$data.containsKey('body') ? l$body : const {},
      _$data.containsKey('bodyVersion') ? l$bodyVersion : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
      _$data.containsKey('pinned') ? l$pinned : const {},
      _$data.containsKey('title') ? l$title : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  factory CopyWith$Input$UpdateTeamDiscussionInput(
    Input$UpdateTeamDiscussionInput instance,
    TRes Function(Input$UpdateTeamDiscussionInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamDiscussionInput;

  factory CopyWith$Input$UpdateTeamDiscussionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamDiscussionInput;

  TRes call({
    String? body,
    String? bodyVersion,
    String? clientMutationId,
    String? id,
    bool? pinned,
    String? title,
  });
}

class _CopyWithImpl$Input$UpdateTeamDiscussionInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamDiscussionInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamDiscussionInput _instance;

  final TRes Function(Input$UpdateTeamDiscussionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? body = _undefined,
    Object? bodyVersion = _undefined,
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
    Object? pinned = _undefined,
    Object? title = _undefined,
  }) =>
      _then(Input$UpdateTeamDiscussionInput._({
        ..._instance._$data,
        if (body != _undefined) 'body': (body as String?),
        if (bodyVersion != _undefined) 'bodyVersion': (bodyVersion as String?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (pinned != _undefined) 'pinned': (pinned as bool?),
        if (title != _undefined) 'title': (title as String?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamDiscussionInput<TRes>
    implements CopyWith$Input$UpdateTeamDiscussionInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamDiscussionInput(this._res);

  TRes _res;

  call({
    String? body,
    String? bodyVersion,
    String? clientMutationId,
    String? id,
    bool? pinned,
    String? title,
  }) =>
      _res;
}

class Input$UpdateTeamReviewAssignmentInput {
  factory Input$UpdateTeamReviewAssignmentInput({
    Enum$TeamReviewAssignmentAlgorithm? algorithm,
    String? clientMutationId,
    required bool enabled,
    List<String>? excludedTeamMemberIds,
    required String id,
    bool? notifyTeam,
    int? teamMemberCount,
  }) =>
      Input$UpdateTeamReviewAssignmentInput._({
        if (algorithm != null) r'algorithm': algorithm,
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'enabled': enabled,
        if (excludedTeamMemberIds != null)
          r'excludedTeamMemberIds': excludedTeamMemberIds,
        r'id': id,
        if (notifyTeam != null) r'notifyTeam': notifyTeam,
        if (teamMemberCount != null) r'teamMemberCount': teamMemberCount,
      });

  Input$UpdateTeamReviewAssignmentInput._(this._$data);

  factory Input$UpdateTeamReviewAssignmentInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('algorithm')) {
      final l$algorithm = data['algorithm'];
      result$data['algorithm'] = l$algorithm == null
          ? null
          : fromJson$Enum$TeamReviewAssignmentAlgorithm(
              (l$algorithm as String));
    }
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$enabled = data['enabled'];
    result$data['enabled'] = (l$enabled as bool);
    if (data.containsKey('excludedTeamMemberIds')) {
      final l$excludedTeamMemberIds = data['excludedTeamMemberIds'];
      result$data['excludedTeamMemberIds'] =
          (l$excludedTeamMemberIds as List<dynamic>?)
              ?.map((e) => (e as String))
              .toList();
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    if (data.containsKey('notifyTeam')) {
      final l$notifyTeam = data['notifyTeam'];
      result$data['notifyTeam'] = (l$notifyTeam as bool?);
    }
    if (data.containsKey('teamMemberCount')) {
      final l$teamMemberCount = data['teamMemberCount'];
      result$data['teamMemberCount'] = (l$teamMemberCount as int?);
    }
    return Input$UpdateTeamReviewAssignmentInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$TeamReviewAssignmentAlgorithm? get algorithm =>
      (_$data['algorithm'] as Enum$TeamReviewAssignmentAlgorithm?);
  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  bool get enabled => (_$data['enabled'] as bool);
  List<String>? get excludedTeamMemberIds =>
      (_$data['excludedTeamMemberIds'] as List<String>?);
  String get id => (_$data['id'] as String);
  bool? get notifyTeam => (_$data['notifyTeam'] as bool?);
  int? get teamMemberCount => (_$data['teamMemberCount'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('algorithm')) {
      final l$algorithm = algorithm;
      result$data['algorithm'] = l$algorithm == null
          ? null
          : toJson$Enum$TeamReviewAssignmentAlgorithm(l$algorithm);
    }
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$enabled = enabled;
    result$data['enabled'] = l$enabled;
    if (_$data.containsKey('excludedTeamMemberIds')) {
      final l$excludedTeamMemberIds = excludedTeamMemberIds;
      result$data['excludedTeamMemberIds'] =
          l$excludedTeamMemberIds?.map((e) => e).toList();
    }
    final l$id = id;
    result$data['id'] = l$id;
    if (_$data.containsKey('notifyTeam')) {
      final l$notifyTeam = notifyTeam;
      result$data['notifyTeam'] = l$notifyTeam;
    }
    if (_$data.containsKey('teamMemberCount')) {
      final l$teamMemberCount = teamMemberCount;
      result$data['teamMemberCount'] = l$teamMemberCount;
    }
    return result$data;
  }

  CopyWith$Input$UpdateTeamReviewAssignmentInput<
          Input$UpdateTeamReviewAssignmentInput>
      get copyWith => CopyWith$Input$UpdateTeamReviewAssignmentInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTeamReviewAssignmentInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$algorithm = algorithm;
    final lOther$algorithm = other.algorithm;
    if (_$data.containsKey('algorithm') !=
        other._$data.containsKey('algorithm')) {
      return false;
    }
    if (l$algorithm != lOther$algorithm) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$enabled = enabled;
    final lOther$enabled = other.enabled;
    if (l$enabled != lOther$enabled) {
      return false;
    }
    final l$excludedTeamMemberIds = excludedTeamMemberIds;
    final lOther$excludedTeamMemberIds = other.excludedTeamMemberIds;
    if (_$data.containsKey('excludedTeamMemberIds') !=
        other._$data.containsKey('excludedTeamMemberIds')) {
      return false;
    }
    if (l$excludedTeamMemberIds != null &&
        lOther$excludedTeamMemberIds != null) {
      if (l$excludedTeamMemberIds.length !=
          lOther$excludedTeamMemberIds.length) {
        return false;
      }
      for (int i = 0; i < l$excludedTeamMemberIds.length; i++) {
        final l$excludedTeamMemberIds$entry = l$excludedTeamMemberIds[i];
        final lOther$excludedTeamMemberIds$entry =
            lOther$excludedTeamMemberIds[i];
        if (l$excludedTeamMemberIds$entry !=
            lOther$excludedTeamMemberIds$entry) {
          return false;
        }
      }
    } else if (l$excludedTeamMemberIds != lOther$excludedTeamMemberIds) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$notifyTeam = notifyTeam;
    final lOther$notifyTeam = other.notifyTeam;
    if (_$data.containsKey('notifyTeam') !=
        other._$data.containsKey('notifyTeam')) {
      return false;
    }
    if (l$notifyTeam != lOther$notifyTeam) {
      return false;
    }
    final l$teamMemberCount = teamMemberCount;
    final lOther$teamMemberCount = other.teamMemberCount;
    if (_$data.containsKey('teamMemberCount') !=
        other._$data.containsKey('teamMemberCount')) {
      return false;
    }
    if (l$teamMemberCount != lOther$teamMemberCount) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$algorithm = algorithm;
    final l$clientMutationId = clientMutationId;
    final l$enabled = enabled;
    final l$excludedTeamMemberIds = excludedTeamMemberIds;
    final l$id = id;
    final l$notifyTeam = notifyTeam;
    final l$teamMemberCount = teamMemberCount;
    return Object.hashAll([
      _$data.containsKey('algorithm') ? l$algorithm : const {},
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$enabled,
      _$data.containsKey('excludedTeamMemberIds')
          ? l$excludedTeamMemberIds == null
              ? null
              : Object.hashAll(l$excludedTeamMemberIds.map((v) => v))
          : const {},
      l$id,
      _$data.containsKey('notifyTeam') ? l$notifyTeam : const {},
      _$data.containsKey('teamMemberCount') ? l$teamMemberCount : const {},
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamReviewAssignmentInput<TRes> {
  factory CopyWith$Input$UpdateTeamReviewAssignmentInput(
    Input$UpdateTeamReviewAssignmentInput instance,
    TRes Function(Input$UpdateTeamReviewAssignmentInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamReviewAssignmentInput;

  factory CopyWith$Input$UpdateTeamReviewAssignmentInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamReviewAssignmentInput;

  TRes call({
    Enum$TeamReviewAssignmentAlgorithm? algorithm,
    String? clientMutationId,
    bool? enabled,
    List<String>? excludedTeamMemberIds,
    String? id,
    bool? notifyTeam,
    int? teamMemberCount,
  });
}

class _CopyWithImpl$Input$UpdateTeamReviewAssignmentInput<TRes>
    implements CopyWith$Input$UpdateTeamReviewAssignmentInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamReviewAssignmentInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamReviewAssignmentInput _instance;

  final TRes Function(Input$UpdateTeamReviewAssignmentInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? algorithm = _undefined,
    Object? clientMutationId = _undefined,
    Object? enabled = _undefined,
    Object? excludedTeamMemberIds = _undefined,
    Object? id = _undefined,
    Object? notifyTeam = _undefined,
    Object? teamMemberCount = _undefined,
  }) =>
      _then(Input$UpdateTeamReviewAssignmentInput._({
        ..._instance._$data,
        if (algorithm != _undefined)
          'algorithm': (algorithm as Enum$TeamReviewAssignmentAlgorithm?),
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (enabled != _undefined && enabled != null)
          'enabled': (enabled as bool),
        if (excludedTeamMemberIds != _undefined)
          'excludedTeamMemberIds': (excludedTeamMemberIds as List<String>?),
        if (id != _undefined && id != null) 'id': (id as String),
        if (notifyTeam != _undefined) 'notifyTeam': (notifyTeam as bool?),
        if (teamMemberCount != _undefined)
          'teamMemberCount': (teamMemberCount as int?),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamReviewAssignmentInput<TRes>
    implements CopyWith$Input$UpdateTeamReviewAssignmentInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamReviewAssignmentInput(this._res);

  TRes _res;

  call({
    Enum$TeamReviewAssignmentAlgorithm? algorithm,
    String? clientMutationId,
    bool? enabled,
    List<String>? excludedTeamMemberIds,
    String? id,
    bool? notifyTeam,
    int? teamMemberCount,
  }) =>
      _res;
}

class Input$UpdateTeamsRepositoryInput {
  factory Input$UpdateTeamsRepositoryInput({
    String? clientMutationId,
    required Enum$RepositoryPermission permission,
    required String repositoryId,
    required List<String> teamIds,
  }) =>
      Input$UpdateTeamsRepositoryInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'permission': permission,
        r'repositoryId': repositoryId,
        r'teamIds': teamIds,
      });

  Input$UpdateTeamsRepositoryInput._(this._$data);

  factory Input$UpdateTeamsRepositoryInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$permission = data['permission'];
    result$data['permission'] =
        fromJson$Enum$RepositoryPermission((l$permission as String));
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$teamIds = data['teamIds'];
    result$data['teamIds'] =
        (l$teamIds as List<dynamic>).map((e) => (e as String)).toList();
    return Input$UpdateTeamsRepositoryInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  Enum$RepositoryPermission get permission =>
      (_$data['permission'] as Enum$RepositoryPermission);
  String get repositoryId => (_$data['repositoryId'] as String);
  List<String> get teamIds => (_$data['teamIds'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$permission = permission;
    result$data['permission'] = toJson$Enum$RepositoryPermission(l$permission);
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$teamIds = teamIds;
    result$data['teamIds'] = l$teamIds.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$UpdateTeamsRepositoryInput<Input$UpdateTeamsRepositoryInput>
      get copyWith => CopyWith$Input$UpdateTeamsRepositoryInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTeamsRepositoryInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$permission = permission;
    final lOther$permission = other.permission;
    if (l$permission != lOther$permission) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$teamIds = teamIds;
    final lOther$teamIds = other.teamIds;
    if (l$teamIds.length != lOther$teamIds.length) {
      return false;
    }
    for (int i = 0; i < l$teamIds.length; i++) {
      final l$teamIds$entry = l$teamIds[i];
      final lOther$teamIds$entry = lOther$teamIds[i];
      if (l$teamIds$entry != lOther$teamIds$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$permission = permission;
    final l$repositoryId = repositoryId;
    final l$teamIds = teamIds;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$permission,
      l$repositoryId,
      Object.hashAll(l$teamIds.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  factory CopyWith$Input$UpdateTeamsRepositoryInput(
    Input$UpdateTeamsRepositoryInput instance,
    TRes Function(Input$UpdateTeamsRepositoryInput) then,
  ) = _CopyWithImpl$Input$UpdateTeamsRepositoryInput;

  factory CopyWith$Input$UpdateTeamsRepositoryInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput;

  TRes call({
    String? clientMutationId,
    Enum$RepositoryPermission? permission,
    String? repositoryId,
    List<String>? teamIds,
  });
}

class _CopyWithImpl$Input$UpdateTeamsRepositoryInput<TRes>
    implements CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  _CopyWithImpl$Input$UpdateTeamsRepositoryInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTeamsRepositoryInput _instance;

  final TRes Function(Input$UpdateTeamsRepositoryInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? permission = _undefined,
    Object? repositoryId = _undefined,
    Object? teamIds = _undefined,
  }) =>
      _then(Input$UpdateTeamsRepositoryInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (permission != _undefined && permission != null)
          'permission': (permission as Enum$RepositoryPermission),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (teamIds != _undefined && teamIds != null)
          'teamIds': (teamIds as List<String>),
      }));
}

class _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput<TRes>
    implements CopyWith$Input$UpdateTeamsRepositoryInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTeamsRepositoryInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    Enum$RepositoryPermission? permission,
    String? repositoryId,
    List<String>? teamIds,
  }) =>
      _res;
}

class Input$UpdateTopicsInput {
  factory Input$UpdateTopicsInput({
    String? clientMutationId,
    required String repositoryId,
    required List<String> topicNames,
  }) =>
      Input$UpdateTopicsInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'repositoryId': repositoryId,
        r'topicNames': topicNames,
      });

  Input$UpdateTopicsInput._(this._$data);

  factory Input$UpdateTopicsInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$repositoryId = data['repositoryId'];
    result$data['repositoryId'] = (l$repositoryId as String);
    final l$topicNames = data['topicNames'];
    result$data['topicNames'] =
        (l$topicNames as List<dynamic>).map((e) => (e as String)).toList();
    return Input$UpdateTopicsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get repositoryId => (_$data['repositoryId'] as String);
  List<String> get topicNames => (_$data['topicNames'] as List<String>);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$repositoryId = repositoryId;
    result$data['repositoryId'] = l$repositoryId;
    final l$topicNames = topicNames;
    result$data['topicNames'] = l$topicNames.map((e) => e).toList();
    return result$data;
  }

  CopyWith$Input$UpdateTopicsInput<Input$UpdateTopicsInput> get copyWith =>
      CopyWith$Input$UpdateTopicsInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UpdateTopicsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$repositoryId = repositoryId;
    final lOther$repositoryId = other.repositoryId;
    if (l$repositoryId != lOther$repositoryId) {
      return false;
    }
    final l$topicNames = topicNames;
    final lOther$topicNames = other.topicNames;
    if (l$topicNames.length != lOther$topicNames.length) {
      return false;
    }
    for (int i = 0; i < l$topicNames.length; i++) {
      final l$topicNames$entry = l$topicNames[i];
      final lOther$topicNames$entry = lOther$topicNames[i];
      if (l$topicNames$entry != lOther$topicNames$entry) {
        return false;
      }
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$repositoryId = repositoryId;
    final l$topicNames = topicNames;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$repositoryId,
      Object.hashAll(l$topicNames.map((v) => v)),
    ]);
  }
}

abstract class CopyWith$Input$UpdateTopicsInput<TRes> {
  factory CopyWith$Input$UpdateTopicsInput(
    Input$UpdateTopicsInput instance,
    TRes Function(Input$UpdateTopicsInput) then,
  ) = _CopyWithImpl$Input$UpdateTopicsInput;

  factory CopyWith$Input$UpdateTopicsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$UpdateTopicsInput;

  TRes call({
    String? clientMutationId,
    String? repositoryId,
    List<String>? topicNames,
  });
}

class _CopyWithImpl$Input$UpdateTopicsInput<TRes>
    implements CopyWith$Input$UpdateTopicsInput<TRes> {
  _CopyWithImpl$Input$UpdateTopicsInput(
    this._instance,
    this._then,
  );

  final Input$UpdateTopicsInput _instance;

  final TRes Function(Input$UpdateTopicsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? repositoryId = _undefined,
    Object? topicNames = _undefined,
  }) =>
      _then(Input$UpdateTopicsInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (repositoryId != _undefined && repositoryId != null)
          'repositoryId': (repositoryId as String),
        if (topicNames != _undefined && topicNames != null)
          'topicNames': (topicNames as List<String>),
      }));
}

class _CopyWithStubImpl$Input$UpdateTopicsInput<TRes>
    implements CopyWith$Input$UpdateTopicsInput<TRes> {
  _CopyWithStubImpl$Input$UpdateTopicsInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? repositoryId,
    List<String>? topicNames,
  }) =>
      _res;
}

class Input$UserStatusOrder {
  factory Input$UserStatusOrder({
    required Enum$OrderDirection direction,
    required Enum$UserStatusOrderField field,
  }) =>
      Input$UserStatusOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$UserStatusOrder._(this._$data);

  factory Input$UserStatusOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$UserStatusOrderField((l$field as String));
    return Input$UserStatusOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$UserStatusOrderField get field =>
      (_$data['field'] as Enum$UserStatusOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$UserStatusOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$UserStatusOrder<Input$UserStatusOrder> get copyWith =>
      CopyWith$Input$UserStatusOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$UserStatusOrder) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$UserStatusOrder<TRes> {
  factory CopyWith$Input$UserStatusOrder(
    Input$UserStatusOrder instance,
    TRes Function(Input$UserStatusOrder) then,
  ) = _CopyWithImpl$Input$UserStatusOrder;

  factory CopyWith$Input$UserStatusOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$UserStatusOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$UserStatusOrderField? field,
  });
}

class _CopyWithImpl$Input$UserStatusOrder<TRes>
    implements CopyWith$Input$UserStatusOrder<TRes> {
  _CopyWithImpl$Input$UserStatusOrder(
    this._instance,
    this._then,
  );

  final Input$UserStatusOrder _instance;

  final TRes Function(Input$UserStatusOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$UserStatusOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$UserStatusOrderField),
      }));
}

class _CopyWithStubImpl$Input$UserStatusOrder<TRes>
    implements CopyWith$Input$UserStatusOrder<TRes> {
  _CopyWithStubImpl$Input$UserStatusOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$UserStatusOrderField? field,
  }) =>
      _res;
}

class Input$VerifiableDomainOrder {
  factory Input$VerifiableDomainOrder({
    required Enum$OrderDirection direction,
    required Enum$VerifiableDomainOrderField field,
  }) =>
      Input$VerifiableDomainOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$VerifiableDomainOrder._(this._$data);

  factory Input$VerifiableDomainOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$VerifiableDomainOrderField((l$field as String));
    return Input$VerifiableDomainOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$VerifiableDomainOrderField get field =>
      (_$data['field'] as Enum$VerifiableDomainOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$VerifiableDomainOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$VerifiableDomainOrder<Input$VerifiableDomainOrder>
      get copyWith => CopyWith$Input$VerifiableDomainOrder(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VerifiableDomainOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$VerifiableDomainOrder<TRes> {
  factory CopyWith$Input$VerifiableDomainOrder(
    Input$VerifiableDomainOrder instance,
    TRes Function(Input$VerifiableDomainOrder) then,
  ) = _CopyWithImpl$Input$VerifiableDomainOrder;

  factory CopyWith$Input$VerifiableDomainOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$VerifiableDomainOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$VerifiableDomainOrderField? field,
  });
}

class _CopyWithImpl$Input$VerifiableDomainOrder<TRes>
    implements CopyWith$Input$VerifiableDomainOrder<TRes> {
  _CopyWithImpl$Input$VerifiableDomainOrder(
    this._instance,
    this._then,
  );

  final Input$VerifiableDomainOrder _instance;

  final TRes Function(Input$VerifiableDomainOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$VerifiableDomainOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$VerifiableDomainOrderField),
      }));
}

class _CopyWithStubImpl$Input$VerifiableDomainOrder<TRes>
    implements CopyWith$Input$VerifiableDomainOrder<TRes> {
  _CopyWithStubImpl$Input$VerifiableDomainOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$VerifiableDomainOrderField? field,
  }) =>
      _res;
}

class Input$VerifyVerifiableDomainInput {
  factory Input$VerifyVerifiableDomainInput({
    String? clientMutationId,
    required String id,
  }) =>
      Input$VerifyVerifiableDomainInput._({
        if (clientMutationId != null) r'clientMutationId': clientMutationId,
        r'id': id,
      });

  Input$VerifyVerifiableDomainInput._(this._$data);

  factory Input$VerifyVerifiableDomainInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('clientMutationId')) {
      final l$clientMutationId = data['clientMutationId'];
      result$data['clientMutationId'] = (l$clientMutationId as String?);
    }
    final l$id = data['id'];
    result$data['id'] = (l$id as String);
    return Input$VerifyVerifiableDomainInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get clientMutationId => (_$data['clientMutationId'] as String?);
  String get id => (_$data['id'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('clientMutationId')) {
      final l$clientMutationId = clientMutationId;
      result$data['clientMutationId'] = l$clientMutationId;
    }
    final l$id = id;
    result$data['id'] = l$id;
    return result$data;
  }

  CopyWith$Input$VerifyVerifiableDomainInput<Input$VerifyVerifiableDomainInput>
      get copyWith => CopyWith$Input$VerifyVerifiableDomainInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$VerifyVerifiableDomainInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$clientMutationId = clientMutationId;
    final lOther$clientMutationId = other.clientMutationId;
    if (_$data.containsKey('clientMutationId') !=
        other._$data.containsKey('clientMutationId')) {
      return false;
    }
    if (l$clientMutationId != lOther$clientMutationId) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$clientMutationId = clientMutationId;
    final l$id = id;
    return Object.hashAll([
      _$data.containsKey('clientMutationId') ? l$clientMutationId : const {},
      l$id,
    ]);
  }
}

abstract class CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  factory CopyWith$Input$VerifyVerifiableDomainInput(
    Input$VerifyVerifiableDomainInput instance,
    TRes Function(Input$VerifyVerifiableDomainInput) then,
  ) = _CopyWithImpl$Input$VerifyVerifiableDomainInput;

  factory CopyWith$Input$VerifyVerifiableDomainInput.stub(TRes res) =
      _CopyWithStubImpl$Input$VerifyVerifiableDomainInput;

  TRes call({
    String? clientMutationId,
    String? id,
  });
}

class _CopyWithImpl$Input$VerifyVerifiableDomainInput<TRes>
    implements CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  _CopyWithImpl$Input$VerifyVerifiableDomainInput(
    this._instance,
    this._then,
  );

  final Input$VerifyVerifiableDomainInput _instance;

  final TRes Function(Input$VerifyVerifiableDomainInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? clientMutationId = _undefined,
    Object? id = _undefined,
  }) =>
      _then(Input$VerifyVerifiableDomainInput._({
        ..._instance._$data,
        if (clientMutationId != _undefined)
          'clientMutationId': (clientMutationId as String?),
        if (id != _undefined && id != null) 'id': (id as String),
      }));
}

class _CopyWithStubImpl$Input$VerifyVerifiableDomainInput<TRes>
    implements CopyWith$Input$VerifyVerifiableDomainInput<TRes> {
  _CopyWithStubImpl$Input$VerifyVerifiableDomainInput(this._res);

  TRes _res;

  call({
    String? clientMutationId,
    String? id,
  }) =>
      _res;
}

class Input$WorkflowRunOrder {
  factory Input$WorkflowRunOrder({
    required Enum$OrderDirection direction,
    required Enum$WorkflowRunOrderField field,
  }) =>
      Input$WorkflowRunOrder._({
        r'direction': direction,
        r'field': field,
      });

  Input$WorkflowRunOrder._(this._$data);

  factory Input$WorkflowRunOrder.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$direction = data['direction'];
    result$data['direction'] =
        fromJson$Enum$OrderDirection((l$direction as String));
    final l$field = data['field'];
    result$data['field'] =
        fromJson$Enum$WorkflowRunOrderField((l$field as String));
    return Input$WorkflowRunOrder._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$OrderDirection get direction =>
      (_$data['direction'] as Enum$OrderDirection);
  Enum$WorkflowRunOrderField get field =>
      (_$data['field'] as Enum$WorkflowRunOrderField);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$direction = direction;
    result$data['direction'] = toJson$Enum$OrderDirection(l$direction);
    final l$field = field;
    result$data['field'] = toJson$Enum$WorkflowRunOrderField(l$field);
    return result$data;
  }

  CopyWith$Input$WorkflowRunOrder<Input$WorkflowRunOrder> get copyWith =>
      CopyWith$Input$WorkflowRunOrder(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$WorkflowRunOrder) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$direction = direction;
    final lOther$direction = other.direction;
    if (l$direction != lOther$direction) {
      return false;
    }
    final l$field = field;
    final lOther$field = other.field;
    if (l$field != lOther$field) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$direction = direction;
    final l$field = field;
    return Object.hashAll([
      l$direction,
      l$field,
    ]);
  }
}

abstract class CopyWith$Input$WorkflowRunOrder<TRes> {
  factory CopyWith$Input$WorkflowRunOrder(
    Input$WorkflowRunOrder instance,
    TRes Function(Input$WorkflowRunOrder) then,
  ) = _CopyWithImpl$Input$WorkflowRunOrder;

  factory CopyWith$Input$WorkflowRunOrder.stub(TRes res) =
      _CopyWithStubImpl$Input$WorkflowRunOrder;

  TRes call({
    Enum$OrderDirection? direction,
    Enum$WorkflowRunOrderField? field,
  });
}

class _CopyWithImpl$Input$WorkflowRunOrder<TRes>
    implements CopyWith$Input$WorkflowRunOrder<TRes> {
  _CopyWithImpl$Input$WorkflowRunOrder(
    this._instance,
    this._then,
  );

  final Input$WorkflowRunOrder _instance;

  final TRes Function(Input$WorkflowRunOrder) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? direction = _undefined,
    Object? field = _undefined,
  }) =>
      _then(Input$WorkflowRunOrder._({
        ..._instance._$data,
        if (direction != _undefined && direction != null)
          'direction': (direction as Enum$OrderDirection),
        if (field != _undefined && field != null)
          'field': (field as Enum$WorkflowRunOrderField),
      }));
}

class _CopyWithStubImpl$Input$WorkflowRunOrder<TRes>
    implements CopyWith$Input$WorkflowRunOrder<TRes> {
  _CopyWithStubImpl$Input$WorkflowRunOrder(this._res);

  TRes _res;

  call({
    Enum$OrderDirection? direction,
    Enum$WorkflowRunOrderField? field,
  }) =>
      _res;
}

enum Enum$ActorType { TEAM, USER, $unknown }

String toJson$Enum$ActorType(Enum$ActorType e) {
  switch (e) {
    case Enum$ActorType.TEAM:
      return r'TEAM';
    case Enum$ActorType.USER:
      return r'USER';
    case Enum$ActorType.$unknown:
      return r'$unknown';
  }
}

Enum$ActorType fromJson$Enum$ActorType(String value) {
  switch (value) {
    case r'TEAM':
      return Enum$ActorType.TEAM;
    case r'USER':
      return Enum$ActorType.USER;
    default:
      return Enum$ActorType.$unknown;
  }
}

enum Enum$AuditLogOrderField { CREATED_AT, $unknown }

String toJson$Enum$AuditLogOrderField(Enum$AuditLogOrderField e) {
  switch (e) {
    case Enum$AuditLogOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$AuditLogOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$AuditLogOrderField fromJson$Enum$AuditLogOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$AuditLogOrderField.CREATED_AT;
    default:
      return Enum$AuditLogOrderField.$unknown;
  }
}

enum Enum$CheckAnnotationLevel { FAILURE, NOTICE, WARNING, $unknown }

String toJson$Enum$CheckAnnotationLevel(Enum$CheckAnnotationLevel e) {
  switch (e) {
    case Enum$CheckAnnotationLevel.FAILURE:
      return r'FAILURE';
    case Enum$CheckAnnotationLevel.NOTICE:
      return r'NOTICE';
    case Enum$CheckAnnotationLevel.WARNING:
      return r'WARNING';
    case Enum$CheckAnnotationLevel.$unknown:
      return r'$unknown';
  }
}

Enum$CheckAnnotationLevel fromJson$Enum$CheckAnnotationLevel(String value) {
  switch (value) {
    case r'FAILURE':
      return Enum$CheckAnnotationLevel.FAILURE;
    case r'NOTICE':
      return Enum$CheckAnnotationLevel.NOTICE;
    case r'WARNING':
      return Enum$CheckAnnotationLevel.WARNING;
    default:
      return Enum$CheckAnnotationLevel.$unknown;
  }
}

enum Enum$CheckConclusionState {
  ACTION_REQUIRED,
  CANCELLED,
  FAILURE,
  NEUTRAL,
  SKIPPED,
  STALE,
  STARTUP_FAILURE,
  SUCCESS,
  TIMED_OUT,
  $unknown
}

String toJson$Enum$CheckConclusionState(Enum$CheckConclusionState e) {
  switch (e) {
    case Enum$CheckConclusionState.ACTION_REQUIRED:
      return r'ACTION_REQUIRED';
    case Enum$CheckConclusionState.CANCELLED:
      return r'CANCELLED';
    case Enum$CheckConclusionState.FAILURE:
      return r'FAILURE';
    case Enum$CheckConclusionState.NEUTRAL:
      return r'NEUTRAL';
    case Enum$CheckConclusionState.SKIPPED:
      return r'SKIPPED';
    case Enum$CheckConclusionState.STALE:
      return r'STALE';
    case Enum$CheckConclusionState.STARTUP_FAILURE:
      return r'STARTUP_FAILURE';
    case Enum$CheckConclusionState.SUCCESS:
      return r'SUCCESS';
    case Enum$CheckConclusionState.TIMED_OUT:
      return r'TIMED_OUT';
    case Enum$CheckConclusionState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckConclusionState fromJson$Enum$CheckConclusionState(String value) {
  switch (value) {
    case r'ACTION_REQUIRED':
      return Enum$CheckConclusionState.ACTION_REQUIRED;
    case r'CANCELLED':
      return Enum$CheckConclusionState.CANCELLED;
    case r'FAILURE':
      return Enum$CheckConclusionState.FAILURE;
    case r'NEUTRAL':
      return Enum$CheckConclusionState.NEUTRAL;
    case r'SKIPPED':
      return Enum$CheckConclusionState.SKIPPED;
    case r'STALE':
      return Enum$CheckConclusionState.STALE;
    case r'STARTUP_FAILURE':
      return Enum$CheckConclusionState.STARTUP_FAILURE;
    case r'SUCCESS':
      return Enum$CheckConclusionState.SUCCESS;
    case r'TIMED_OUT':
      return Enum$CheckConclusionState.TIMED_OUT;
    default:
      return Enum$CheckConclusionState.$unknown;
  }
}

enum Enum$CheckRunState {
  ACTION_REQUIRED,
  CANCELLED,
  COMPLETED,
  FAILURE,
  IN_PROGRESS,
  NEUTRAL,
  PENDING,
  QUEUED,
  SKIPPED,
  STALE,
  STARTUP_FAILURE,
  SUCCESS,
  TIMED_OUT,
  WAITING,
  $unknown
}

String toJson$Enum$CheckRunState(Enum$CheckRunState e) {
  switch (e) {
    case Enum$CheckRunState.ACTION_REQUIRED:
      return r'ACTION_REQUIRED';
    case Enum$CheckRunState.CANCELLED:
      return r'CANCELLED';
    case Enum$CheckRunState.COMPLETED:
      return r'COMPLETED';
    case Enum$CheckRunState.FAILURE:
      return r'FAILURE';
    case Enum$CheckRunState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$CheckRunState.NEUTRAL:
      return r'NEUTRAL';
    case Enum$CheckRunState.PENDING:
      return r'PENDING';
    case Enum$CheckRunState.QUEUED:
      return r'QUEUED';
    case Enum$CheckRunState.SKIPPED:
      return r'SKIPPED';
    case Enum$CheckRunState.STALE:
      return r'STALE';
    case Enum$CheckRunState.STARTUP_FAILURE:
      return r'STARTUP_FAILURE';
    case Enum$CheckRunState.SUCCESS:
      return r'SUCCESS';
    case Enum$CheckRunState.TIMED_OUT:
      return r'TIMED_OUT';
    case Enum$CheckRunState.WAITING:
      return r'WAITING';
    case Enum$CheckRunState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckRunState fromJson$Enum$CheckRunState(String value) {
  switch (value) {
    case r'ACTION_REQUIRED':
      return Enum$CheckRunState.ACTION_REQUIRED;
    case r'CANCELLED':
      return Enum$CheckRunState.CANCELLED;
    case r'COMPLETED':
      return Enum$CheckRunState.COMPLETED;
    case r'FAILURE':
      return Enum$CheckRunState.FAILURE;
    case r'IN_PROGRESS':
      return Enum$CheckRunState.IN_PROGRESS;
    case r'NEUTRAL':
      return Enum$CheckRunState.NEUTRAL;
    case r'PENDING':
      return Enum$CheckRunState.PENDING;
    case r'QUEUED':
      return Enum$CheckRunState.QUEUED;
    case r'SKIPPED':
      return Enum$CheckRunState.SKIPPED;
    case r'STALE':
      return Enum$CheckRunState.STALE;
    case r'STARTUP_FAILURE':
      return Enum$CheckRunState.STARTUP_FAILURE;
    case r'SUCCESS':
      return Enum$CheckRunState.SUCCESS;
    case r'TIMED_OUT':
      return Enum$CheckRunState.TIMED_OUT;
    case r'WAITING':
      return Enum$CheckRunState.WAITING;
    default:
      return Enum$CheckRunState.$unknown;
  }
}

enum Enum$CheckRunType { ALL, LATEST, $unknown }

String toJson$Enum$CheckRunType(Enum$CheckRunType e) {
  switch (e) {
    case Enum$CheckRunType.ALL:
      return r'ALL';
    case Enum$CheckRunType.LATEST:
      return r'LATEST';
    case Enum$CheckRunType.$unknown:
      return r'$unknown';
  }
}

Enum$CheckRunType fromJson$Enum$CheckRunType(String value) {
  switch (value) {
    case r'ALL':
      return Enum$CheckRunType.ALL;
    case r'LATEST':
      return Enum$CheckRunType.LATEST;
    default:
      return Enum$CheckRunType.$unknown;
  }
}

enum Enum$CheckStatusState {
  COMPLETED,
  IN_PROGRESS,
  PENDING,
  QUEUED,
  REQUESTED,
  WAITING,
  $unknown
}

String toJson$Enum$CheckStatusState(Enum$CheckStatusState e) {
  switch (e) {
    case Enum$CheckStatusState.COMPLETED:
      return r'COMPLETED';
    case Enum$CheckStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$CheckStatusState.PENDING:
      return r'PENDING';
    case Enum$CheckStatusState.QUEUED:
      return r'QUEUED';
    case Enum$CheckStatusState.REQUESTED:
      return r'REQUESTED';
    case Enum$CheckStatusState.WAITING:
      return r'WAITING';
    case Enum$CheckStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$CheckStatusState fromJson$Enum$CheckStatusState(String value) {
  switch (value) {
    case r'COMPLETED':
      return Enum$CheckStatusState.COMPLETED;
    case r'IN_PROGRESS':
      return Enum$CheckStatusState.IN_PROGRESS;
    case r'PENDING':
      return Enum$CheckStatusState.PENDING;
    case r'QUEUED':
      return Enum$CheckStatusState.QUEUED;
    case r'REQUESTED':
      return Enum$CheckStatusState.REQUESTED;
    case r'WAITING':
      return Enum$CheckStatusState.WAITING;
    default:
      return Enum$CheckStatusState.$unknown;
  }
}

enum Enum$CollaboratorAffiliation { ALL, DIRECT, OUTSIDE, $unknown }

String toJson$Enum$CollaboratorAffiliation(Enum$CollaboratorAffiliation e) {
  switch (e) {
    case Enum$CollaboratorAffiliation.ALL:
      return r'ALL';
    case Enum$CollaboratorAffiliation.DIRECT:
      return r'DIRECT';
    case Enum$CollaboratorAffiliation.OUTSIDE:
      return r'OUTSIDE';
    case Enum$CollaboratorAffiliation.$unknown:
      return r'$unknown';
  }
}

Enum$CollaboratorAffiliation fromJson$Enum$CollaboratorAffiliation(
    String value) {
  switch (value) {
    case r'ALL':
      return Enum$CollaboratorAffiliation.ALL;
    case r'DIRECT':
      return Enum$CollaboratorAffiliation.DIRECT;
    case r'OUTSIDE':
      return Enum$CollaboratorAffiliation.OUTSIDE;
    default:
      return Enum$CollaboratorAffiliation.$unknown;
  }
}

enum Enum$CommentAuthorAssociation {
  COLLABORATOR,
  CONTRIBUTOR,
  FIRST_TIMER,
  FIRST_TIME_CONTRIBUTOR,
  MANNEQUIN,
  MEMBER,
  NONE,
  OWNER,
  $unknown
}

String toJson$Enum$CommentAuthorAssociation(Enum$CommentAuthorAssociation e) {
  switch (e) {
    case Enum$CommentAuthorAssociation.COLLABORATOR:
      return r'COLLABORATOR';
    case Enum$CommentAuthorAssociation.CONTRIBUTOR:
      return r'CONTRIBUTOR';
    case Enum$CommentAuthorAssociation.FIRST_TIMER:
      return r'FIRST_TIMER';
    case Enum$CommentAuthorAssociation.FIRST_TIME_CONTRIBUTOR:
      return r'FIRST_TIME_CONTRIBUTOR';
    case Enum$CommentAuthorAssociation.MANNEQUIN:
      return r'MANNEQUIN';
    case Enum$CommentAuthorAssociation.MEMBER:
      return r'MEMBER';
    case Enum$CommentAuthorAssociation.NONE:
      return r'NONE';
    case Enum$CommentAuthorAssociation.OWNER:
      return r'OWNER';
    case Enum$CommentAuthorAssociation.$unknown:
      return r'$unknown';
  }
}

Enum$CommentAuthorAssociation fromJson$Enum$CommentAuthorAssociation(
    String value) {
  switch (value) {
    case r'COLLABORATOR':
      return Enum$CommentAuthorAssociation.COLLABORATOR;
    case r'CONTRIBUTOR':
      return Enum$CommentAuthorAssociation.CONTRIBUTOR;
    case r'FIRST_TIMER':
      return Enum$CommentAuthorAssociation.FIRST_TIMER;
    case r'FIRST_TIME_CONTRIBUTOR':
      return Enum$CommentAuthorAssociation.FIRST_TIME_CONTRIBUTOR;
    case r'MANNEQUIN':
      return Enum$CommentAuthorAssociation.MANNEQUIN;
    case r'MEMBER':
      return Enum$CommentAuthorAssociation.MEMBER;
    case r'NONE':
      return Enum$CommentAuthorAssociation.NONE;
    case r'OWNER':
      return Enum$CommentAuthorAssociation.OWNER;
    default:
      return Enum$CommentAuthorAssociation.$unknown;
  }
}

enum Enum$CommentCannotUpdateReason {
  ARCHIVED,
  DENIED,
  INSUFFICIENT_ACCESS,
  LOCKED,
  LOGIN_REQUIRED,
  MAINTENANCE,
  VERIFIED_EMAIL_REQUIRED,
  $unknown
}

String toJson$Enum$CommentCannotUpdateReason(Enum$CommentCannotUpdateReason e) {
  switch (e) {
    case Enum$CommentCannotUpdateReason.ARCHIVED:
      return r'ARCHIVED';
    case Enum$CommentCannotUpdateReason.DENIED:
      return r'DENIED';
    case Enum$CommentCannotUpdateReason.INSUFFICIENT_ACCESS:
      return r'INSUFFICIENT_ACCESS';
    case Enum$CommentCannotUpdateReason.LOCKED:
      return r'LOCKED';
    case Enum$CommentCannotUpdateReason.LOGIN_REQUIRED:
      return r'LOGIN_REQUIRED';
    case Enum$CommentCannotUpdateReason.MAINTENANCE:
      return r'MAINTENANCE';
    case Enum$CommentCannotUpdateReason.VERIFIED_EMAIL_REQUIRED:
      return r'VERIFIED_EMAIL_REQUIRED';
    case Enum$CommentCannotUpdateReason.$unknown:
      return r'$unknown';
  }
}

Enum$CommentCannotUpdateReason fromJson$Enum$CommentCannotUpdateReason(
    String value) {
  switch (value) {
    case r'ARCHIVED':
      return Enum$CommentCannotUpdateReason.ARCHIVED;
    case r'DENIED':
      return Enum$CommentCannotUpdateReason.DENIED;
    case r'INSUFFICIENT_ACCESS':
      return Enum$CommentCannotUpdateReason.INSUFFICIENT_ACCESS;
    case r'LOCKED':
      return Enum$CommentCannotUpdateReason.LOCKED;
    case r'LOGIN_REQUIRED':
      return Enum$CommentCannotUpdateReason.LOGIN_REQUIRED;
    case r'MAINTENANCE':
      return Enum$CommentCannotUpdateReason.MAINTENANCE;
    case r'VERIFIED_EMAIL_REQUIRED':
      return Enum$CommentCannotUpdateReason.VERIFIED_EMAIL_REQUIRED;
    default:
      return Enum$CommentCannotUpdateReason.$unknown;
  }
}

enum Enum$CommitContributionOrderField { COMMIT_COUNT, OCCURRED_AT, $unknown }

String toJson$Enum$CommitContributionOrderField(
    Enum$CommitContributionOrderField e) {
  switch (e) {
    case Enum$CommitContributionOrderField.COMMIT_COUNT:
      return r'COMMIT_COUNT';
    case Enum$CommitContributionOrderField.OCCURRED_AT:
      return r'OCCURRED_AT';
    case Enum$CommitContributionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$CommitContributionOrderField fromJson$Enum$CommitContributionOrderField(
    String value) {
  switch (value) {
    case r'COMMIT_COUNT':
      return Enum$CommitContributionOrderField.COMMIT_COUNT;
    case r'OCCURRED_AT':
      return Enum$CommitContributionOrderField.OCCURRED_AT;
    default:
      return Enum$CommitContributionOrderField.$unknown;
  }
}

enum Enum$ComparisonStatus { AHEAD, BEHIND, DIVERGED, IDENTICAL, $unknown }

String toJson$Enum$ComparisonStatus(Enum$ComparisonStatus e) {
  switch (e) {
    case Enum$ComparisonStatus.AHEAD:
      return r'AHEAD';
    case Enum$ComparisonStatus.BEHIND:
      return r'BEHIND';
    case Enum$ComparisonStatus.DIVERGED:
      return r'DIVERGED';
    case Enum$ComparisonStatus.IDENTICAL:
      return r'IDENTICAL';
    case Enum$ComparisonStatus.$unknown:
      return r'$unknown';
  }
}

Enum$ComparisonStatus fromJson$Enum$ComparisonStatus(String value) {
  switch (value) {
    case r'AHEAD':
      return Enum$ComparisonStatus.AHEAD;
    case r'BEHIND':
      return Enum$ComparisonStatus.BEHIND;
    case r'DIVERGED':
      return Enum$ComparisonStatus.DIVERGED;
    case r'IDENTICAL':
      return Enum$ComparisonStatus.IDENTICAL;
    default:
      return Enum$ComparisonStatus.$unknown;
  }
}

enum Enum$ContributionLevel {
  FIRST_QUARTILE,
  FOURTH_QUARTILE,
  NONE,
  SECOND_QUARTILE,
  THIRD_QUARTILE,
  $unknown
}

String toJson$Enum$ContributionLevel(Enum$ContributionLevel e) {
  switch (e) {
    case Enum$ContributionLevel.FIRST_QUARTILE:
      return r'FIRST_QUARTILE';
    case Enum$ContributionLevel.FOURTH_QUARTILE:
      return r'FOURTH_QUARTILE';
    case Enum$ContributionLevel.NONE:
      return r'NONE';
    case Enum$ContributionLevel.SECOND_QUARTILE:
      return r'SECOND_QUARTILE';
    case Enum$ContributionLevel.THIRD_QUARTILE:
      return r'THIRD_QUARTILE';
    case Enum$ContributionLevel.$unknown:
      return r'$unknown';
  }
}

Enum$ContributionLevel fromJson$Enum$ContributionLevel(String value) {
  switch (value) {
    case r'FIRST_QUARTILE':
      return Enum$ContributionLevel.FIRST_QUARTILE;
    case r'FOURTH_QUARTILE':
      return Enum$ContributionLevel.FOURTH_QUARTILE;
    case r'NONE':
      return Enum$ContributionLevel.NONE;
    case r'SECOND_QUARTILE':
      return Enum$ContributionLevel.SECOND_QUARTILE;
    case r'THIRD_QUARTILE':
      return Enum$ContributionLevel.THIRD_QUARTILE;
    default:
      return Enum$ContributionLevel.$unknown;
  }
}

enum Enum$DefaultRepositoryPermissionField {
  ADMIN,
  NONE,
  READ,
  WRITE,
  $unknown
}

String toJson$Enum$DefaultRepositoryPermissionField(
    Enum$DefaultRepositoryPermissionField e) {
  switch (e) {
    case Enum$DefaultRepositoryPermissionField.ADMIN:
      return r'ADMIN';
    case Enum$DefaultRepositoryPermissionField.NONE:
      return r'NONE';
    case Enum$DefaultRepositoryPermissionField.READ:
      return r'READ';
    case Enum$DefaultRepositoryPermissionField.WRITE:
      return r'WRITE';
    case Enum$DefaultRepositoryPermissionField.$unknown:
      return r'$unknown';
  }
}

Enum$DefaultRepositoryPermissionField
    fromJson$Enum$DefaultRepositoryPermissionField(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$DefaultRepositoryPermissionField.ADMIN;
    case r'NONE':
      return Enum$DefaultRepositoryPermissionField.NONE;
    case r'READ':
      return Enum$DefaultRepositoryPermissionField.READ;
    case r'WRITE':
      return Enum$DefaultRepositoryPermissionField.WRITE;
    default:
      return Enum$DefaultRepositoryPermissionField.$unknown;
  }
}

enum Enum$DependencyGraphEcosystem {
  ACTIONS,
  COMPOSER,
  GO,
  MAVEN,
  NPM,
  NUGET,
  PIP,
  PUB,
  RUBYGEMS,
  RUST,
  $unknown
}

String toJson$Enum$DependencyGraphEcosystem(Enum$DependencyGraphEcosystem e) {
  switch (e) {
    case Enum$DependencyGraphEcosystem.ACTIONS:
      return r'ACTIONS';
    case Enum$DependencyGraphEcosystem.COMPOSER:
      return r'COMPOSER';
    case Enum$DependencyGraphEcosystem.GO:
      return r'GO';
    case Enum$DependencyGraphEcosystem.MAVEN:
      return r'MAVEN';
    case Enum$DependencyGraphEcosystem.NPM:
      return r'NPM';
    case Enum$DependencyGraphEcosystem.NUGET:
      return r'NUGET';
    case Enum$DependencyGraphEcosystem.PIP:
      return r'PIP';
    case Enum$DependencyGraphEcosystem.PUB:
      return r'PUB';
    case Enum$DependencyGraphEcosystem.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$DependencyGraphEcosystem.RUST:
      return r'RUST';
    case Enum$DependencyGraphEcosystem.$unknown:
      return r'$unknown';
  }
}

Enum$DependencyGraphEcosystem fromJson$Enum$DependencyGraphEcosystem(
    String value) {
  switch (value) {
    case r'ACTIONS':
      return Enum$DependencyGraphEcosystem.ACTIONS;
    case r'COMPOSER':
      return Enum$DependencyGraphEcosystem.COMPOSER;
    case r'GO':
      return Enum$DependencyGraphEcosystem.GO;
    case r'MAVEN':
      return Enum$DependencyGraphEcosystem.MAVEN;
    case r'NPM':
      return Enum$DependencyGraphEcosystem.NPM;
    case r'NUGET':
      return Enum$DependencyGraphEcosystem.NUGET;
    case r'PIP':
      return Enum$DependencyGraphEcosystem.PIP;
    case r'PUB':
      return Enum$DependencyGraphEcosystem.PUB;
    case r'RUBYGEMS':
      return Enum$DependencyGraphEcosystem.RUBYGEMS;
    case r'RUST':
      return Enum$DependencyGraphEcosystem.RUST;
    default:
      return Enum$DependencyGraphEcosystem.$unknown;
  }
}

enum Enum$DeploymentOrderField { CREATED_AT, $unknown }

String toJson$Enum$DeploymentOrderField(Enum$DeploymentOrderField e) {
  switch (e) {
    case Enum$DeploymentOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$DeploymentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentOrderField fromJson$Enum$DeploymentOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$DeploymentOrderField.CREATED_AT;
    default:
      return Enum$DeploymentOrderField.$unknown;
  }
}

enum Enum$DeploymentProtectionRuleType {
  REQUIRED_REVIEWERS,
  WAIT_TIMER,
  $unknown
}

String toJson$Enum$DeploymentProtectionRuleType(
    Enum$DeploymentProtectionRuleType e) {
  switch (e) {
    case Enum$DeploymentProtectionRuleType.REQUIRED_REVIEWERS:
      return r'REQUIRED_REVIEWERS';
    case Enum$DeploymentProtectionRuleType.WAIT_TIMER:
      return r'WAIT_TIMER';
    case Enum$DeploymentProtectionRuleType.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentProtectionRuleType fromJson$Enum$DeploymentProtectionRuleType(
    String value) {
  switch (value) {
    case r'REQUIRED_REVIEWERS':
      return Enum$DeploymentProtectionRuleType.REQUIRED_REVIEWERS;
    case r'WAIT_TIMER':
      return Enum$DeploymentProtectionRuleType.WAIT_TIMER;
    default:
      return Enum$DeploymentProtectionRuleType.$unknown;
  }
}

enum Enum$DeploymentReviewState { APPROVED, REJECTED, $unknown }

String toJson$Enum$DeploymentReviewState(Enum$DeploymentReviewState e) {
  switch (e) {
    case Enum$DeploymentReviewState.APPROVED:
      return r'APPROVED';
    case Enum$DeploymentReviewState.REJECTED:
      return r'REJECTED';
    case Enum$DeploymentReviewState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentReviewState fromJson$Enum$DeploymentReviewState(String value) {
  switch (value) {
    case r'APPROVED':
      return Enum$DeploymentReviewState.APPROVED;
    case r'REJECTED':
      return Enum$DeploymentReviewState.REJECTED;
    default:
      return Enum$DeploymentReviewState.$unknown;
  }
}

enum Enum$DeploymentState {
  ABANDONED,
  ACTIVE,
  DESTROYED,
  ERROR,
  FAILURE,
  INACTIVE,
  IN_PROGRESS,
  PENDING,
  QUEUED,
  WAITING,
  $unknown
}

String toJson$Enum$DeploymentState(Enum$DeploymentState e) {
  switch (e) {
    case Enum$DeploymentState.ABANDONED:
      return r'ABANDONED';
    case Enum$DeploymentState.ACTIVE:
      return r'ACTIVE';
    case Enum$DeploymentState.DESTROYED:
      return r'DESTROYED';
    case Enum$DeploymentState.ERROR:
      return r'ERROR';
    case Enum$DeploymentState.FAILURE:
      return r'FAILURE';
    case Enum$DeploymentState.INACTIVE:
      return r'INACTIVE';
    case Enum$DeploymentState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$DeploymentState.PENDING:
      return r'PENDING';
    case Enum$DeploymentState.QUEUED:
      return r'QUEUED';
    case Enum$DeploymentState.WAITING:
      return r'WAITING';
    case Enum$DeploymentState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentState fromJson$Enum$DeploymentState(String value) {
  switch (value) {
    case r'ABANDONED':
      return Enum$DeploymentState.ABANDONED;
    case r'ACTIVE':
      return Enum$DeploymentState.ACTIVE;
    case r'DESTROYED':
      return Enum$DeploymentState.DESTROYED;
    case r'ERROR':
      return Enum$DeploymentState.ERROR;
    case r'FAILURE':
      return Enum$DeploymentState.FAILURE;
    case r'INACTIVE':
      return Enum$DeploymentState.INACTIVE;
    case r'IN_PROGRESS':
      return Enum$DeploymentState.IN_PROGRESS;
    case r'PENDING':
      return Enum$DeploymentState.PENDING;
    case r'QUEUED':
      return Enum$DeploymentState.QUEUED;
    case r'WAITING':
      return Enum$DeploymentState.WAITING;
    default:
      return Enum$DeploymentState.$unknown;
  }
}

enum Enum$DeploymentStatusState {
  ERROR,
  FAILURE,
  INACTIVE,
  IN_PROGRESS,
  PENDING,
  QUEUED,
  SUCCESS,
  WAITING,
  $unknown
}

String toJson$Enum$DeploymentStatusState(Enum$DeploymentStatusState e) {
  switch (e) {
    case Enum$DeploymentStatusState.ERROR:
      return r'ERROR';
    case Enum$DeploymentStatusState.FAILURE:
      return r'FAILURE';
    case Enum$DeploymentStatusState.INACTIVE:
      return r'INACTIVE';
    case Enum$DeploymentStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$DeploymentStatusState.PENDING:
      return r'PENDING';
    case Enum$DeploymentStatusState.QUEUED:
      return r'QUEUED';
    case Enum$DeploymentStatusState.SUCCESS:
      return r'SUCCESS';
    case Enum$DeploymentStatusState.WAITING:
      return r'WAITING';
    case Enum$DeploymentStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$DeploymentStatusState fromJson$Enum$DeploymentStatusState(String value) {
  switch (value) {
    case r'ERROR':
      return Enum$DeploymentStatusState.ERROR;
    case r'FAILURE':
      return Enum$DeploymentStatusState.FAILURE;
    case r'INACTIVE':
      return Enum$DeploymentStatusState.INACTIVE;
    case r'IN_PROGRESS':
      return Enum$DeploymentStatusState.IN_PROGRESS;
    case r'PENDING':
      return Enum$DeploymentStatusState.PENDING;
    case r'QUEUED':
      return Enum$DeploymentStatusState.QUEUED;
    case r'SUCCESS':
      return Enum$DeploymentStatusState.SUCCESS;
    case r'WAITING':
      return Enum$DeploymentStatusState.WAITING;
    default:
      return Enum$DeploymentStatusState.$unknown;
  }
}

enum Enum$DiffSide { LEFT, RIGHT, $unknown }

String toJson$Enum$DiffSide(Enum$DiffSide e) {
  switch (e) {
    case Enum$DiffSide.LEFT:
      return r'LEFT';
    case Enum$DiffSide.RIGHT:
      return r'RIGHT';
    case Enum$DiffSide.$unknown:
      return r'$unknown';
  }
}

Enum$DiffSide fromJson$Enum$DiffSide(String value) {
  switch (value) {
    case r'LEFT':
      return Enum$DiffSide.LEFT;
    case r'RIGHT':
      return Enum$DiffSide.RIGHT;
    default:
      return Enum$DiffSide.$unknown;
  }
}

enum Enum$DiscussionCloseReason { DUPLICATE, OUTDATED, RESOLVED, $unknown }

String toJson$Enum$DiscussionCloseReason(Enum$DiscussionCloseReason e) {
  switch (e) {
    case Enum$DiscussionCloseReason.DUPLICATE:
      return r'DUPLICATE';
    case Enum$DiscussionCloseReason.OUTDATED:
      return r'OUTDATED';
    case Enum$DiscussionCloseReason.RESOLVED:
      return r'RESOLVED';
    case Enum$DiscussionCloseReason.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionCloseReason fromJson$Enum$DiscussionCloseReason(String value) {
  switch (value) {
    case r'DUPLICATE':
      return Enum$DiscussionCloseReason.DUPLICATE;
    case r'OUTDATED':
      return Enum$DiscussionCloseReason.OUTDATED;
    case r'RESOLVED':
      return Enum$DiscussionCloseReason.RESOLVED;
    default:
      return Enum$DiscussionCloseReason.$unknown;
  }
}

enum Enum$DiscussionOrderField { CREATED_AT, UPDATED_AT, $unknown }

String toJson$Enum$DiscussionOrderField(Enum$DiscussionOrderField e) {
  switch (e) {
    case Enum$DiscussionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$DiscussionOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$DiscussionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionOrderField fromJson$Enum$DiscussionOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$DiscussionOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$DiscussionOrderField.UPDATED_AT;
    default:
      return Enum$DiscussionOrderField.$unknown;
  }
}

enum Enum$DiscussionPollOptionOrderField {
  AUTHORED_ORDER,
  VOTE_COUNT,
  $unknown
}

String toJson$Enum$DiscussionPollOptionOrderField(
    Enum$DiscussionPollOptionOrderField e) {
  switch (e) {
    case Enum$DiscussionPollOptionOrderField.AUTHORED_ORDER:
      return r'AUTHORED_ORDER';
    case Enum$DiscussionPollOptionOrderField.VOTE_COUNT:
      return r'VOTE_COUNT';
    case Enum$DiscussionPollOptionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionPollOptionOrderField
    fromJson$Enum$DiscussionPollOptionOrderField(String value) {
  switch (value) {
    case r'AUTHORED_ORDER':
      return Enum$DiscussionPollOptionOrderField.AUTHORED_ORDER;
    case r'VOTE_COUNT':
      return Enum$DiscussionPollOptionOrderField.VOTE_COUNT;
    default:
      return Enum$DiscussionPollOptionOrderField.$unknown;
  }
}

enum Enum$DiscussionState { CLOSED, OPEN, $unknown }

String toJson$Enum$DiscussionState(Enum$DiscussionState e) {
  switch (e) {
    case Enum$DiscussionState.CLOSED:
      return r'CLOSED';
    case Enum$DiscussionState.OPEN:
      return r'OPEN';
    case Enum$DiscussionState.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionState fromJson$Enum$DiscussionState(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$DiscussionState.CLOSED;
    case r'OPEN':
      return Enum$DiscussionState.OPEN;
    default:
      return Enum$DiscussionState.$unknown;
  }
}

enum Enum$DiscussionStateReason {
  DUPLICATE,
  OUTDATED,
  REOPENED,
  RESOLVED,
  $unknown
}

String toJson$Enum$DiscussionStateReason(Enum$DiscussionStateReason e) {
  switch (e) {
    case Enum$DiscussionStateReason.DUPLICATE:
      return r'DUPLICATE';
    case Enum$DiscussionStateReason.OUTDATED:
      return r'OUTDATED';
    case Enum$DiscussionStateReason.REOPENED:
      return r'REOPENED';
    case Enum$DiscussionStateReason.RESOLVED:
      return r'RESOLVED';
    case Enum$DiscussionStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$DiscussionStateReason fromJson$Enum$DiscussionStateReason(String value) {
  switch (value) {
    case r'DUPLICATE':
      return Enum$DiscussionStateReason.DUPLICATE;
    case r'OUTDATED':
      return Enum$DiscussionStateReason.OUTDATED;
    case r'REOPENED':
      return Enum$DiscussionStateReason.REOPENED;
    case r'RESOLVED':
      return Enum$DiscussionStateReason.RESOLVED;
    default:
      return Enum$DiscussionStateReason.$unknown;
  }
}

enum Enum$DismissReason {
  FIX_STARTED,
  INACCURATE,
  NOT_USED,
  NO_BANDWIDTH,
  TOLERABLE_RISK,
  $unknown
}

String toJson$Enum$DismissReason(Enum$DismissReason e) {
  switch (e) {
    case Enum$DismissReason.FIX_STARTED:
      return r'FIX_STARTED';
    case Enum$DismissReason.INACCURATE:
      return r'INACCURATE';
    case Enum$DismissReason.NOT_USED:
      return r'NOT_USED';
    case Enum$DismissReason.NO_BANDWIDTH:
      return r'NO_BANDWIDTH';
    case Enum$DismissReason.TOLERABLE_RISK:
      return r'TOLERABLE_RISK';
    case Enum$DismissReason.$unknown:
      return r'$unknown';
  }
}

Enum$DismissReason fromJson$Enum$DismissReason(String value) {
  switch (value) {
    case r'FIX_STARTED':
      return Enum$DismissReason.FIX_STARTED;
    case r'INACCURATE':
      return Enum$DismissReason.INACCURATE;
    case r'NOT_USED':
      return Enum$DismissReason.NOT_USED;
    case r'NO_BANDWIDTH':
      return Enum$DismissReason.NO_BANDWIDTH;
    case r'TOLERABLE_RISK':
      return Enum$DismissReason.TOLERABLE_RISK;
    default:
      return Enum$DismissReason.$unknown;
  }
}

enum Enum$EnterpriseAdministratorInvitationOrderField { CREATED_AT, $unknown }

String toJson$Enum$EnterpriseAdministratorInvitationOrderField(
    Enum$EnterpriseAdministratorInvitationOrderField e) {
  switch (e) {
    case Enum$EnterpriseAdministratorInvitationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseAdministratorInvitationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAdministratorInvitationOrderField
    fromJson$Enum$EnterpriseAdministratorInvitationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseAdministratorInvitationOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseAdministratorInvitationOrderField.$unknown;
  }
}

enum Enum$EnterpriseAdministratorRole { BILLING_MANAGER, OWNER, $unknown }

String toJson$Enum$EnterpriseAdministratorRole(
    Enum$EnterpriseAdministratorRole e) {
  switch (e) {
    case Enum$EnterpriseAdministratorRole.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$EnterpriseAdministratorRole.OWNER:
      return r'OWNER';
    case Enum$EnterpriseAdministratorRole.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAdministratorRole fromJson$Enum$EnterpriseAdministratorRole(
    String value) {
  switch (value) {
    case r'BILLING_MANAGER':
      return Enum$EnterpriseAdministratorRole.BILLING_MANAGER;
    case r'OWNER':
      return Enum$EnterpriseAdministratorRole.OWNER;
    default:
      return Enum$EnterpriseAdministratorRole.$unknown;
  }
}

enum Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue {
  ENTERPRISE_ORGANIZATIONS,
  ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS,
  EVERYWHERE,
  SAME_ORGANIZATION,
  SAME_ORGANIZATION_USER_ACCOUNTS,
  USER_ACCOUNTS,
  $unknown
}

String toJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
    Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue e) {
  switch (e) {
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .ENTERPRISE_ORGANIZATIONS:
      return r'ENTERPRISE_ORGANIZATIONS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS:
      return r'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.EVERYWHERE:
      return r'EVERYWHERE';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .SAME_ORGANIZATION:
      return r'SAME_ORGANIZATION';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
        .SAME_ORGANIZATION_USER_ACCOUNTS:
      return r'SAME_ORGANIZATION_USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.USER_ACCOUNTS:
      return r'USER_ACCOUNTS';
    case Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
    fromJson$Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue(
        String value) {
  switch (value) {
    case r'ENTERPRISE_ORGANIZATIONS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS;
    case r'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS;
    case r'EVERYWHERE':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.EVERYWHERE;
    case r'SAME_ORGANIZATION':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION;
    case r'SAME_ORGANIZATION_USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .SAME_ORGANIZATION_USER_ACCOUNTS;
    case r'USER_ACCOUNTS':
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue
          .USER_ACCOUNTS;
    default:
      return Enum$EnterpriseAllowPrivateRepositoryForkingPolicyValue.$unknown;
  }
}

enum Enum$EnterpriseDefaultRepositoryPermissionSettingValue {
  ADMIN,
  NONE,
  NO_POLICY,
  READ,
  WRITE,
  $unknown
}

String toJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
    Enum$EnterpriseDefaultRepositoryPermissionSettingValue e) {
  switch (e) {
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.ADMIN:
      return r'ADMIN';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NONE:
      return r'NONE';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.READ:
      return r'READ';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.WRITE:
      return r'WRITE';
    case Enum$EnterpriseDefaultRepositoryPermissionSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseDefaultRepositoryPermissionSettingValue
    fromJson$Enum$EnterpriseDefaultRepositoryPermissionSettingValue(
        String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.ADMIN;
    case r'NONE':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NONE;
    case r'NO_POLICY':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.NO_POLICY;
    case r'READ':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.READ;
    case r'WRITE':
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.WRITE;
    default:
      return Enum$EnterpriseDefaultRepositoryPermissionSettingValue.$unknown;
  }
}

enum Enum$EnterpriseEnabledDisabledSettingValue {
  DISABLED,
  ENABLED,
  NO_POLICY,
  $unknown
}

String toJson$Enum$EnterpriseEnabledDisabledSettingValue(
    Enum$EnterpriseEnabledDisabledSettingValue e) {
  switch (e) {
    case Enum$EnterpriseEnabledDisabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseEnabledDisabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseEnabledDisabledSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseEnabledDisabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseEnabledDisabledSettingValue
    fromJson$Enum$EnterpriseEnabledDisabledSettingValue(String value) {
  switch (value) {
    case r'DISABLED':
      return Enum$EnterpriseEnabledDisabledSettingValue.DISABLED;
    case r'ENABLED':
      return Enum$EnterpriseEnabledDisabledSettingValue.ENABLED;
    case r'NO_POLICY':
      return Enum$EnterpriseEnabledDisabledSettingValue.NO_POLICY;
    default:
      return Enum$EnterpriseEnabledDisabledSettingValue.$unknown;
  }
}

enum Enum$EnterpriseEnabledSettingValue { ENABLED, NO_POLICY, $unknown }

String toJson$Enum$EnterpriseEnabledSettingValue(
    Enum$EnterpriseEnabledSettingValue e) {
  switch (e) {
    case Enum$EnterpriseEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseEnabledSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseEnabledSettingValue fromJson$Enum$EnterpriseEnabledSettingValue(
    String value) {
  switch (value) {
    case r'ENABLED':
      return Enum$EnterpriseEnabledSettingValue.ENABLED;
    case r'NO_POLICY':
      return Enum$EnterpriseEnabledSettingValue.NO_POLICY;
    default:
      return Enum$EnterpriseEnabledSettingValue.$unknown;
  }
}

enum Enum$EnterpriseMemberOrderField { CREATED_AT, LOGIN, $unknown }

String toJson$Enum$EnterpriseMemberOrderField(
    Enum$EnterpriseMemberOrderField e) {
  switch (e) {
    case Enum$EnterpriseMemberOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseMemberOrderField.LOGIN:
      return r'LOGIN';
    case Enum$EnterpriseMemberOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMemberOrderField fromJson$Enum$EnterpriseMemberOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseMemberOrderField.CREATED_AT;
    case r'LOGIN':
      return Enum$EnterpriseMemberOrderField.LOGIN;
    default:
      return Enum$EnterpriseMemberOrderField.$unknown;
  }
}

enum Enum$EnterpriseMembersCanCreateRepositoriesSettingValue {
  ALL,
  DISABLED,
  NO_POLICY,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
    Enum$EnterpriseMembersCanCreateRepositoriesSettingValue e) {
  switch (e) {
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.ALL:
      return r'ALL';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.NO_POLICY:
      return r'NO_POLICY';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PRIVATE:
      return r'PRIVATE';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PUBLIC:
      return r'PUBLIC';
    case Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMembersCanCreateRepositoriesSettingValue
    fromJson$Enum$EnterpriseMembersCanCreateRepositoriesSettingValue(
        String value) {
  switch (value) {
    case r'ALL':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.ALL;
    case r'DISABLED':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.DISABLED;
    case r'NO_POLICY':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.NO_POLICY;
    case r'PRIVATE':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PRIVATE;
    case r'PUBLIC':
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.PUBLIC;
    default:
      return Enum$EnterpriseMembersCanCreateRepositoriesSettingValue.$unknown;
  }
}

enum Enum$EnterpriseMembersCanMakePurchasesSettingValue {
  DISABLED,
  ENABLED,
  $unknown
}

String toJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(
    Enum$EnterpriseMembersCanMakePurchasesSettingValue e) {
  switch (e) {
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$EnterpriseMembersCanMakePurchasesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseMembersCanMakePurchasesSettingValue
    fromJson$Enum$EnterpriseMembersCanMakePurchasesSettingValue(String value) {
  switch (value) {
    case r'DISABLED':
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.DISABLED;
    case r'ENABLED':
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.ENABLED;
    default:
      return Enum$EnterpriseMembersCanMakePurchasesSettingValue.$unknown;
  }
}

enum Enum$EnterpriseServerInstallationOrderField {
  CREATED_AT,
  CUSTOMER_NAME,
  HOST_NAME,
  $unknown
}

String toJson$Enum$EnterpriseServerInstallationOrderField(
    Enum$EnterpriseServerInstallationOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerInstallationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseServerInstallationOrderField.CUSTOMER_NAME:
      return r'CUSTOMER_NAME';
    case Enum$EnterpriseServerInstallationOrderField.HOST_NAME:
      return r'HOST_NAME';
    case Enum$EnterpriseServerInstallationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerInstallationOrderField
    fromJson$Enum$EnterpriseServerInstallationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseServerInstallationOrderField.CREATED_AT;
    case r'CUSTOMER_NAME':
      return Enum$EnterpriseServerInstallationOrderField.CUSTOMER_NAME;
    case r'HOST_NAME':
      return Enum$EnterpriseServerInstallationOrderField.HOST_NAME;
    default:
      return Enum$EnterpriseServerInstallationOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountEmailOrderField { EMAIL, $unknown }

String toJson$Enum$EnterpriseServerUserAccountEmailOrderField(
    Enum$EnterpriseServerUserAccountEmailOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountEmailOrderField.EMAIL:
      return r'EMAIL';
    case Enum$EnterpriseServerUserAccountEmailOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountEmailOrderField
    fromJson$Enum$EnterpriseServerUserAccountEmailOrderField(String value) {
  switch (value) {
    case r'EMAIL':
      return Enum$EnterpriseServerUserAccountEmailOrderField.EMAIL;
    default:
      return Enum$EnterpriseServerUserAccountEmailOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountOrderField {
  LOGIN,
  REMOTE_CREATED_AT,
  $unknown
}

String toJson$Enum$EnterpriseServerUserAccountOrderField(
    Enum$EnterpriseServerUserAccountOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountOrderField.LOGIN:
      return r'LOGIN';
    case Enum$EnterpriseServerUserAccountOrderField.REMOTE_CREATED_AT:
      return r'REMOTE_CREATED_AT';
    case Enum$EnterpriseServerUserAccountOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountOrderField
    fromJson$Enum$EnterpriseServerUserAccountOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$EnterpriseServerUserAccountOrderField.LOGIN;
    case r'REMOTE_CREATED_AT':
      return Enum$EnterpriseServerUserAccountOrderField.REMOTE_CREATED_AT;
    default:
      return Enum$EnterpriseServerUserAccountOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountsUploadOrderField { CREATED_AT, $unknown }

String toJson$Enum$EnterpriseServerUserAccountsUploadOrderField(
    Enum$EnterpriseServerUserAccountsUploadOrderField e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountsUploadOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$EnterpriseServerUserAccountsUploadOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountsUploadOrderField
    fromJson$Enum$EnterpriseServerUserAccountsUploadOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$EnterpriseServerUserAccountsUploadOrderField.CREATED_AT;
    default:
      return Enum$EnterpriseServerUserAccountsUploadOrderField.$unknown;
  }
}

enum Enum$EnterpriseServerUserAccountsUploadSyncState {
  FAILURE,
  PENDING,
  SUCCESS,
  $unknown
}

String toJson$Enum$EnterpriseServerUserAccountsUploadSyncState(
    Enum$EnterpriseServerUserAccountsUploadSyncState e) {
  switch (e) {
    case Enum$EnterpriseServerUserAccountsUploadSyncState.FAILURE:
      return r'FAILURE';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.PENDING:
      return r'PENDING';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.SUCCESS:
      return r'SUCCESS';
    case Enum$EnterpriseServerUserAccountsUploadSyncState.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseServerUserAccountsUploadSyncState
    fromJson$Enum$EnterpriseServerUserAccountsUploadSyncState(String value) {
  switch (value) {
    case r'FAILURE':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.FAILURE;
    case r'PENDING':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.PENDING;
    case r'SUCCESS':
      return Enum$EnterpriseServerUserAccountsUploadSyncState.SUCCESS;
    default:
      return Enum$EnterpriseServerUserAccountsUploadSyncState.$unknown;
  }
}

enum Enum$EnterpriseUserAccountMembershipRole {
  MEMBER,
  OWNER,
  UNAFFILIATED,
  $unknown
}

String toJson$Enum$EnterpriseUserAccountMembershipRole(
    Enum$EnterpriseUserAccountMembershipRole e) {
  switch (e) {
    case Enum$EnterpriseUserAccountMembershipRole.MEMBER:
      return r'MEMBER';
    case Enum$EnterpriseUserAccountMembershipRole.OWNER:
      return r'OWNER';
    case Enum$EnterpriseUserAccountMembershipRole.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$EnterpriseUserAccountMembershipRole.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseUserAccountMembershipRole
    fromJson$Enum$EnterpriseUserAccountMembershipRole(String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$EnterpriseUserAccountMembershipRole.MEMBER;
    case r'OWNER':
      return Enum$EnterpriseUserAccountMembershipRole.OWNER;
    case r'UNAFFILIATED':
      return Enum$EnterpriseUserAccountMembershipRole.UNAFFILIATED;
    default:
      return Enum$EnterpriseUserAccountMembershipRole.$unknown;
  }
}

enum Enum$EnterpriseUserDeployment { CLOUD, SERVER, $unknown }

String toJson$Enum$EnterpriseUserDeployment(Enum$EnterpriseUserDeployment e) {
  switch (e) {
    case Enum$EnterpriseUserDeployment.CLOUD:
      return r'CLOUD';
    case Enum$EnterpriseUserDeployment.SERVER:
      return r'SERVER';
    case Enum$EnterpriseUserDeployment.$unknown:
      return r'$unknown';
  }
}

Enum$EnterpriseUserDeployment fromJson$Enum$EnterpriseUserDeployment(
    String value) {
  switch (value) {
    case r'CLOUD':
      return Enum$EnterpriseUserDeployment.CLOUD;
    case r'SERVER':
      return Enum$EnterpriseUserDeployment.SERVER;
    default:
      return Enum$EnterpriseUserDeployment.$unknown;
  }
}

enum Enum$FileViewedState { DISMISSED, UNVIEWED, VIEWED, $unknown }

String toJson$Enum$FileViewedState(Enum$FileViewedState e) {
  switch (e) {
    case Enum$FileViewedState.DISMISSED:
      return r'DISMISSED';
    case Enum$FileViewedState.UNVIEWED:
      return r'UNVIEWED';
    case Enum$FileViewedState.VIEWED:
      return r'VIEWED';
    case Enum$FileViewedState.$unknown:
      return r'$unknown';
  }
}

Enum$FileViewedState fromJson$Enum$FileViewedState(String value) {
  switch (value) {
    case r'DISMISSED':
      return Enum$FileViewedState.DISMISSED;
    case r'UNVIEWED':
      return Enum$FileViewedState.UNVIEWED;
    case r'VIEWED':
      return Enum$FileViewedState.VIEWED;
    default:
      return Enum$FileViewedState.$unknown;
  }
}

enum Enum$FundingPlatform {
  COMMUNITY_BRIDGE,
  CUSTOM,
  GITHUB,
  ISSUEHUNT,
  KO_FI,
  LFX_CROWDFUNDING,
  LIBERAPAY,
  OPEN_COLLECTIVE,
  OTECHIE,
  PATREON,
  TIDELIFT,
  $unknown
}

String toJson$Enum$FundingPlatform(Enum$FundingPlatform e) {
  switch (e) {
    case Enum$FundingPlatform.COMMUNITY_BRIDGE:
      return r'COMMUNITY_BRIDGE';
    case Enum$FundingPlatform.CUSTOM:
      return r'CUSTOM';
    case Enum$FundingPlatform.GITHUB:
      return r'GITHUB';
    case Enum$FundingPlatform.ISSUEHUNT:
      return r'ISSUEHUNT';
    case Enum$FundingPlatform.KO_FI:
      return r'KO_FI';
    case Enum$FundingPlatform.LFX_CROWDFUNDING:
      return r'LFX_CROWDFUNDING';
    case Enum$FundingPlatform.LIBERAPAY:
      return r'LIBERAPAY';
    case Enum$FundingPlatform.OPEN_COLLECTIVE:
      return r'OPEN_COLLECTIVE';
    case Enum$FundingPlatform.OTECHIE:
      return r'OTECHIE';
    case Enum$FundingPlatform.PATREON:
      return r'PATREON';
    case Enum$FundingPlatform.TIDELIFT:
      return r'TIDELIFT';
    case Enum$FundingPlatform.$unknown:
      return r'$unknown';
  }
}

Enum$FundingPlatform fromJson$Enum$FundingPlatform(String value) {
  switch (value) {
    case r'COMMUNITY_BRIDGE':
      return Enum$FundingPlatform.COMMUNITY_BRIDGE;
    case r'CUSTOM':
      return Enum$FundingPlatform.CUSTOM;
    case r'GITHUB':
      return Enum$FundingPlatform.GITHUB;
    case r'ISSUEHUNT':
      return Enum$FundingPlatform.ISSUEHUNT;
    case r'KO_FI':
      return Enum$FundingPlatform.KO_FI;
    case r'LFX_CROWDFUNDING':
      return Enum$FundingPlatform.LFX_CROWDFUNDING;
    case r'LIBERAPAY':
      return Enum$FundingPlatform.LIBERAPAY;
    case r'OPEN_COLLECTIVE':
      return Enum$FundingPlatform.OPEN_COLLECTIVE;
    case r'OTECHIE':
      return Enum$FundingPlatform.OTECHIE;
    case r'PATREON':
      return Enum$FundingPlatform.PATREON;
    case r'TIDELIFT':
      return Enum$FundingPlatform.TIDELIFT;
    default:
      return Enum$FundingPlatform.$unknown;
  }
}

enum Enum$GistOrderField { CREATED_AT, PUSHED_AT, UPDATED_AT, $unknown }

String toJson$Enum$GistOrderField(Enum$GistOrderField e) {
  switch (e) {
    case Enum$GistOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$GistOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$GistOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$GistOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$GistOrderField fromJson$Enum$GistOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$GistOrderField.CREATED_AT;
    case r'PUSHED_AT':
      return Enum$GistOrderField.PUSHED_AT;
    case r'UPDATED_AT':
      return Enum$GistOrderField.UPDATED_AT;
    default:
      return Enum$GistOrderField.$unknown;
  }
}

enum Enum$GistPrivacy { ALL, PUBLIC, SECRET, $unknown }

String toJson$Enum$GistPrivacy(Enum$GistPrivacy e) {
  switch (e) {
    case Enum$GistPrivacy.ALL:
      return r'ALL';
    case Enum$GistPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$GistPrivacy.SECRET:
      return r'SECRET';
    case Enum$GistPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$GistPrivacy fromJson$Enum$GistPrivacy(String value) {
  switch (value) {
    case r'ALL':
      return Enum$GistPrivacy.ALL;
    case r'PUBLIC':
      return Enum$GistPrivacy.PUBLIC;
    case r'SECRET':
      return Enum$GistPrivacy.SECRET;
    default:
      return Enum$GistPrivacy.$unknown;
  }
}

enum Enum$GitSignatureState {
  BAD_CERT,
  BAD_EMAIL,
  EXPIRED_KEY,
  GPGVERIFY_ERROR,
  GPGVERIFY_UNAVAILABLE,
  INVALID,
  MALFORMED_SIG,
  NOT_SIGNING_KEY,
  NO_USER,
  OCSP_ERROR,
  OCSP_PENDING,
  OCSP_REVOKED,
  UNKNOWN_KEY,
  UNKNOWN_SIG_TYPE,
  UNSIGNED,
  UNVERIFIED_EMAIL,
  VALID,
  $unknown
}

String toJson$Enum$GitSignatureState(Enum$GitSignatureState e) {
  switch (e) {
    case Enum$GitSignatureState.BAD_CERT:
      return r'BAD_CERT';
    case Enum$GitSignatureState.BAD_EMAIL:
      return r'BAD_EMAIL';
    case Enum$GitSignatureState.EXPIRED_KEY:
      return r'EXPIRED_KEY';
    case Enum$GitSignatureState.GPGVERIFY_ERROR:
      return r'GPGVERIFY_ERROR';
    case Enum$GitSignatureState.GPGVERIFY_UNAVAILABLE:
      return r'GPGVERIFY_UNAVAILABLE';
    case Enum$GitSignatureState.INVALID:
      return r'INVALID';
    case Enum$GitSignatureState.MALFORMED_SIG:
      return r'MALFORMED_SIG';
    case Enum$GitSignatureState.NOT_SIGNING_KEY:
      return r'NOT_SIGNING_KEY';
    case Enum$GitSignatureState.NO_USER:
      return r'NO_USER';
    case Enum$GitSignatureState.OCSP_ERROR:
      return r'OCSP_ERROR';
    case Enum$GitSignatureState.OCSP_PENDING:
      return r'OCSP_PENDING';
    case Enum$GitSignatureState.OCSP_REVOKED:
      return r'OCSP_REVOKED';
    case Enum$GitSignatureState.UNKNOWN_KEY:
      return r'UNKNOWN_KEY';
    case Enum$GitSignatureState.UNKNOWN_SIG_TYPE:
      return r'UNKNOWN_SIG_TYPE';
    case Enum$GitSignatureState.UNSIGNED:
      return r'UNSIGNED';
    case Enum$GitSignatureState.UNVERIFIED_EMAIL:
      return r'UNVERIFIED_EMAIL';
    case Enum$GitSignatureState.VALID:
      return r'VALID';
    case Enum$GitSignatureState.$unknown:
      return r'$unknown';
  }
}

Enum$GitSignatureState fromJson$Enum$GitSignatureState(String value) {
  switch (value) {
    case r'BAD_CERT':
      return Enum$GitSignatureState.BAD_CERT;
    case r'BAD_EMAIL':
      return Enum$GitSignatureState.BAD_EMAIL;
    case r'EXPIRED_KEY':
      return Enum$GitSignatureState.EXPIRED_KEY;
    case r'GPGVERIFY_ERROR':
      return Enum$GitSignatureState.GPGVERIFY_ERROR;
    case r'GPGVERIFY_UNAVAILABLE':
      return Enum$GitSignatureState.GPGVERIFY_UNAVAILABLE;
    case r'INVALID':
      return Enum$GitSignatureState.INVALID;
    case r'MALFORMED_SIG':
      return Enum$GitSignatureState.MALFORMED_SIG;
    case r'NOT_SIGNING_KEY':
      return Enum$GitSignatureState.NOT_SIGNING_KEY;
    case r'NO_USER':
      return Enum$GitSignatureState.NO_USER;
    case r'OCSP_ERROR':
      return Enum$GitSignatureState.OCSP_ERROR;
    case r'OCSP_PENDING':
      return Enum$GitSignatureState.OCSP_PENDING;
    case r'OCSP_REVOKED':
      return Enum$GitSignatureState.OCSP_REVOKED;
    case r'UNKNOWN_KEY':
      return Enum$GitSignatureState.UNKNOWN_KEY;
    case r'UNKNOWN_SIG_TYPE':
      return Enum$GitSignatureState.UNKNOWN_SIG_TYPE;
    case r'UNSIGNED':
      return Enum$GitSignatureState.UNSIGNED;
    case r'UNVERIFIED_EMAIL':
      return Enum$GitSignatureState.UNVERIFIED_EMAIL;
    case r'VALID':
      return Enum$GitSignatureState.VALID;
    default:
      return Enum$GitSignatureState.$unknown;
  }
}

enum Enum$IdentityProviderConfigurationState {
  CONFIGURED,
  ENFORCED,
  UNCONFIGURED,
  $unknown
}

String toJson$Enum$IdentityProviderConfigurationState(
    Enum$IdentityProviderConfigurationState e) {
  switch (e) {
    case Enum$IdentityProviderConfigurationState.CONFIGURED:
      return r'CONFIGURED';
    case Enum$IdentityProviderConfigurationState.ENFORCED:
      return r'ENFORCED';
    case Enum$IdentityProviderConfigurationState.UNCONFIGURED:
      return r'UNCONFIGURED';
    case Enum$IdentityProviderConfigurationState.$unknown:
      return r'$unknown';
  }
}

Enum$IdentityProviderConfigurationState
    fromJson$Enum$IdentityProviderConfigurationState(String value) {
  switch (value) {
    case r'CONFIGURED':
      return Enum$IdentityProviderConfigurationState.CONFIGURED;
    case r'ENFORCED':
      return Enum$IdentityProviderConfigurationState.ENFORCED;
    case r'UNCONFIGURED':
      return Enum$IdentityProviderConfigurationState.UNCONFIGURED;
    default:
      return Enum$IdentityProviderConfigurationState.$unknown;
  }
}

enum Enum$IpAllowListEnabledSettingValue { DISABLED, ENABLED, $unknown }

String toJson$Enum$IpAllowListEnabledSettingValue(
    Enum$IpAllowListEnabledSettingValue e) {
  switch (e) {
    case Enum$IpAllowListEnabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$IpAllowListEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$IpAllowListEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListEnabledSettingValue
    fromJson$Enum$IpAllowListEnabledSettingValue(String value) {
  switch (value) {
    case r'DISABLED':
      return Enum$IpAllowListEnabledSettingValue.DISABLED;
    case r'ENABLED':
      return Enum$IpAllowListEnabledSettingValue.ENABLED;
    default:
      return Enum$IpAllowListEnabledSettingValue.$unknown;
  }
}

enum Enum$IpAllowListEntryOrderField { ALLOW_LIST_VALUE, CREATED_AT, $unknown }

String toJson$Enum$IpAllowListEntryOrderField(
    Enum$IpAllowListEntryOrderField e) {
  switch (e) {
    case Enum$IpAllowListEntryOrderField.ALLOW_LIST_VALUE:
      return r'ALLOW_LIST_VALUE';
    case Enum$IpAllowListEntryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IpAllowListEntryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListEntryOrderField fromJson$Enum$IpAllowListEntryOrderField(
    String value) {
  switch (value) {
    case r'ALLOW_LIST_VALUE':
      return Enum$IpAllowListEntryOrderField.ALLOW_LIST_VALUE;
    case r'CREATED_AT':
      return Enum$IpAllowListEntryOrderField.CREATED_AT;
    default:
      return Enum$IpAllowListEntryOrderField.$unknown;
  }
}

enum Enum$IpAllowListForInstalledAppsEnabledSettingValue {
  DISABLED,
  ENABLED,
  $unknown
}

String toJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(
    Enum$IpAllowListForInstalledAppsEnabledSettingValue e) {
  switch (e) {
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$IpAllowListForInstalledAppsEnabledSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$IpAllowListForInstalledAppsEnabledSettingValue
    fromJson$Enum$IpAllowListForInstalledAppsEnabledSettingValue(String value) {
  switch (value) {
    case r'DISABLED':
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.DISABLED;
    case r'ENABLED':
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.ENABLED;
    default:
      return Enum$IpAllowListForInstalledAppsEnabledSettingValue.$unknown;
  }
}

enum Enum$IssueClosedStateReason { COMPLETED, NOT_PLANNED, $unknown }

String toJson$Enum$IssueClosedStateReason(Enum$IssueClosedStateReason e) {
  switch (e) {
    case Enum$IssueClosedStateReason.COMPLETED:
      return r'COMPLETED';
    case Enum$IssueClosedStateReason.NOT_PLANNED:
      return r'NOT_PLANNED';
    case Enum$IssueClosedStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$IssueClosedStateReason fromJson$Enum$IssueClosedStateReason(String value) {
  switch (value) {
    case r'COMPLETED':
      return Enum$IssueClosedStateReason.COMPLETED;
    case r'NOT_PLANNED':
      return Enum$IssueClosedStateReason.NOT_PLANNED;
    default:
      return Enum$IssueClosedStateReason.$unknown;
  }
}

enum Enum$IssueCommentOrderField { UPDATED_AT, $unknown }

String toJson$Enum$IssueCommentOrderField(Enum$IssueCommentOrderField e) {
  switch (e) {
    case Enum$IssueCommentOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$IssueCommentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueCommentOrderField fromJson$Enum$IssueCommentOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$IssueCommentOrderField.UPDATED_AT;
    default:
      return Enum$IssueCommentOrderField.$unknown;
  }
}

enum Enum$IssueOrderField { COMMENTS, CREATED_AT, UPDATED_AT, $unknown }

String toJson$Enum$IssueOrderField(Enum$IssueOrderField e) {
  switch (e) {
    case Enum$IssueOrderField.COMMENTS:
      return r'COMMENTS';
    case Enum$IssueOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$IssueOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$IssueOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$IssueOrderField fromJson$Enum$IssueOrderField(String value) {
  switch (value) {
    case r'COMMENTS':
      return Enum$IssueOrderField.COMMENTS;
    case r'CREATED_AT':
      return Enum$IssueOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$IssueOrderField.UPDATED_AT;
    default:
      return Enum$IssueOrderField.$unknown;
  }
}

enum Enum$IssueState { CLOSED, OPEN, $unknown }

String toJson$Enum$IssueState(Enum$IssueState e) {
  switch (e) {
    case Enum$IssueState.CLOSED:
      return r'CLOSED';
    case Enum$IssueState.OPEN:
      return r'OPEN';
    case Enum$IssueState.$unknown:
      return r'$unknown';
  }
}

Enum$IssueState fromJson$Enum$IssueState(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$IssueState.CLOSED;
    case r'OPEN':
      return Enum$IssueState.OPEN;
    default:
      return Enum$IssueState.$unknown;
  }
}

enum Enum$IssueStateReason { COMPLETED, NOT_PLANNED, REOPENED, $unknown }

String toJson$Enum$IssueStateReason(Enum$IssueStateReason e) {
  switch (e) {
    case Enum$IssueStateReason.COMPLETED:
      return r'COMPLETED';
    case Enum$IssueStateReason.NOT_PLANNED:
      return r'NOT_PLANNED';
    case Enum$IssueStateReason.REOPENED:
      return r'REOPENED';
    case Enum$IssueStateReason.$unknown:
      return r'$unknown';
  }
}

Enum$IssueStateReason fromJson$Enum$IssueStateReason(String value) {
  switch (value) {
    case r'COMPLETED':
      return Enum$IssueStateReason.COMPLETED;
    case r'NOT_PLANNED':
      return Enum$IssueStateReason.NOT_PLANNED;
    case r'REOPENED':
      return Enum$IssueStateReason.REOPENED;
    default:
      return Enum$IssueStateReason.$unknown;
  }
}

enum Enum$IssueTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT,
  ASSIGNED_EVENT,
  CLOSED_EVENT,
  COMMENT_DELETED_EVENT,
  CONNECTED_EVENT,
  CONVERTED_NOTE_TO_ISSUE_EVENT,
  CONVERTED_TO_DISCUSSION_EVENT,
  CROSS_REFERENCED_EVENT,
  DEMILESTONED_EVENT,
  DISCONNECTED_EVENT,
  ISSUE_COMMENT,
  LABELED_EVENT,
  LOCKED_EVENT,
  MARKED_AS_DUPLICATE_EVENT,
  MENTIONED_EVENT,
  MILESTONED_EVENT,
  MOVED_COLUMNS_IN_PROJECT_EVENT,
  PINNED_EVENT,
  REFERENCED_EVENT,
  REMOVED_FROM_PROJECT_EVENT,
  RENAMED_TITLE_EVENT,
  REOPENED_EVENT,
  SUBSCRIBED_EVENT,
  TRANSFERRED_EVENT,
  UNASSIGNED_EVENT,
  UNLABELED_EVENT,
  UNLOCKED_EVENT,
  UNMARKED_AS_DUPLICATE_EVENT,
  UNPINNED_EVENT,
  UNSUBSCRIBED_EVENT,
  USER_BLOCKED_EVENT,
  $unknown
}

String toJson$Enum$IssueTimelineItemsItemType(
    Enum$IssueTimelineItemsItemType e) {
  switch (e) {
    case Enum$IssueTimelineItemsItemType.ADDED_TO_PROJECT_EVENT:
      return r'ADDED_TO_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.ASSIGNED_EVENT:
      return r'ASSIGNED_EVENT';
    case Enum$IssueTimelineItemsItemType.CLOSED_EVENT:
      return r'CLOSED_EVENT';
    case Enum$IssueTimelineItemsItemType.COMMENT_DELETED_EVENT:
      return r'COMMENT_DELETED_EVENT';
    case Enum$IssueTimelineItemsItemType.CONNECTED_EVENT:
      return r'CONNECTED_EVENT';
    case Enum$IssueTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT:
      return r'CONVERTED_NOTE_TO_ISSUE_EVENT';
    case Enum$IssueTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT:
      return r'CONVERTED_TO_DISCUSSION_EVENT';
    case Enum$IssueTimelineItemsItemType.CROSS_REFERENCED_EVENT:
      return r'CROSS_REFERENCED_EVENT';
    case Enum$IssueTimelineItemsItemType.DEMILESTONED_EVENT:
      return r'DEMILESTONED_EVENT';
    case Enum$IssueTimelineItemsItemType.DISCONNECTED_EVENT:
      return r'DISCONNECTED_EVENT';
    case Enum$IssueTimelineItemsItemType.ISSUE_COMMENT:
      return r'ISSUE_COMMENT';
    case Enum$IssueTimelineItemsItemType.LABELED_EVENT:
      return r'LABELED_EVENT';
    case Enum$IssueTimelineItemsItemType.LOCKED_EVENT:
      return r'LOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT:
      return r'MARKED_AS_DUPLICATE_EVENT';
    case Enum$IssueTimelineItemsItemType.MENTIONED_EVENT:
      return r'MENTIONED_EVENT';
    case Enum$IssueTimelineItemsItemType.MILESTONED_EVENT:
      return r'MILESTONED_EVENT';
    case Enum$IssueTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT:
      return r'MOVED_COLUMNS_IN_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.PINNED_EVENT:
      return r'PINNED_EVENT';
    case Enum$IssueTimelineItemsItemType.REFERENCED_EVENT:
      return r'REFERENCED_EVENT';
    case Enum$IssueTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT:
      return r'REMOVED_FROM_PROJECT_EVENT';
    case Enum$IssueTimelineItemsItemType.RENAMED_TITLE_EVENT:
      return r'RENAMED_TITLE_EVENT';
    case Enum$IssueTimelineItemsItemType.REOPENED_EVENT:
      return r'REOPENED_EVENT';
    case Enum$IssueTimelineItemsItemType.SUBSCRIBED_EVENT:
      return r'SUBSCRIBED_EVENT';
    case Enum$IssueTimelineItemsItemType.TRANSFERRED_EVENT:
      return r'TRANSFERRED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNASSIGNED_EVENT:
      return r'UNASSIGNED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNLABELED_EVENT:
      return r'UNLABELED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNLOCKED_EVENT:
      return r'UNLOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT:
      return r'UNMARKED_AS_DUPLICATE_EVENT';
    case Enum$IssueTimelineItemsItemType.UNPINNED_EVENT:
      return r'UNPINNED_EVENT';
    case Enum$IssueTimelineItemsItemType.UNSUBSCRIBED_EVENT:
      return r'UNSUBSCRIBED_EVENT';
    case Enum$IssueTimelineItemsItemType.USER_BLOCKED_EVENT:
      return r'USER_BLOCKED_EVENT';
    case Enum$IssueTimelineItemsItemType.$unknown:
      return r'$unknown';
  }
}

Enum$IssueTimelineItemsItemType fromJson$Enum$IssueTimelineItemsItemType(
    String value) {
  switch (value) {
    case r'ADDED_TO_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.ADDED_TO_PROJECT_EVENT;
    case r'ASSIGNED_EVENT':
      return Enum$IssueTimelineItemsItemType.ASSIGNED_EVENT;
    case r'CLOSED_EVENT':
      return Enum$IssueTimelineItemsItemType.CLOSED_EVENT;
    case r'COMMENT_DELETED_EVENT':
      return Enum$IssueTimelineItemsItemType.COMMENT_DELETED_EVENT;
    case r'CONNECTED_EVENT':
      return Enum$IssueTimelineItemsItemType.CONNECTED_EVENT;
    case r'CONVERTED_NOTE_TO_ISSUE_EVENT':
      return Enum$IssueTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT;
    case r'CONVERTED_TO_DISCUSSION_EVENT':
      return Enum$IssueTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT;
    case r'CROSS_REFERENCED_EVENT':
      return Enum$IssueTimelineItemsItemType.CROSS_REFERENCED_EVENT;
    case r'DEMILESTONED_EVENT':
      return Enum$IssueTimelineItemsItemType.DEMILESTONED_EVENT;
    case r'DISCONNECTED_EVENT':
      return Enum$IssueTimelineItemsItemType.DISCONNECTED_EVENT;
    case r'ISSUE_COMMENT':
      return Enum$IssueTimelineItemsItemType.ISSUE_COMMENT;
    case r'LABELED_EVENT':
      return Enum$IssueTimelineItemsItemType.LABELED_EVENT;
    case r'LOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.LOCKED_EVENT;
    case r'MARKED_AS_DUPLICATE_EVENT':
      return Enum$IssueTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT;
    case r'MENTIONED_EVENT':
      return Enum$IssueTimelineItemsItemType.MENTIONED_EVENT;
    case r'MILESTONED_EVENT':
      return Enum$IssueTimelineItemsItemType.MILESTONED_EVENT;
    case r'MOVED_COLUMNS_IN_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT;
    case r'PINNED_EVENT':
      return Enum$IssueTimelineItemsItemType.PINNED_EVENT;
    case r'REFERENCED_EVENT':
      return Enum$IssueTimelineItemsItemType.REFERENCED_EVENT;
    case r'REMOVED_FROM_PROJECT_EVENT':
      return Enum$IssueTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT;
    case r'RENAMED_TITLE_EVENT':
      return Enum$IssueTimelineItemsItemType.RENAMED_TITLE_EVENT;
    case r'REOPENED_EVENT':
      return Enum$IssueTimelineItemsItemType.REOPENED_EVENT;
    case r'SUBSCRIBED_EVENT':
      return Enum$IssueTimelineItemsItemType.SUBSCRIBED_EVENT;
    case r'TRANSFERRED_EVENT':
      return Enum$IssueTimelineItemsItemType.TRANSFERRED_EVENT;
    case r'UNASSIGNED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNASSIGNED_EVENT;
    case r'UNLABELED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNLABELED_EVENT;
    case r'UNLOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNLOCKED_EVENT;
    case r'UNMARKED_AS_DUPLICATE_EVENT':
      return Enum$IssueTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT;
    case r'UNPINNED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNPINNED_EVENT;
    case r'UNSUBSCRIBED_EVENT':
      return Enum$IssueTimelineItemsItemType.UNSUBSCRIBED_EVENT;
    case r'USER_BLOCKED_EVENT':
      return Enum$IssueTimelineItemsItemType.USER_BLOCKED_EVENT;
    default:
      return Enum$IssueTimelineItemsItemType.$unknown;
  }
}

enum Enum$LabelOrderField { CREATED_AT, NAME, $unknown }

String toJson$Enum$LabelOrderField(Enum$LabelOrderField e) {
  switch (e) {
    case Enum$LabelOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$LabelOrderField.NAME:
      return r'NAME';
    case Enum$LabelOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$LabelOrderField fromJson$Enum$LabelOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$LabelOrderField.CREATED_AT;
    case r'NAME':
      return Enum$LabelOrderField.NAME;
    default:
      return Enum$LabelOrderField.$unknown;
  }
}

enum Enum$LanguageOrderField { SIZE, $unknown }

String toJson$Enum$LanguageOrderField(Enum$LanguageOrderField e) {
  switch (e) {
    case Enum$LanguageOrderField.SIZE:
      return r'SIZE';
    case Enum$LanguageOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$LanguageOrderField fromJson$Enum$LanguageOrderField(String value) {
  switch (value) {
    case r'SIZE':
      return Enum$LanguageOrderField.SIZE;
    default:
      return Enum$LanguageOrderField.$unknown;
  }
}

enum Enum$LockReason { OFF_TOPIC, RESOLVED, SPAM, TOO_HEATED, $unknown }

String toJson$Enum$LockReason(Enum$LockReason e) {
  switch (e) {
    case Enum$LockReason.OFF_TOPIC:
      return r'OFF_TOPIC';
    case Enum$LockReason.RESOLVED:
      return r'RESOLVED';
    case Enum$LockReason.SPAM:
      return r'SPAM';
    case Enum$LockReason.TOO_HEATED:
      return r'TOO_HEATED';
    case Enum$LockReason.$unknown:
      return r'$unknown';
  }
}

Enum$LockReason fromJson$Enum$LockReason(String value) {
  switch (value) {
    case r'OFF_TOPIC':
      return Enum$LockReason.OFF_TOPIC;
    case r'RESOLVED':
      return Enum$LockReason.RESOLVED;
    case r'SPAM':
      return Enum$LockReason.SPAM;
    case r'TOO_HEATED':
      return Enum$LockReason.TOO_HEATED;
    default:
      return Enum$LockReason.$unknown;
  }
}

enum Enum$MannequinOrderField { CREATED_AT, LOGIN, $unknown }

String toJson$Enum$MannequinOrderField(Enum$MannequinOrderField e) {
  switch (e) {
    case Enum$MannequinOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$MannequinOrderField.LOGIN:
      return r'LOGIN';
    case Enum$MannequinOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$MannequinOrderField fromJson$Enum$MannequinOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$MannequinOrderField.CREATED_AT;
    case r'LOGIN':
      return Enum$MannequinOrderField.LOGIN;
    default:
      return Enum$MannequinOrderField.$unknown;
  }
}

enum Enum$MergeCommitMessage { BLANK, PR_BODY, PR_TITLE, $unknown }

String toJson$Enum$MergeCommitMessage(Enum$MergeCommitMessage e) {
  switch (e) {
    case Enum$MergeCommitMessage.BLANK:
      return r'BLANK';
    case Enum$MergeCommitMessage.PR_BODY:
      return r'PR_BODY';
    case Enum$MergeCommitMessage.PR_TITLE:
      return r'PR_TITLE';
    case Enum$MergeCommitMessage.$unknown:
      return r'$unknown';
  }
}

Enum$MergeCommitMessage fromJson$Enum$MergeCommitMessage(String value) {
  switch (value) {
    case r'BLANK':
      return Enum$MergeCommitMessage.BLANK;
    case r'PR_BODY':
      return Enum$MergeCommitMessage.PR_BODY;
    case r'PR_TITLE':
      return Enum$MergeCommitMessage.PR_TITLE;
    default:
      return Enum$MergeCommitMessage.$unknown;
  }
}

enum Enum$MergeCommitTitle { MERGE_MESSAGE, PR_TITLE, $unknown }

String toJson$Enum$MergeCommitTitle(Enum$MergeCommitTitle e) {
  switch (e) {
    case Enum$MergeCommitTitle.MERGE_MESSAGE:
      return r'MERGE_MESSAGE';
    case Enum$MergeCommitTitle.PR_TITLE:
      return r'PR_TITLE';
    case Enum$MergeCommitTitle.$unknown:
      return r'$unknown';
  }
}

Enum$MergeCommitTitle fromJson$Enum$MergeCommitTitle(String value) {
  switch (value) {
    case r'MERGE_MESSAGE':
      return Enum$MergeCommitTitle.MERGE_MESSAGE;
    case r'PR_TITLE':
      return Enum$MergeCommitTitle.PR_TITLE;
    default:
      return Enum$MergeCommitTitle.$unknown;
  }
}

enum Enum$MergeStateStatus {
  BEHIND,
  BLOCKED,
  CLEAN,
  DIRTY,
  DRAFT,
  HAS_HOOKS,
  UNKNOWN,
  UNSTABLE,
  $unknown
}

String toJson$Enum$MergeStateStatus(Enum$MergeStateStatus e) {
  switch (e) {
    case Enum$MergeStateStatus.BEHIND:
      return r'BEHIND';
    case Enum$MergeStateStatus.BLOCKED:
      return r'BLOCKED';
    case Enum$MergeStateStatus.CLEAN:
      return r'CLEAN';
    case Enum$MergeStateStatus.DIRTY:
      return r'DIRTY';
    case Enum$MergeStateStatus.DRAFT:
      return r'DRAFT';
    case Enum$MergeStateStatus.HAS_HOOKS:
      return r'HAS_HOOKS';
    case Enum$MergeStateStatus.UNKNOWN:
      return r'UNKNOWN';
    case Enum$MergeStateStatus.UNSTABLE:
      return r'UNSTABLE';
    case Enum$MergeStateStatus.$unknown:
      return r'$unknown';
  }
}

Enum$MergeStateStatus fromJson$Enum$MergeStateStatus(String value) {
  switch (value) {
    case r'BEHIND':
      return Enum$MergeStateStatus.BEHIND;
    case r'BLOCKED':
      return Enum$MergeStateStatus.BLOCKED;
    case r'CLEAN':
      return Enum$MergeStateStatus.CLEAN;
    case r'DIRTY':
      return Enum$MergeStateStatus.DIRTY;
    case r'DRAFT':
      return Enum$MergeStateStatus.DRAFT;
    case r'HAS_HOOKS':
      return Enum$MergeStateStatus.HAS_HOOKS;
    case r'UNKNOWN':
      return Enum$MergeStateStatus.UNKNOWN;
    case r'UNSTABLE':
      return Enum$MergeStateStatus.UNSTABLE;
    default:
      return Enum$MergeStateStatus.$unknown;
  }
}

enum Enum$MergeableState { CONFLICTING, MERGEABLE, UNKNOWN, $unknown }

String toJson$Enum$MergeableState(Enum$MergeableState e) {
  switch (e) {
    case Enum$MergeableState.CONFLICTING:
      return r'CONFLICTING';
    case Enum$MergeableState.MERGEABLE:
      return r'MERGEABLE';
    case Enum$MergeableState.UNKNOWN:
      return r'UNKNOWN';
    case Enum$MergeableState.$unknown:
      return r'$unknown';
  }
}

Enum$MergeableState fromJson$Enum$MergeableState(String value) {
  switch (value) {
    case r'CONFLICTING':
      return Enum$MergeableState.CONFLICTING;
    case r'MERGEABLE':
      return Enum$MergeableState.MERGEABLE;
    case r'UNKNOWN':
      return Enum$MergeableState.UNKNOWN;
    default:
      return Enum$MergeableState.$unknown;
  }
}

enum Enum$MigrationSourceType {
  AZURE_DEVOPS,
  BITBUCKET_SERVER,
  GITHUB_ARCHIVE,
  $unknown
}

String toJson$Enum$MigrationSourceType(Enum$MigrationSourceType e) {
  switch (e) {
    case Enum$MigrationSourceType.AZURE_DEVOPS:
      return r'AZURE_DEVOPS';
    case Enum$MigrationSourceType.BITBUCKET_SERVER:
      return r'BITBUCKET_SERVER';
    case Enum$MigrationSourceType.GITHUB_ARCHIVE:
      return r'GITHUB_ARCHIVE';
    case Enum$MigrationSourceType.$unknown:
      return r'$unknown';
  }
}

Enum$MigrationSourceType fromJson$Enum$MigrationSourceType(String value) {
  switch (value) {
    case r'AZURE_DEVOPS':
      return Enum$MigrationSourceType.AZURE_DEVOPS;
    case r'BITBUCKET_SERVER':
      return Enum$MigrationSourceType.BITBUCKET_SERVER;
    case r'GITHUB_ARCHIVE':
      return Enum$MigrationSourceType.GITHUB_ARCHIVE;
    default:
      return Enum$MigrationSourceType.$unknown;
  }
}

enum Enum$MigrationState {
  FAILED,
  FAILED_VALIDATION,
  IN_PROGRESS,
  NOT_STARTED,
  PENDING_VALIDATION,
  QUEUED,
  SUCCEEDED,
  $unknown
}

String toJson$Enum$MigrationState(Enum$MigrationState e) {
  switch (e) {
    case Enum$MigrationState.FAILED:
      return r'FAILED';
    case Enum$MigrationState.FAILED_VALIDATION:
      return r'FAILED_VALIDATION';
    case Enum$MigrationState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$MigrationState.NOT_STARTED:
      return r'NOT_STARTED';
    case Enum$MigrationState.PENDING_VALIDATION:
      return r'PENDING_VALIDATION';
    case Enum$MigrationState.QUEUED:
      return r'QUEUED';
    case Enum$MigrationState.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$MigrationState.$unknown:
      return r'$unknown';
  }
}

Enum$MigrationState fromJson$Enum$MigrationState(String value) {
  switch (value) {
    case r'FAILED':
      return Enum$MigrationState.FAILED;
    case r'FAILED_VALIDATION':
      return Enum$MigrationState.FAILED_VALIDATION;
    case r'IN_PROGRESS':
      return Enum$MigrationState.IN_PROGRESS;
    case r'NOT_STARTED':
      return Enum$MigrationState.NOT_STARTED;
    case r'PENDING_VALIDATION':
      return Enum$MigrationState.PENDING_VALIDATION;
    case r'QUEUED':
      return Enum$MigrationState.QUEUED;
    case r'SUCCEEDED':
      return Enum$MigrationState.SUCCEEDED;
    default:
      return Enum$MigrationState.$unknown;
  }
}

enum Enum$MilestoneOrderField {
  CREATED_AT,
  DUE_DATE,
  NUMBER,
  UPDATED_AT,
  $unknown
}

String toJson$Enum$MilestoneOrderField(Enum$MilestoneOrderField e) {
  switch (e) {
    case Enum$MilestoneOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$MilestoneOrderField.DUE_DATE:
      return r'DUE_DATE';
    case Enum$MilestoneOrderField.NUMBER:
      return r'NUMBER';
    case Enum$MilestoneOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$MilestoneOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneOrderField fromJson$Enum$MilestoneOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$MilestoneOrderField.CREATED_AT;
    case r'DUE_DATE':
      return Enum$MilestoneOrderField.DUE_DATE;
    case r'NUMBER':
      return Enum$MilestoneOrderField.NUMBER;
    case r'UPDATED_AT':
      return Enum$MilestoneOrderField.UPDATED_AT;
    default:
      return Enum$MilestoneOrderField.$unknown;
  }
}

enum Enum$MilestoneState { CLOSED, OPEN, $unknown }

String toJson$Enum$MilestoneState(Enum$MilestoneState e) {
  switch (e) {
    case Enum$MilestoneState.CLOSED:
      return r'CLOSED';
    case Enum$MilestoneState.OPEN:
      return r'OPEN';
    case Enum$MilestoneState.$unknown:
      return r'$unknown';
  }
}

Enum$MilestoneState fromJson$Enum$MilestoneState(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$MilestoneState.CLOSED;
    case r'OPEN':
      return Enum$MilestoneState.OPEN;
    default:
      return Enum$MilestoneState.$unknown;
  }
}

enum Enum$NotificationRestrictionSettingValue { DISABLED, ENABLED, $unknown }

String toJson$Enum$NotificationRestrictionSettingValue(
    Enum$NotificationRestrictionSettingValue e) {
  switch (e) {
    case Enum$NotificationRestrictionSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$NotificationRestrictionSettingValue.ENABLED:
      return r'ENABLED';
    case Enum$NotificationRestrictionSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$NotificationRestrictionSettingValue
    fromJson$Enum$NotificationRestrictionSettingValue(String value) {
  switch (value) {
    case r'DISABLED':
      return Enum$NotificationRestrictionSettingValue.DISABLED;
    case r'ENABLED':
      return Enum$NotificationRestrictionSettingValue.ENABLED;
    default:
      return Enum$NotificationRestrictionSettingValue.$unknown;
  }
}

enum Enum$OIDCProviderType { AAD, $unknown }

String toJson$Enum$OIDCProviderType(Enum$OIDCProviderType e) {
  switch (e) {
    case Enum$OIDCProviderType.AAD:
      return r'AAD';
    case Enum$OIDCProviderType.$unknown:
      return r'$unknown';
  }
}

Enum$OIDCProviderType fromJson$Enum$OIDCProviderType(String value) {
  switch (value) {
    case r'AAD':
      return Enum$OIDCProviderType.AAD;
    default:
      return Enum$OIDCProviderType.$unknown;
  }
}

enum Enum$OauthApplicationCreateAuditEntryState {
  ACTIVE,
  PENDING_DELETION,
  SUSPENDED,
  $unknown
}

String toJson$Enum$OauthApplicationCreateAuditEntryState(
    Enum$OauthApplicationCreateAuditEntryState e) {
  switch (e) {
    case Enum$OauthApplicationCreateAuditEntryState.ACTIVE:
      return r'ACTIVE';
    case Enum$OauthApplicationCreateAuditEntryState.PENDING_DELETION:
      return r'PENDING_DELETION';
    case Enum$OauthApplicationCreateAuditEntryState.SUSPENDED:
      return r'SUSPENDED';
    case Enum$OauthApplicationCreateAuditEntryState.$unknown:
      return r'$unknown';
  }
}

Enum$OauthApplicationCreateAuditEntryState
    fromJson$Enum$OauthApplicationCreateAuditEntryState(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$OauthApplicationCreateAuditEntryState.ACTIVE;
    case r'PENDING_DELETION':
      return Enum$OauthApplicationCreateAuditEntryState.PENDING_DELETION;
    case r'SUSPENDED':
      return Enum$OauthApplicationCreateAuditEntryState.SUSPENDED;
    default:
      return Enum$OauthApplicationCreateAuditEntryState.$unknown;
  }
}

enum Enum$OperationType {
  ACCESS,
  AUTHENTICATION,
  CREATE,
  MODIFY,
  REMOVE,
  RESTORE,
  TRANSFER,
  $unknown
}

String toJson$Enum$OperationType(Enum$OperationType e) {
  switch (e) {
    case Enum$OperationType.ACCESS:
      return r'ACCESS';
    case Enum$OperationType.AUTHENTICATION:
      return r'AUTHENTICATION';
    case Enum$OperationType.CREATE:
      return r'CREATE';
    case Enum$OperationType.MODIFY:
      return r'MODIFY';
    case Enum$OperationType.REMOVE:
      return r'REMOVE';
    case Enum$OperationType.RESTORE:
      return r'RESTORE';
    case Enum$OperationType.TRANSFER:
      return r'TRANSFER';
    case Enum$OperationType.$unknown:
      return r'$unknown';
  }
}

Enum$OperationType fromJson$Enum$OperationType(String value) {
  switch (value) {
    case r'ACCESS':
      return Enum$OperationType.ACCESS;
    case r'AUTHENTICATION':
      return Enum$OperationType.AUTHENTICATION;
    case r'CREATE':
      return Enum$OperationType.CREATE;
    case r'MODIFY':
      return Enum$OperationType.MODIFY;
    case r'REMOVE':
      return Enum$OperationType.REMOVE;
    case r'RESTORE':
      return Enum$OperationType.RESTORE;
    case r'TRANSFER':
      return Enum$OperationType.TRANSFER;
    default:
      return Enum$OperationType.$unknown;
  }
}

enum Enum$OrderDirection { ASC, DESC, $unknown }

String toJson$Enum$OrderDirection(Enum$OrderDirection e) {
  switch (e) {
    case Enum$OrderDirection.ASC:
      return r'ASC';
    case Enum$OrderDirection.DESC:
      return r'DESC';
    case Enum$OrderDirection.$unknown:
      return r'$unknown';
  }
}

Enum$OrderDirection fromJson$Enum$OrderDirection(String value) {
  switch (value) {
    case r'ASC':
      return Enum$OrderDirection.ASC;
    case r'DESC':
      return Enum$OrderDirection.DESC;
    default:
      return Enum$OrderDirection.$unknown;
  }
}

enum Enum$OrgAddMemberAuditEntryPermission { ADMIN, READ, $unknown }

String toJson$Enum$OrgAddMemberAuditEntryPermission(
    Enum$OrgAddMemberAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgAddMemberAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgAddMemberAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgAddMemberAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgAddMemberAuditEntryPermission
    fromJson$Enum$OrgAddMemberAuditEntryPermission(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$OrgAddMemberAuditEntryPermission.ADMIN;
    case r'READ':
      return Enum$OrgAddMemberAuditEntryPermission.READ;
    default:
      return Enum$OrgAddMemberAuditEntryPermission.$unknown;
  }
}

enum Enum$OrgCreateAuditEntryBillingPlan {
  BUSINESS,
  BUSINESS_PLUS,
  FREE,
  TIERED_PER_SEAT,
  UNLIMITED,
  $unknown
}

String toJson$Enum$OrgCreateAuditEntryBillingPlan(
    Enum$OrgCreateAuditEntryBillingPlan e) {
  switch (e) {
    case Enum$OrgCreateAuditEntryBillingPlan.BUSINESS:
      return r'BUSINESS';
    case Enum$OrgCreateAuditEntryBillingPlan.BUSINESS_PLUS:
      return r'BUSINESS_PLUS';
    case Enum$OrgCreateAuditEntryBillingPlan.FREE:
      return r'FREE';
    case Enum$OrgCreateAuditEntryBillingPlan.TIERED_PER_SEAT:
      return r'TIERED_PER_SEAT';
    case Enum$OrgCreateAuditEntryBillingPlan.UNLIMITED:
      return r'UNLIMITED';
    case Enum$OrgCreateAuditEntryBillingPlan.$unknown:
      return r'$unknown';
  }
}

Enum$OrgCreateAuditEntryBillingPlan
    fromJson$Enum$OrgCreateAuditEntryBillingPlan(String value) {
  switch (value) {
    case r'BUSINESS':
      return Enum$OrgCreateAuditEntryBillingPlan.BUSINESS;
    case r'BUSINESS_PLUS':
      return Enum$OrgCreateAuditEntryBillingPlan.BUSINESS_PLUS;
    case r'FREE':
      return Enum$OrgCreateAuditEntryBillingPlan.FREE;
    case r'TIERED_PER_SEAT':
      return Enum$OrgCreateAuditEntryBillingPlan.TIERED_PER_SEAT;
    case r'UNLIMITED':
      return Enum$OrgCreateAuditEntryBillingPlan.UNLIMITED;
    default:
      return Enum$OrgCreateAuditEntryBillingPlan.$unknown;
  }
}

enum Enum$OrgEnterpriseOwnerOrderField { LOGIN, $unknown }

String toJson$Enum$OrgEnterpriseOwnerOrderField(
    Enum$OrgEnterpriseOwnerOrderField e) {
  switch (e) {
    case Enum$OrgEnterpriseOwnerOrderField.LOGIN:
      return r'LOGIN';
    case Enum$OrgEnterpriseOwnerOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$OrgEnterpriseOwnerOrderField fromJson$Enum$OrgEnterpriseOwnerOrderField(
    String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$OrgEnterpriseOwnerOrderField.LOGIN;
    default:
      return Enum$OrgEnterpriseOwnerOrderField.$unknown;
  }
}

enum Enum$OrgRemoveBillingManagerAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING,
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY,
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  $unknown
}

String toJson$Enum$OrgRemoveBillingManagerAuditEntryReason(
    Enum$OrgRemoveBillingManagerAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveBillingManagerAuditEntryReason
        .SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveBillingManagerAuditEntryReason
        .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY:
      return r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY';
    case Enum$OrgRemoveBillingManagerAuditEntryReason
        .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveBillingManagerAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveBillingManagerAuditEntryReason
    fromJson$Enum$OrgRemoveBillingManagerAuditEntryReason(String value) {
  switch (value) {
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    case r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY;
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveBillingManagerAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    default:
      return Enum$OrgRemoveBillingManagerAuditEntryReason.$unknown;
  }
}

enum Enum$OrgRemoveMemberAuditEntryMembershipType {
  ADMIN,
  BILLING_MANAGER,
  DIRECT_MEMBER,
  OUTSIDE_COLLABORATOR,
  SUSPENDED,
  UNAFFILIATED,
  $unknown
}

String toJson$Enum$OrgRemoveMemberAuditEntryMembershipType(
    Enum$OrgRemoveMemberAuditEntryMembershipType e) {
  switch (e) {
    case Enum$OrgRemoveMemberAuditEntryMembershipType.ADMIN:
      return r'ADMIN';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.OUTSIDE_COLLABORATOR:
      return r'OUTSIDE_COLLABORATOR';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.SUSPENDED:
      return r'SUSPENDED';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$OrgRemoveMemberAuditEntryMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveMemberAuditEntryMembershipType
    fromJson$Enum$OrgRemoveMemberAuditEntryMembershipType(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.ADMIN;
    case r'BILLING_MANAGER':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.BILLING_MANAGER;
    case r'DIRECT_MEMBER':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.DIRECT_MEMBER;
    case r'OUTSIDE_COLLABORATOR':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.OUTSIDE_COLLABORATOR;
    case r'SUSPENDED':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.SUSPENDED;
    case r'UNAFFILIATED':
      return Enum$OrgRemoveMemberAuditEntryMembershipType.UNAFFILIATED;
    default:
      return Enum$OrgRemoveMemberAuditEntryMembershipType.$unknown;
  }
}

enum Enum$OrgRemoveMemberAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING,
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY,
  TWO_FACTOR_ACCOUNT_RECOVERY,
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  USER_ACCOUNT_DELETED,
  $unknown
}

String toJson$Enum$OrgRemoveMemberAuditEntryReason(
    Enum$OrgRemoveMemberAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveMemberAuditEntryReason.SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveMemberAuditEntryReason
        .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY:
      return r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY';
    case Enum$OrgRemoveMemberAuditEntryReason.TWO_FACTOR_ACCOUNT_RECOVERY:
      return r'TWO_FACTOR_ACCOUNT_RECOVERY';
    case Enum$OrgRemoveMemberAuditEntryReason
        .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveMemberAuditEntryReason.USER_ACCOUNT_DELETED:
      return r'USER_ACCOUNT_DELETED';
    case Enum$OrgRemoveMemberAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveMemberAuditEntryReason
    fromJson$Enum$OrgRemoveMemberAuditEntryReason(String value) {
  switch (value) {
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveMemberAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    case r'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY':
      return Enum$OrgRemoveMemberAuditEntryReason
          .SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY;
    case r'TWO_FACTOR_ACCOUNT_RECOVERY':
      return Enum$OrgRemoveMemberAuditEntryReason.TWO_FACTOR_ACCOUNT_RECOVERY;
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveMemberAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    case r'USER_ACCOUNT_DELETED':
      return Enum$OrgRemoveMemberAuditEntryReason.USER_ACCOUNT_DELETED;
    default:
      return Enum$OrgRemoveMemberAuditEntryReason.$unknown;
  }
}

enum Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  BILLING_MANAGER,
  OUTSIDE_COLLABORATOR,
  UNAFFILIATED,
  $unknown
}

String toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(
    Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType e) {
  switch (e) {
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
        .BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
        .OUTSIDE_COLLABORATOR:
      return r'OUTSIDE_COLLABORATOR';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
    fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType(
        String value) {
  switch (value) {
    case r'BILLING_MANAGER':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .BILLING_MANAGER;
    case r'OUTSIDE_COLLABORATOR':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .OUTSIDE_COLLABORATOR;
    case r'UNAFFILIATED':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType
          .UNAFFILIATED;
    default:
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryMembershipType.$unknown;
  }
}

enum Enum$OrgRemoveOutsideCollaboratorAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING,
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE,
  $unknown
}

String toJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(
    Enum$OrgRemoveOutsideCollaboratorAuditEntryReason e) {
  switch (e) {
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
        .SAML_EXTERNAL_IDENTITY_MISSING:
      return r'SAML_EXTERNAL_IDENTITY_MISSING';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
        .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE:
      return r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE';
    case Enum$OrgRemoveOutsideCollaboratorAuditEntryReason.$unknown:
      return r'$unknown';
  }
}

Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
    fromJson$Enum$OrgRemoveOutsideCollaboratorAuditEntryReason(String value) {
  switch (value) {
    case r'SAML_EXTERNAL_IDENTITY_MISSING':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .SAML_EXTERNAL_IDENTITY_MISSING;
    case r'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE':
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason
          .TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE;
    default:
      return Enum$OrgRemoveOutsideCollaboratorAuditEntryReason.$unknown;
  }
}

enum Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  ADMIN,
  NONE,
  READ,
  WRITE,
  $unknown
}

String toJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
    Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.NONE:
      return r'NONE';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.WRITE:
      return r'WRITE';
    case Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
    fromJson$Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission(
        String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .ADMIN;
    case r'NONE':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.NONE;
    case r'READ':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission.READ;
    case r'WRITE':
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .WRITE;
    default:
      return Enum$OrgUpdateDefaultRepositoryPermissionAuditEntryPermission
          .$unknown;
  }
}

enum Enum$OrgUpdateMemberAuditEntryPermission { ADMIN, READ, $unknown }

String toJson$Enum$OrgUpdateMemberAuditEntryPermission(
    Enum$OrgUpdateMemberAuditEntryPermission e) {
  switch (e) {
    case Enum$OrgUpdateMemberAuditEntryPermission.ADMIN:
      return r'ADMIN';
    case Enum$OrgUpdateMemberAuditEntryPermission.READ:
      return r'READ';
    case Enum$OrgUpdateMemberAuditEntryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateMemberAuditEntryPermission
    fromJson$Enum$OrgUpdateMemberAuditEntryPermission(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$OrgUpdateMemberAuditEntryPermission.ADMIN;
    case r'READ':
      return Enum$OrgUpdateMemberAuditEntryPermission.READ;
    default:
      return Enum$OrgUpdateMemberAuditEntryPermission.$unknown;
  }
}

enum Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  ALL,
  INTERNAL,
  NONE,
  PRIVATE,
  PRIVATE_INTERNAL,
  PUBLIC,
  PUBLIC_INTERNAL,
  PUBLIC_PRIVATE,
  $unknown
}

String
    toJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
        Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
            e) {
  switch (e) {
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .ALL:
      return r'ALL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .INTERNAL:
      return r'INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .NONE:
      return r'NONE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PRIVATE:
      return r'PRIVATE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PRIVATE_INTERNAL:
      return r'PRIVATE_INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PUBLIC:
      return r'PUBLIC';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PUBLIC_INTERNAL:
      return r'PUBLIC_INTERNAL';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .PUBLIC_PRIVATE:
      return r'PUBLIC_PRIVATE';
    case Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
        .$unknown:
      return r'$unknown';
  }
}

Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
    fromJson$Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility(
        String value) {
  switch (value) {
    case r'ALL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .ALL;
    case r'INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .INTERNAL;
    case r'NONE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .NONE;
    case r'PRIVATE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE;
    case r'PRIVATE_INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PRIVATE_INTERNAL;
    case r'PUBLIC':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC;
    case r'PUBLIC_INTERNAL':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_INTERNAL;
    case r'PUBLIC_PRIVATE':
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .PUBLIC_PRIVATE;
    default:
      return Enum$OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility
          .$unknown;
  }
}

enum Enum$OrganizationInvitationRole {
  ADMIN,
  BILLING_MANAGER,
  DIRECT_MEMBER,
  REINSTATE,
  $unknown
}

String toJson$Enum$OrganizationInvitationRole(
    Enum$OrganizationInvitationRole e) {
  switch (e) {
    case Enum$OrganizationInvitationRole.ADMIN:
      return r'ADMIN';
    case Enum$OrganizationInvitationRole.BILLING_MANAGER:
      return r'BILLING_MANAGER';
    case Enum$OrganizationInvitationRole.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$OrganizationInvitationRole.REINSTATE:
      return r'REINSTATE';
    case Enum$OrganizationInvitationRole.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationRole fromJson$Enum$OrganizationInvitationRole(
    String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$OrganizationInvitationRole.ADMIN;
    case r'BILLING_MANAGER':
      return Enum$OrganizationInvitationRole.BILLING_MANAGER;
    case r'DIRECT_MEMBER':
      return Enum$OrganizationInvitationRole.DIRECT_MEMBER;
    case r'REINSTATE':
      return Enum$OrganizationInvitationRole.REINSTATE;
    default:
      return Enum$OrganizationInvitationRole.$unknown;
  }
}

enum Enum$OrganizationInvitationSource { MEMBER, SCIM, UNKNOWN, $unknown }

String toJson$Enum$OrganizationInvitationSource(
    Enum$OrganizationInvitationSource e) {
  switch (e) {
    case Enum$OrganizationInvitationSource.MEMBER:
      return r'MEMBER';
    case Enum$OrganizationInvitationSource.SCIM:
      return r'SCIM';
    case Enum$OrganizationInvitationSource.UNKNOWN:
      return r'UNKNOWN';
    case Enum$OrganizationInvitationSource.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationSource fromJson$Enum$OrganizationInvitationSource(
    String value) {
  switch (value) {
    case r'MEMBER':
      return Enum$OrganizationInvitationSource.MEMBER;
    case r'SCIM':
      return Enum$OrganizationInvitationSource.SCIM;
    case r'UNKNOWN':
      return Enum$OrganizationInvitationSource.UNKNOWN;
    default:
      return Enum$OrganizationInvitationSource.$unknown;
  }
}

enum Enum$OrganizationInvitationType { EMAIL, USER, $unknown }

String toJson$Enum$OrganizationInvitationType(
    Enum$OrganizationInvitationType e) {
  switch (e) {
    case Enum$OrganizationInvitationType.EMAIL:
      return r'EMAIL';
    case Enum$OrganizationInvitationType.USER:
      return r'USER';
    case Enum$OrganizationInvitationType.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationInvitationType fromJson$Enum$OrganizationInvitationType(
    String value) {
  switch (value) {
    case r'EMAIL':
      return Enum$OrganizationInvitationType.EMAIL;
    case r'USER':
      return Enum$OrganizationInvitationType.USER;
    default:
      return Enum$OrganizationInvitationType.$unknown;
  }
}

enum Enum$OrganizationMemberRole { ADMIN, MEMBER, $unknown }

String toJson$Enum$OrganizationMemberRole(Enum$OrganizationMemberRole e) {
  switch (e) {
    case Enum$OrganizationMemberRole.ADMIN:
      return r'ADMIN';
    case Enum$OrganizationMemberRole.MEMBER:
      return r'MEMBER';
    case Enum$OrganizationMemberRole.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMemberRole fromJson$Enum$OrganizationMemberRole(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$OrganizationMemberRole.ADMIN;
    case r'MEMBER':
      return Enum$OrganizationMemberRole.MEMBER;
    default:
      return Enum$OrganizationMemberRole.$unknown;
  }
}

enum Enum$OrganizationMembersCanCreateRepositoriesSettingValue {
  ALL,
  DISABLED,
  INTERNAL,
  PRIVATE,
  $unknown
}

String toJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(
    Enum$OrganizationMembersCanCreateRepositoriesSettingValue e) {
  switch (e) {
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.ALL:
      return r'ALL';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.DISABLED:
      return r'DISABLED';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.INTERNAL:
      return r'INTERNAL';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.PRIVATE:
      return r'PRIVATE';
    case Enum$OrganizationMembersCanCreateRepositoriesSettingValue.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMembersCanCreateRepositoriesSettingValue
    fromJson$Enum$OrganizationMembersCanCreateRepositoriesSettingValue(
        String value) {
  switch (value) {
    case r'ALL':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.ALL;
    case r'DISABLED':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.DISABLED;
    case r'INTERNAL':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.INTERNAL;
    case r'PRIVATE':
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.PRIVATE;
    default:
      return Enum$OrganizationMembersCanCreateRepositoriesSettingValue.$unknown;
  }
}

enum Enum$OrganizationMigrationState {
  FAILED,
  IN_PROGRESS,
  NOT_STARTED,
  POST_REPO_MIGRATION,
  PRE_REPO_MIGRATION,
  QUEUED,
  REPO_MIGRATION,
  SUCCEEDED,
  $unknown
}

String toJson$Enum$OrganizationMigrationState(
    Enum$OrganizationMigrationState e) {
  switch (e) {
    case Enum$OrganizationMigrationState.FAILED:
      return r'FAILED';
    case Enum$OrganizationMigrationState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$OrganizationMigrationState.NOT_STARTED:
      return r'NOT_STARTED';
    case Enum$OrganizationMigrationState.POST_REPO_MIGRATION:
      return r'POST_REPO_MIGRATION';
    case Enum$OrganizationMigrationState.PRE_REPO_MIGRATION:
      return r'PRE_REPO_MIGRATION';
    case Enum$OrganizationMigrationState.QUEUED:
      return r'QUEUED';
    case Enum$OrganizationMigrationState.REPO_MIGRATION:
      return r'REPO_MIGRATION';
    case Enum$OrganizationMigrationState.SUCCEEDED:
      return r'SUCCEEDED';
    case Enum$OrganizationMigrationState.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationMigrationState fromJson$Enum$OrganizationMigrationState(
    String value) {
  switch (value) {
    case r'FAILED':
      return Enum$OrganizationMigrationState.FAILED;
    case r'IN_PROGRESS':
      return Enum$OrganizationMigrationState.IN_PROGRESS;
    case r'NOT_STARTED':
      return Enum$OrganizationMigrationState.NOT_STARTED;
    case r'POST_REPO_MIGRATION':
      return Enum$OrganizationMigrationState.POST_REPO_MIGRATION;
    case r'PRE_REPO_MIGRATION':
      return Enum$OrganizationMigrationState.PRE_REPO_MIGRATION;
    case r'QUEUED':
      return Enum$OrganizationMigrationState.QUEUED;
    case r'REPO_MIGRATION':
      return Enum$OrganizationMigrationState.REPO_MIGRATION;
    case r'SUCCEEDED':
      return Enum$OrganizationMigrationState.SUCCEEDED;
    default:
      return Enum$OrganizationMigrationState.$unknown;
  }
}

enum Enum$OrganizationOrderField { CREATED_AT, LOGIN, $unknown }

String toJson$Enum$OrganizationOrderField(Enum$OrganizationOrderField e) {
  switch (e) {
    case Enum$OrganizationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$OrganizationOrderField.LOGIN:
      return r'LOGIN';
    case Enum$OrganizationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$OrganizationOrderField fromJson$Enum$OrganizationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$OrganizationOrderField.CREATED_AT;
    case r'LOGIN':
      return Enum$OrganizationOrderField.LOGIN;
    default:
      return Enum$OrganizationOrderField.$unknown;
  }
}

enum Enum$PackageFileOrderField { CREATED_AT, $unknown }

String toJson$Enum$PackageFileOrderField(Enum$PackageFileOrderField e) {
  switch (e) {
    case Enum$PackageFileOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageFileOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageFileOrderField fromJson$Enum$PackageFileOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageFileOrderField.CREATED_AT;
    default:
      return Enum$PackageFileOrderField.$unknown;
  }
}

enum Enum$PackageOrderField { CREATED_AT, $unknown }

String toJson$Enum$PackageOrderField(Enum$PackageOrderField e) {
  switch (e) {
    case Enum$PackageOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageOrderField fromJson$Enum$PackageOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageOrderField.CREATED_AT;
    default:
      return Enum$PackageOrderField.$unknown;
  }
}

enum Enum$PackageType {
  DEBIAN,
  DOCKER,
  MAVEN,
  NPM,
  NUGET,
  PYPI,
  RUBYGEMS,
  $unknown
}

String toJson$Enum$PackageType(Enum$PackageType e) {
  switch (e) {
    case Enum$PackageType.DEBIAN:
      return r'DEBIAN';
    case Enum$PackageType.DOCKER:
      return r'DOCKER';
    case Enum$PackageType.MAVEN:
      return r'MAVEN';
    case Enum$PackageType.NPM:
      return r'NPM';
    case Enum$PackageType.NUGET:
      return r'NUGET';
    case Enum$PackageType.PYPI:
      return r'PYPI';
    case Enum$PackageType.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$PackageType.$unknown:
      return r'$unknown';
  }
}

Enum$PackageType fromJson$Enum$PackageType(String value) {
  switch (value) {
    case r'DEBIAN':
      return Enum$PackageType.DEBIAN;
    case r'DOCKER':
      return Enum$PackageType.DOCKER;
    case r'MAVEN':
      return Enum$PackageType.MAVEN;
    case r'NPM':
      return Enum$PackageType.NPM;
    case r'NUGET':
      return Enum$PackageType.NUGET;
    case r'PYPI':
      return Enum$PackageType.PYPI;
    case r'RUBYGEMS':
      return Enum$PackageType.RUBYGEMS;
    default:
      return Enum$PackageType.$unknown;
  }
}

enum Enum$PackageVersionOrderField { CREATED_AT, $unknown }

String toJson$Enum$PackageVersionOrderField(Enum$PackageVersionOrderField e) {
  switch (e) {
    case Enum$PackageVersionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PackageVersionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PackageVersionOrderField fromJson$Enum$PackageVersionOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PackageVersionOrderField.CREATED_AT;
    default:
      return Enum$PackageVersionOrderField.$unknown;
  }
}

enum Enum$PatchStatus {
  ADDED,
  CHANGED,
  COPIED,
  DELETED,
  MODIFIED,
  RENAMED,
  $unknown
}

String toJson$Enum$PatchStatus(Enum$PatchStatus e) {
  switch (e) {
    case Enum$PatchStatus.ADDED:
      return r'ADDED';
    case Enum$PatchStatus.CHANGED:
      return r'CHANGED';
    case Enum$PatchStatus.COPIED:
      return r'COPIED';
    case Enum$PatchStatus.DELETED:
      return r'DELETED';
    case Enum$PatchStatus.MODIFIED:
      return r'MODIFIED';
    case Enum$PatchStatus.RENAMED:
      return r'RENAMED';
    case Enum$PatchStatus.$unknown:
      return r'$unknown';
  }
}

Enum$PatchStatus fromJson$Enum$PatchStatus(String value) {
  switch (value) {
    case r'ADDED':
      return Enum$PatchStatus.ADDED;
    case r'CHANGED':
      return Enum$PatchStatus.CHANGED;
    case r'COPIED':
      return Enum$PatchStatus.COPIED;
    case r'DELETED':
      return Enum$PatchStatus.DELETED;
    case r'MODIFIED':
      return Enum$PatchStatus.MODIFIED;
    case r'RENAMED':
      return Enum$PatchStatus.RENAMED;
    default:
      return Enum$PatchStatus.$unknown;
  }
}

enum Enum$PinnableItemType {
  GIST,
  ISSUE,
  ORGANIZATION,
  PROJECT,
  PULL_REQUEST,
  REPOSITORY,
  TEAM,
  USER,
  $unknown
}

String toJson$Enum$PinnableItemType(Enum$PinnableItemType e) {
  switch (e) {
    case Enum$PinnableItemType.GIST:
      return r'GIST';
    case Enum$PinnableItemType.ISSUE:
      return r'ISSUE';
    case Enum$PinnableItemType.ORGANIZATION:
      return r'ORGANIZATION';
    case Enum$PinnableItemType.PROJECT:
      return r'PROJECT';
    case Enum$PinnableItemType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$PinnableItemType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$PinnableItemType.TEAM:
      return r'TEAM';
    case Enum$PinnableItemType.USER:
      return r'USER';
    case Enum$PinnableItemType.$unknown:
      return r'$unknown';
  }
}

Enum$PinnableItemType fromJson$Enum$PinnableItemType(String value) {
  switch (value) {
    case r'GIST':
      return Enum$PinnableItemType.GIST;
    case r'ISSUE':
      return Enum$PinnableItemType.ISSUE;
    case r'ORGANIZATION':
      return Enum$PinnableItemType.ORGANIZATION;
    case r'PROJECT':
      return Enum$PinnableItemType.PROJECT;
    case r'PULL_REQUEST':
      return Enum$PinnableItemType.PULL_REQUEST;
    case r'REPOSITORY':
      return Enum$PinnableItemType.REPOSITORY;
    case r'TEAM':
      return Enum$PinnableItemType.TEAM;
    case r'USER':
      return Enum$PinnableItemType.USER;
    default:
      return Enum$PinnableItemType.$unknown;
  }
}

enum Enum$PinnedDiscussionGradient {
  BLUE_MINT,
  BLUE_PURPLE,
  PINK_BLUE,
  PURPLE_CORAL,
  RED_ORANGE,
  $unknown
}

String toJson$Enum$PinnedDiscussionGradient(Enum$PinnedDiscussionGradient e) {
  switch (e) {
    case Enum$PinnedDiscussionGradient.BLUE_MINT:
      return r'BLUE_MINT';
    case Enum$PinnedDiscussionGradient.BLUE_PURPLE:
      return r'BLUE_PURPLE';
    case Enum$PinnedDiscussionGradient.PINK_BLUE:
      return r'PINK_BLUE';
    case Enum$PinnedDiscussionGradient.PURPLE_CORAL:
      return r'PURPLE_CORAL';
    case Enum$PinnedDiscussionGradient.RED_ORANGE:
      return r'RED_ORANGE';
    case Enum$PinnedDiscussionGradient.$unknown:
      return r'$unknown';
  }
}

Enum$PinnedDiscussionGradient fromJson$Enum$PinnedDiscussionGradient(
    String value) {
  switch (value) {
    case r'BLUE_MINT':
      return Enum$PinnedDiscussionGradient.BLUE_MINT;
    case r'BLUE_PURPLE':
      return Enum$PinnedDiscussionGradient.BLUE_PURPLE;
    case r'PINK_BLUE':
      return Enum$PinnedDiscussionGradient.PINK_BLUE;
    case r'PURPLE_CORAL':
      return Enum$PinnedDiscussionGradient.PURPLE_CORAL;
    case r'RED_ORANGE':
      return Enum$PinnedDiscussionGradient.RED_ORANGE;
    default:
      return Enum$PinnedDiscussionGradient.$unknown;
  }
}

enum Enum$PinnedDiscussionPattern {
  CHEVRON_UP,
  DOT,
  DOT_FILL,
  HEART_FILL,
  PLUS,
  ZAP,
  $unknown
}

String toJson$Enum$PinnedDiscussionPattern(Enum$PinnedDiscussionPattern e) {
  switch (e) {
    case Enum$PinnedDiscussionPattern.CHEVRON_UP:
      return r'CHEVRON_UP';
    case Enum$PinnedDiscussionPattern.DOT:
      return r'DOT';
    case Enum$PinnedDiscussionPattern.DOT_FILL:
      return r'DOT_FILL';
    case Enum$PinnedDiscussionPattern.HEART_FILL:
      return r'HEART_FILL';
    case Enum$PinnedDiscussionPattern.PLUS:
      return r'PLUS';
    case Enum$PinnedDiscussionPattern.ZAP:
      return r'ZAP';
    case Enum$PinnedDiscussionPattern.$unknown:
      return r'$unknown';
  }
}

Enum$PinnedDiscussionPattern fromJson$Enum$PinnedDiscussionPattern(
    String value) {
  switch (value) {
    case r'CHEVRON_UP':
      return Enum$PinnedDiscussionPattern.CHEVRON_UP;
    case r'DOT':
      return Enum$PinnedDiscussionPattern.DOT;
    case r'DOT_FILL':
      return Enum$PinnedDiscussionPattern.DOT_FILL;
    case r'HEART_FILL':
      return Enum$PinnedDiscussionPattern.HEART_FILL;
    case r'PLUS':
      return Enum$PinnedDiscussionPattern.PLUS;
    case r'ZAP':
      return Enum$PinnedDiscussionPattern.ZAP;
    default:
      return Enum$PinnedDiscussionPattern.$unknown;
  }
}

enum Enum$ProjectCardArchivedState { ARCHIVED, NOT_ARCHIVED, $unknown }

String toJson$Enum$ProjectCardArchivedState(Enum$ProjectCardArchivedState e) {
  switch (e) {
    case Enum$ProjectCardArchivedState.ARCHIVED:
      return r'ARCHIVED';
    case Enum$ProjectCardArchivedState.NOT_ARCHIVED:
      return r'NOT_ARCHIVED';
    case Enum$ProjectCardArchivedState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectCardArchivedState fromJson$Enum$ProjectCardArchivedState(
    String value) {
  switch (value) {
    case r'ARCHIVED':
      return Enum$ProjectCardArchivedState.ARCHIVED;
    case r'NOT_ARCHIVED':
      return Enum$ProjectCardArchivedState.NOT_ARCHIVED;
    default:
      return Enum$ProjectCardArchivedState.$unknown;
  }
}

enum Enum$ProjectCardState { CONTENT_ONLY, NOTE_ONLY, REDACTED, $unknown }

String toJson$Enum$ProjectCardState(Enum$ProjectCardState e) {
  switch (e) {
    case Enum$ProjectCardState.CONTENT_ONLY:
      return r'CONTENT_ONLY';
    case Enum$ProjectCardState.NOTE_ONLY:
      return r'NOTE_ONLY';
    case Enum$ProjectCardState.REDACTED:
      return r'REDACTED';
    case Enum$ProjectCardState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectCardState fromJson$Enum$ProjectCardState(String value) {
  switch (value) {
    case r'CONTENT_ONLY':
      return Enum$ProjectCardState.CONTENT_ONLY;
    case r'NOTE_ONLY':
      return Enum$ProjectCardState.NOTE_ONLY;
    case r'REDACTED':
      return Enum$ProjectCardState.REDACTED;
    default:
      return Enum$ProjectCardState.$unknown;
  }
}

enum Enum$ProjectColumnPurpose { DONE, IN_PROGRESS, TODO, $unknown }

String toJson$Enum$ProjectColumnPurpose(Enum$ProjectColumnPurpose e) {
  switch (e) {
    case Enum$ProjectColumnPurpose.DONE:
      return r'DONE';
    case Enum$ProjectColumnPurpose.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$ProjectColumnPurpose.TODO:
      return r'TODO';
    case Enum$ProjectColumnPurpose.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectColumnPurpose fromJson$Enum$ProjectColumnPurpose(String value) {
  switch (value) {
    case r'DONE':
      return Enum$ProjectColumnPurpose.DONE;
    case r'IN_PROGRESS':
      return Enum$ProjectColumnPurpose.IN_PROGRESS;
    case r'TODO':
      return Enum$ProjectColumnPurpose.TODO;
    default:
      return Enum$ProjectColumnPurpose.$unknown;
  }
}

enum Enum$ProjectOrderField { CREATED_AT, NAME, UPDATED_AT, $unknown }

String toJson$Enum$ProjectOrderField(Enum$ProjectOrderField e) {
  switch (e) {
    case Enum$ProjectOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectOrderField.NAME:
      return r'NAME';
    case Enum$ProjectOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectOrderField fromJson$Enum$ProjectOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectOrderField.NAME;
    case r'UPDATED_AT':
      return Enum$ProjectOrderField.UPDATED_AT;
    default:
      return Enum$ProjectOrderField.$unknown;
  }
}

enum Enum$ProjectState { CLOSED, OPEN, $unknown }

String toJson$Enum$ProjectState(Enum$ProjectState e) {
  switch (e) {
    case Enum$ProjectState.CLOSED:
      return r'CLOSED';
    case Enum$ProjectState.OPEN:
      return r'OPEN';
    case Enum$ProjectState.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectState fromJson$Enum$ProjectState(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$ProjectState.CLOSED;
    case r'OPEN':
      return Enum$ProjectState.OPEN;
    default:
      return Enum$ProjectState.$unknown;
  }
}

enum Enum$ProjectTemplate {
  AUTOMATED_KANBAN_V2,
  AUTOMATED_REVIEWS_KANBAN,
  BASIC_KANBAN,
  BUG_TRIAGE,
  $unknown
}

String toJson$Enum$ProjectTemplate(Enum$ProjectTemplate e) {
  switch (e) {
    case Enum$ProjectTemplate.AUTOMATED_KANBAN_V2:
      return r'AUTOMATED_KANBAN_V2';
    case Enum$ProjectTemplate.AUTOMATED_REVIEWS_KANBAN:
      return r'AUTOMATED_REVIEWS_KANBAN';
    case Enum$ProjectTemplate.BASIC_KANBAN:
      return r'BASIC_KANBAN';
    case Enum$ProjectTemplate.BUG_TRIAGE:
      return r'BUG_TRIAGE';
    case Enum$ProjectTemplate.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectTemplate fromJson$Enum$ProjectTemplate(String value) {
  switch (value) {
    case r'AUTOMATED_KANBAN_V2':
      return Enum$ProjectTemplate.AUTOMATED_KANBAN_V2;
    case r'AUTOMATED_REVIEWS_KANBAN':
      return Enum$ProjectTemplate.AUTOMATED_REVIEWS_KANBAN;
    case r'BASIC_KANBAN':
      return Enum$ProjectTemplate.BASIC_KANBAN;
    case r'BUG_TRIAGE':
      return Enum$ProjectTemplate.BUG_TRIAGE;
    default:
      return Enum$ProjectTemplate.$unknown;
  }
}

enum Enum$ProjectV2CustomFieldType {
  DATE,
  NUMBER,
  SINGLE_SELECT,
  TEXT,
  $unknown
}

String toJson$Enum$ProjectV2CustomFieldType(Enum$ProjectV2CustomFieldType e) {
  switch (e) {
    case Enum$ProjectV2CustomFieldType.DATE:
      return r'DATE';
    case Enum$ProjectV2CustomFieldType.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2CustomFieldType.SINGLE_SELECT:
      return r'SINGLE_SELECT';
    case Enum$ProjectV2CustomFieldType.TEXT:
      return r'TEXT';
    case Enum$ProjectV2CustomFieldType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2CustomFieldType fromJson$Enum$ProjectV2CustomFieldType(
    String value) {
  switch (value) {
    case r'DATE':
      return Enum$ProjectV2CustomFieldType.DATE;
    case r'NUMBER':
      return Enum$ProjectV2CustomFieldType.NUMBER;
    case r'SINGLE_SELECT':
      return Enum$ProjectV2CustomFieldType.SINGLE_SELECT;
    case r'TEXT':
      return Enum$ProjectV2CustomFieldType.TEXT;
    default:
      return Enum$ProjectV2CustomFieldType.$unknown;
  }
}

enum Enum$ProjectV2FieldOrderField { CREATED_AT, NAME, POSITION, $unknown }

String toJson$Enum$ProjectV2FieldOrderField(Enum$ProjectV2FieldOrderField e) {
  switch (e) {
    case Enum$ProjectV2FieldOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2FieldOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2FieldOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2FieldOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2FieldOrderField fromJson$Enum$ProjectV2FieldOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectV2FieldOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectV2FieldOrderField.NAME;
    case r'POSITION':
      return Enum$ProjectV2FieldOrderField.POSITION;
    default:
      return Enum$ProjectV2FieldOrderField.$unknown;
  }
}

enum Enum$ProjectV2FieldType {
  ASSIGNEES,
  DATE,
  ITERATION,
  LABELS,
  LINKED_PULL_REQUESTS,
  MILESTONE,
  NUMBER,
  REPOSITORY,
  REVIEWERS,
  SINGLE_SELECT,
  TEXT,
  TITLE,
  TRACKED_BY,
  TRACKS,
  $unknown
}

String toJson$Enum$ProjectV2FieldType(Enum$ProjectV2FieldType e) {
  switch (e) {
    case Enum$ProjectV2FieldType.ASSIGNEES:
      return r'ASSIGNEES';
    case Enum$ProjectV2FieldType.DATE:
      return r'DATE';
    case Enum$ProjectV2FieldType.ITERATION:
      return r'ITERATION';
    case Enum$ProjectV2FieldType.LABELS:
      return r'LABELS';
    case Enum$ProjectV2FieldType.LINKED_PULL_REQUESTS:
      return r'LINKED_PULL_REQUESTS';
    case Enum$ProjectV2FieldType.MILESTONE:
      return r'MILESTONE';
    case Enum$ProjectV2FieldType.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2FieldType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$ProjectV2FieldType.REVIEWERS:
      return r'REVIEWERS';
    case Enum$ProjectV2FieldType.SINGLE_SELECT:
      return r'SINGLE_SELECT';
    case Enum$ProjectV2FieldType.TEXT:
      return r'TEXT';
    case Enum$ProjectV2FieldType.TITLE:
      return r'TITLE';
    case Enum$ProjectV2FieldType.TRACKED_BY:
      return r'TRACKED_BY';
    case Enum$ProjectV2FieldType.TRACKS:
      return r'TRACKS';
    case Enum$ProjectV2FieldType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2FieldType fromJson$Enum$ProjectV2FieldType(String value) {
  switch (value) {
    case r'ASSIGNEES':
      return Enum$ProjectV2FieldType.ASSIGNEES;
    case r'DATE':
      return Enum$ProjectV2FieldType.DATE;
    case r'ITERATION':
      return Enum$ProjectV2FieldType.ITERATION;
    case r'LABELS':
      return Enum$ProjectV2FieldType.LABELS;
    case r'LINKED_PULL_REQUESTS':
      return Enum$ProjectV2FieldType.LINKED_PULL_REQUESTS;
    case r'MILESTONE':
      return Enum$ProjectV2FieldType.MILESTONE;
    case r'NUMBER':
      return Enum$ProjectV2FieldType.NUMBER;
    case r'REPOSITORY':
      return Enum$ProjectV2FieldType.REPOSITORY;
    case r'REVIEWERS':
      return Enum$ProjectV2FieldType.REVIEWERS;
    case r'SINGLE_SELECT':
      return Enum$ProjectV2FieldType.SINGLE_SELECT;
    case r'TEXT':
      return Enum$ProjectV2FieldType.TEXT;
    case r'TITLE':
      return Enum$ProjectV2FieldType.TITLE;
    case r'TRACKED_BY':
      return Enum$ProjectV2FieldType.TRACKED_BY;
    case r'TRACKS':
      return Enum$ProjectV2FieldType.TRACKS;
    default:
      return Enum$ProjectV2FieldType.$unknown;
  }
}

enum Enum$ProjectV2ItemFieldValueOrderField { POSITION, $unknown }

String toJson$Enum$ProjectV2ItemFieldValueOrderField(
    Enum$ProjectV2ItemFieldValueOrderField e) {
  switch (e) {
    case Enum$ProjectV2ItemFieldValueOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ItemFieldValueOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemFieldValueOrderField
    fromJson$Enum$ProjectV2ItemFieldValueOrderField(String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ItemFieldValueOrderField.POSITION;
    default:
      return Enum$ProjectV2ItemFieldValueOrderField.$unknown;
  }
}

enum Enum$ProjectV2ItemOrderField { POSITION, $unknown }

String toJson$Enum$ProjectV2ItemOrderField(Enum$ProjectV2ItemOrderField e) {
  switch (e) {
    case Enum$ProjectV2ItemOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ItemOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemOrderField fromJson$Enum$ProjectV2ItemOrderField(
    String value) {
  switch (value) {
    case r'POSITION':
      return Enum$ProjectV2ItemOrderField.POSITION;
    default:
      return Enum$ProjectV2ItemOrderField.$unknown;
  }
}

enum Enum$ProjectV2ItemType {
  DRAFT_ISSUE,
  ISSUE,
  PULL_REQUEST,
  REDACTED,
  $unknown
}

String toJson$Enum$ProjectV2ItemType(Enum$ProjectV2ItemType e) {
  switch (e) {
    case Enum$ProjectV2ItemType.DRAFT_ISSUE:
      return r'DRAFT_ISSUE';
    case Enum$ProjectV2ItemType.ISSUE:
      return r'ISSUE';
    case Enum$ProjectV2ItemType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$ProjectV2ItemType.REDACTED:
      return r'REDACTED';
    case Enum$ProjectV2ItemType.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ItemType fromJson$Enum$ProjectV2ItemType(String value) {
  switch (value) {
    case r'DRAFT_ISSUE':
      return Enum$ProjectV2ItemType.DRAFT_ISSUE;
    case r'ISSUE':
      return Enum$ProjectV2ItemType.ISSUE;
    case r'PULL_REQUEST':
      return Enum$ProjectV2ItemType.PULL_REQUEST;
    case r'REDACTED':
      return Enum$ProjectV2ItemType.REDACTED;
    default:
      return Enum$ProjectV2ItemType.$unknown;
  }
}

enum Enum$ProjectV2OrderField {
  CREATED_AT,
  NUMBER,
  TITLE,
  UPDATED_AT,
  $unknown
}

String toJson$Enum$ProjectV2OrderField(Enum$ProjectV2OrderField e) {
  switch (e) {
    case Enum$ProjectV2OrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2OrderField.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2OrderField.TITLE:
      return r'TITLE';
    case Enum$ProjectV2OrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectV2OrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2OrderField fromJson$Enum$ProjectV2OrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectV2OrderField.CREATED_AT;
    case r'NUMBER':
      return Enum$ProjectV2OrderField.NUMBER;
    case r'TITLE':
      return Enum$ProjectV2OrderField.TITLE;
    case r'UPDATED_AT':
      return Enum$ProjectV2OrderField.UPDATED_AT;
    default:
      return Enum$ProjectV2OrderField.$unknown;
  }
}

enum Enum$ProjectV2SingleSelectFieldOptionColor {
  BLUE,
  GRAY,
  GREEN,
  ORANGE,
  PINK,
  PURPLE,
  RED,
  YELLOW,
  $unknown
}

String toJson$Enum$ProjectV2SingleSelectFieldOptionColor(
    Enum$ProjectV2SingleSelectFieldOptionColor e) {
  switch (e) {
    case Enum$ProjectV2SingleSelectFieldOptionColor.BLUE:
      return r'BLUE';
    case Enum$ProjectV2SingleSelectFieldOptionColor.GRAY:
      return r'GRAY';
    case Enum$ProjectV2SingleSelectFieldOptionColor.GREEN:
      return r'GREEN';
    case Enum$ProjectV2SingleSelectFieldOptionColor.ORANGE:
      return r'ORANGE';
    case Enum$ProjectV2SingleSelectFieldOptionColor.PINK:
      return r'PINK';
    case Enum$ProjectV2SingleSelectFieldOptionColor.PURPLE:
      return r'PURPLE';
    case Enum$ProjectV2SingleSelectFieldOptionColor.RED:
      return r'RED';
    case Enum$ProjectV2SingleSelectFieldOptionColor.YELLOW:
      return r'YELLOW';
    case Enum$ProjectV2SingleSelectFieldOptionColor.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2SingleSelectFieldOptionColor
    fromJson$Enum$ProjectV2SingleSelectFieldOptionColor(String value) {
  switch (value) {
    case r'BLUE':
      return Enum$ProjectV2SingleSelectFieldOptionColor.BLUE;
    case r'GRAY':
      return Enum$ProjectV2SingleSelectFieldOptionColor.GRAY;
    case r'GREEN':
      return Enum$ProjectV2SingleSelectFieldOptionColor.GREEN;
    case r'ORANGE':
      return Enum$ProjectV2SingleSelectFieldOptionColor.ORANGE;
    case r'PINK':
      return Enum$ProjectV2SingleSelectFieldOptionColor.PINK;
    case r'PURPLE':
      return Enum$ProjectV2SingleSelectFieldOptionColor.PURPLE;
    case r'RED':
      return Enum$ProjectV2SingleSelectFieldOptionColor.RED;
    case r'YELLOW':
      return Enum$ProjectV2SingleSelectFieldOptionColor.YELLOW;
    default:
      return Enum$ProjectV2SingleSelectFieldOptionColor.$unknown;
  }
}

enum Enum$ProjectV2State { CLOSED, OPEN, $unknown }

String toJson$Enum$ProjectV2State(Enum$ProjectV2State e) {
  switch (e) {
    case Enum$ProjectV2State.CLOSED:
      return r'CLOSED';
    case Enum$ProjectV2State.OPEN:
      return r'OPEN';
    case Enum$ProjectV2State.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2State fromJson$Enum$ProjectV2State(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$ProjectV2State.CLOSED;
    case r'OPEN':
      return Enum$ProjectV2State.OPEN;
    default:
      return Enum$ProjectV2State.$unknown;
  }
}

enum Enum$ProjectV2ViewLayout {
  BOARD_LAYOUT,
  ROADMAP_LAYOUT,
  TABLE_LAYOUT,
  $unknown
}

String toJson$Enum$ProjectV2ViewLayout(Enum$ProjectV2ViewLayout e) {
  switch (e) {
    case Enum$ProjectV2ViewLayout.BOARD_LAYOUT:
      return r'BOARD_LAYOUT';
    case Enum$ProjectV2ViewLayout.ROADMAP_LAYOUT:
      return r'ROADMAP_LAYOUT';
    case Enum$ProjectV2ViewLayout.TABLE_LAYOUT:
      return r'TABLE_LAYOUT';
    case Enum$ProjectV2ViewLayout.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ViewLayout fromJson$Enum$ProjectV2ViewLayout(String value) {
  switch (value) {
    case r'BOARD_LAYOUT':
      return Enum$ProjectV2ViewLayout.BOARD_LAYOUT;
    case r'ROADMAP_LAYOUT':
      return Enum$ProjectV2ViewLayout.ROADMAP_LAYOUT;
    case r'TABLE_LAYOUT':
      return Enum$ProjectV2ViewLayout.TABLE_LAYOUT;
    default:
      return Enum$ProjectV2ViewLayout.$unknown;
  }
}

enum Enum$ProjectV2ViewOrderField { CREATED_AT, NAME, POSITION, $unknown }

String toJson$Enum$ProjectV2ViewOrderField(Enum$ProjectV2ViewOrderField e) {
  switch (e) {
    case Enum$ProjectV2ViewOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2ViewOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2ViewOrderField.POSITION:
      return r'POSITION';
    case Enum$ProjectV2ViewOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2ViewOrderField fromJson$Enum$ProjectV2ViewOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectV2ViewOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectV2ViewOrderField.NAME;
    case r'POSITION':
      return Enum$ProjectV2ViewOrderField.POSITION;
    default:
      return Enum$ProjectV2ViewOrderField.$unknown;
  }
}

enum Enum$ProjectV2WorkflowsOrderField {
  CREATED_AT,
  NAME,
  NUMBER,
  UPDATED_AT,
  $unknown
}

String toJson$Enum$ProjectV2WorkflowsOrderField(
    Enum$ProjectV2WorkflowsOrderField e) {
  switch (e) {
    case Enum$ProjectV2WorkflowsOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ProjectV2WorkflowsOrderField.NAME:
      return r'NAME';
    case Enum$ProjectV2WorkflowsOrderField.NUMBER:
      return r'NUMBER';
    case Enum$ProjectV2WorkflowsOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$ProjectV2WorkflowsOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ProjectV2WorkflowsOrderField fromJson$Enum$ProjectV2WorkflowsOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ProjectV2WorkflowsOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ProjectV2WorkflowsOrderField.NAME;
    case r'NUMBER':
      return Enum$ProjectV2WorkflowsOrderField.NUMBER;
    case r'UPDATED_AT':
      return Enum$ProjectV2WorkflowsOrderField.UPDATED_AT;
    default:
      return Enum$ProjectV2WorkflowsOrderField.$unknown;
  }
}

enum Enum$PullRequestMergeMethod { MERGE, REBASE, SQUASH, $unknown }

String toJson$Enum$PullRequestMergeMethod(Enum$PullRequestMergeMethod e) {
  switch (e) {
    case Enum$PullRequestMergeMethod.MERGE:
      return r'MERGE';
    case Enum$PullRequestMergeMethod.REBASE:
      return r'REBASE';
    case Enum$PullRequestMergeMethod.SQUASH:
      return r'SQUASH';
    case Enum$PullRequestMergeMethod.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestMergeMethod fromJson$Enum$PullRequestMergeMethod(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$PullRequestMergeMethod.MERGE;
    case r'REBASE':
      return Enum$PullRequestMergeMethod.REBASE;
    case r'SQUASH':
      return Enum$PullRequestMergeMethod.SQUASH;
    default:
      return Enum$PullRequestMergeMethod.$unknown;
  }
}

enum Enum$PullRequestOrderField { CREATED_AT, UPDATED_AT, $unknown }

String toJson$Enum$PullRequestOrderField(Enum$PullRequestOrderField e) {
  switch (e) {
    case Enum$PullRequestOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$PullRequestOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$PullRequestOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestOrderField fromJson$Enum$PullRequestOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$PullRequestOrderField.CREATED_AT;
    case r'UPDATED_AT':
      return Enum$PullRequestOrderField.UPDATED_AT;
    default:
      return Enum$PullRequestOrderField.$unknown;
  }
}

enum Enum$PullRequestReviewCommentState { PENDING, SUBMITTED, $unknown }

String toJson$Enum$PullRequestReviewCommentState(
    Enum$PullRequestReviewCommentState e) {
  switch (e) {
    case Enum$PullRequestReviewCommentState.PENDING:
      return r'PENDING';
    case Enum$PullRequestReviewCommentState.SUBMITTED:
      return r'SUBMITTED';
    case Enum$PullRequestReviewCommentState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewCommentState fromJson$Enum$PullRequestReviewCommentState(
    String value) {
  switch (value) {
    case r'PENDING':
      return Enum$PullRequestReviewCommentState.PENDING;
    case r'SUBMITTED':
      return Enum$PullRequestReviewCommentState.SUBMITTED;
    default:
      return Enum$PullRequestReviewCommentState.$unknown;
  }
}

enum Enum$PullRequestReviewDecision {
  APPROVED,
  CHANGES_REQUESTED,
  REVIEW_REQUIRED,
  $unknown
}

String toJson$Enum$PullRequestReviewDecision(Enum$PullRequestReviewDecision e) {
  switch (e) {
    case Enum$PullRequestReviewDecision.APPROVED:
      return r'APPROVED';
    case Enum$PullRequestReviewDecision.CHANGES_REQUESTED:
      return r'CHANGES_REQUESTED';
    case Enum$PullRequestReviewDecision.REVIEW_REQUIRED:
      return r'REVIEW_REQUIRED';
    case Enum$PullRequestReviewDecision.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewDecision fromJson$Enum$PullRequestReviewDecision(
    String value) {
  switch (value) {
    case r'APPROVED':
      return Enum$PullRequestReviewDecision.APPROVED;
    case r'CHANGES_REQUESTED':
      return Enum$PullRequestReviewDecision.CHANGES_REQUESTED;
    case r'REVIEW_REQUIRED':
      return Enum$PullRequestReviewDecision.REVIEW_REQUIRED;
    default:
      return Enum$PullRequestReviewDecision.$unknown;
  }
}

enum Enum$PullRequestReviewEvent {
  APPROVE,
  COMMENT,
  DISMISS,
  REQUEST_CHANGES,
  $unknown
}

String toJson$Enum$PullRequestReviewEvent(Enum$PullRequestReviewEvent e) {
  switch (e) {
    case Enum$PullRequestReviewEvent.APPROVE:
      return r'APPROVE';
    case Enum$PullRequestReviewEvent.COMMENT:
      return r'COMMENT';
    case Enum$PullRequestReviewEvent.DISMISS:
      return r'DISMISS';
    case Enum$PullRequestReviewEvent.REQUEST_CHANGES:
      return r'REQUEST_CHANGES';
    case Enum$PullRequestReviewEvent.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewEvent fromJson$Enum$PullRequestReviewEvent(String value) {
  switch (value) {
    case r'APPROVE':
      return Enum$PullRequestReviewEvent.APPROVE;
    case r'COMMENT':
      return Enum$PullRequestReviewEvent.COMMENT;
    case r'DISMISS':
      return Enum$PullRequestReviewEvent.DISMISS;
    case r'REQUEST_CHANGES':
      return Enum$PullRequestReviewEvent.REQUEST_CHANGES;
    default:
      return Enum$PullRequestReviewEvent.$unknown;
  }
}

enum Enum$PullRequestReviewState {
  APPROVED,
  CHANGES_REQUESTED,
  COMMENTED,
  DISMISSED,
  PENDING,
  $unknown
}

String toJson$Enum$PullRequestReviewState(Enum$PullRequestReviewState e) {
  switch (e) {
    case Enum$PullRequestReviewState.APPROVED:
      return r'APPROVED';
    case Enum$PullRequestReviewState.CHANGES_REQUESTED:
      return r'CHANGES_REQUESTED';
    case Enum$PullRequestReviewState.COMMENTED:
      return r'COMMENTED';
    case Enum$PullRequestReviewState.DISMISSED:
      return r'DISMISSED';
    case Enum$PullRequestReviewState.PENDING:
      return r'PENDING';
    case Enum$PullRequestReviewState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestReviewState fromJson$Enum$PullRequestReviewState(String value) {
  switch (value) {
    case r'APPROVED':
      return Enum$PullRequestReviewState.APPROVED;
    case r'CHANGES_REQUESTED':
      return Enum$PullRequestReviewState.CHANGES_REQUESTED;
    case r'COMMENTED':
      return Enum$PullRequestReviewState.COMMENTED;
    case r'DISMISSED':
      return Enum$PullRequestReviewState.DISMISSED;
    case r'PENDING':
      return Enum$PullRequestReviewState.PENDING;
    default:
      return Enum$PullRequestReviewState.$unknown;
  }
}

enum Enum$PullRequestState { CLOSED, MERGED, OPEN, $unknown }

String toJson$Enum$PullRequestState(Enum$PullRequestState e) {
  switch (e) {
    case Enum$PullRequestState.CLOSED:
      return r'CLOSED';
    case Enum$PullRequestState.MERGED:
      return r'MERGED';
    case Enum$PullRequestState.OPEN:
      return r'OPEN';
    case Enum$PullRequestState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestState fromJson$Enum$PullRequestState(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$PullRequestState.CLOSED;
    case r'MERGED':
      return Enum$PullRequestState.MERGED;
    case r'OPEN':
      return Enum$PullRequestState.OPEN;
    default:
      return Enum$PullRequestState.$unknown;
  }
}

enum Enum$PullRequestTimelineItemsItemType {
  ADDED_TO_MERGE_QUEUE_EVENT,
  ADDED_TO_PROJECT_EVENT,
  ASSIGNED_EVENT,
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT,
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT,
  AUTO_MERGE_DISABLED_EVENT,
  AUTO_MERGE_ENABLED_EVENT,
  AUTO_REBASE_ENABLED_EVENT,
  AUTO_SQUASH_ENABLED_EVENT,
  BASE_REF_CHANGED_EVENT,
  BASE_REF_DELETED_EVENT,
  BASE_REF_FORCE_PUSHED_EVENT,
  CLOSED_EVENT,
  COMMENT_DELETED_EVENT,
  CONNECTED_EVENT,
  CONVERTED_NOTE_TO_ISSUE_EVENT,
  CONVERTED_TO_DISCUSSION_EVENT,
  CONVERT_TO_DRAFT_EVENT,
  CROSS_REFERENCED_EVENT,
  DEMILESTONED_EVENT,
  DEPLOYED_EVENT,
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT,
  DISCONNECTED_EVENT,
  HEAD_REF_DELETED_EVENT,
  HEAD_REF_FORCE_PUSHED_EVENT,
  HEAD_REF_RESTORED_EVENT,
  ISSUE_COMMENT,
  LABELED_EVENT,
  LOCKED_EVENT,
  MARKED_AS_DUPLICATE_EVENT,
  MENTIONED_EVENT,
  MERGED_EVENT,
  MILESTONED_EVENT,
  MOVED_COLUMNS_IN_PROJECT_EVENT,
  PINNED_EVENT,
  PULL_REQUEST_COMMIT,
  PULL_REQUEST_COMMIT_COMMENT_THREAD,
  PULL_REQUEST_REVIEW,
  PULL_REQUEST_REVIEW_THREAD,
  PULL_REQUEST_REVISION_MARKER,
  READY_FOR_REVIEW_EVENT,
  REFERENCED_EVENT,
  REMOVED_FROM_MERGE_QUEUE_EVENT,
  REMOVED_FROM_PROJECT_EVENT,
  RENAMED_TITLE_EVENT,
  REOPENED_EVENT,
  REVIEW_DISMISSED_EVENT,
  REVIEW_REQUESTED_EVENT,
  REVIEW_REQUEST_REMOVED_EVENT,
  SUBSCRIBED_EVENT,
  TRANSFERRED_EVENT,
  UNASSIGNED_EVENT,
  UNLABELED_EVENT,
  UNLOCKED_EVENT,
  UNMARKED_AS_DUPLICATE_EVENT,
  UNPINNED_EVENT,
  UNSUBSCRIBED_EVENT,
  USER_BLOCKED_EVENT,
  $unknown
}

String toJson$Enum$PullRequestTimelineItemsItemType(
    Enum$PullRequestTimelineItemsItemType e) {
  switch (e) {
    case Enum$PullRequestTimelineItemsItemType.ADDED_TO_MERGE_QUEUE_EVENT:
      return r'ADDED_TO_MERGE_QUEUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ADDED_TO_PROJECT_EVENT:
      return r'ADDED_TO_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ASSIGNED_EVENT:
      return r'ASSIGNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType
        .AUTOMATIC_BASE_CHANGE_FAILED_EVENT:
      return r'AUTOMATIC_BASE_CHANGE_FAILED_EVENT';
    case Enum$PullRequestTimelineItemsItemType
        .AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT:
      return r'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_DISABLED_EVENT:
      return r'AUTO_MERGE_DISABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_ENABLED_EVENT:
      return r'AUTO_MERGE_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_REBASE_ENABLED_EVENT:
      return r'AUTO_REBASE_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.AUTO_SQUASH_ENABLED_EVENT:
      return r'AUTO_SQUASH_ENABLED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_CHANGED_EVENT:
      return r'BASE_REF_CHANGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_DELETED_EVENT:
      return r'BASE_REF_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.BASE_REF_FORCE_PUSHED_EVENT:
      return r'BASE_REF_FORCE_PUSHED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CLOSED_EVENT:
      return r'CLOSED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.COMMENT_DELETED_EVENT:
      return r'COMMENT_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONNECTED_EVENT:
      return r'CONNECTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERTED_NOTE_TO_ISSUE_EVENT:
      return r'CONVERTED_NOTE_TO_ISSUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERTED_TO_DISCUSSION_EVENT:
      return r'CONVERTED_TO_DISCUSSION_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CONVERT_TO_DRAFT_EVENT:
      return r'CONVERT_TO_DRAFT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.CROSS_REFERENCED_EVENT:
      return r'CROSS_REFERENCED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DEMILESTONED_EVENT:
      return r'DEMILESTONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DEPLOYED_EVENT:
      return r'DEPLOYED_EVENT';
    case Enum$PullRequestTimelineItemsItemType
        .DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT:
      return r'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.DISCONNECTED_EVENT:
      return r'DISCONNECTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_DELETED_EVENT:
      return r'HEAD_REF_DELETED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_FORCE_PUSHED_EVENT:
      return r'HEAD_REF_FORCE_PUSHED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.HEAD_REF_RESTORED_EVENT:
      return r'HEAD_REF_RESTORED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.ISSUE_COMMENT:
      return r'ISSUE_COMMENT';
    case Enum$PullRequestTimelineItemsItemType.LABELED_EVENT:
      return r'LABELED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.LOCKED_EVENT:
      return r'LOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT:
      return r'MARKED_AS_DUPLICATE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MENTIONED_EVENT:
      return r'MENTIONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MERGED_EVENT:
      return r'MERGED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MILESTONED_EVENT:
      return r'MILESTONED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.MOVED_COLUMNS_IN_PROJECT_EVENT:
      return r'MOVED_COLUMNS_IN_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.PINNED_EVENT:
      return r'PINNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_COMMIT:
      return r'PULL_REQUEST_COMMIT';
    case Enum$PullRequestTimelineItemsItemType
        .PULL_REQUEST_COMMIT_COMMENT_THREAD:
      return r'PULL_REQUEST_COMMIT_COMMENT_THREAD';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW:
      return r'PULL_REQUEST_REVIEW';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW_THREAD:
      return r'PULL_REQUEST_REVIEW_THREAD';
    case Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVISION_MARKER:
      return r'PULL_REQUEST_REVISION_MARKER';
    case Enum$PullRequestTimelineItemsItemType.READY_FOR_REVIEW_EVENT:
      return r'READY_FOR_REVIEW_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REFERENCED_EVENT:
      return r'REFERENCED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_MERGE_QUEUE_EVENT:
      return r'REMOVED_FROM_MERGE_QUEUE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT:
      return r'REMOVED_FROM_PROJECT_EVENT';
    case Enum$PullRequestTimelineItemsItemType.RENAMED_TITLE_EVENT:
      return r'RENAMED_TITLE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REOPENED_EVENT:
      return r'REOPENED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_DISMISSED_EVENT:
      return r'REVIEW_DISMISSED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_REQUESTED_EVENT:
      return r'REVIEW_REQUESTED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.REVIEW_REQUEST_REMOVED_EVENT:
      return r'REVIEW_REQUEST_REMOVED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.SUBSCRIBED_EVENT:
      return r'SUBSCRIBED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.TRANSFERRED_EVENT:
      return r'TRANSFERRED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNASSIGNED_EVENT:
      return r'UNASSIGNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNLABELED_EVENT:
      return r'UNLABELED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNLOCKED_EVENT:
      return r'UNLOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT:
      return r'UNMARKED_AS_DUPLICATE_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNPINNED_EVENT:
      return r'UNPINNED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.UNSUBSCRIBED_EVENT:
      return r'UNSUBSCRIBED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.USER_BLOCKED_EVENT:
      return r'USER_BLOCKED_EVENT';
    case Enum$PullRequestTimelineItemsItemType.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestTimelineItemsItemType
    fromJson$Enum$PullRequestTimelineItemsItemType(String value) {
  switch (value) {
    case r'ADDED_TO_MERGE_QUEUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ADDED_TO_MERGE_QUEUE_EVENT;
    case r'ADDED_TO_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ADDED_TO_PROJECT_EVENT;
    case r'ASSIGNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.ASSIGNED_EVENT;
    case r'AUTOMATIC_BASE_CHANGE_FAILED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_FAILED_EVENT;
    case r'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT;
    case r'AUTO_MERGE_DISABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_DISABLED_EVENT;
    case r'AUTO_MERGE_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_MERGE_ENABLED_EVENT;
    case r'AUTO_REBASE_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_REBASE_ENABLED_EVENT;
    case r'AUTO_SQUASH_ENABLED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.AUTO_SQUASH_ENABLED_EVENT;
    case r'BASE_REF_CHANGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_CHANGED_EVENT;
    case r'BASE_REF_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_DELETED_EVENT;
    case r'BASE_REF_FORCE_PUSHED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.BASE_REF_FORCE_PUSHED_EVENT;
    case r'CLOSED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CLOSED_EVENT;
    case r'COMMENT_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.COMMENT_DELETED_EVENT;
    case r'CONNECTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CONNECTED_EVENT;
    case r'CONVERTED_NOTE_TO_ISSUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .CONVERTED_NOTE_TO_ISSUE_EVENT;
    case r'CONVERTED_TO_DISCUSSION_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .CONVERTED_TO_DISCUSSION_EVENT;
    case r'CONVERT_TO_DRAFT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CONVERT_TO_DRAFT_EVENT;
    case r'CROSS_REFERENCED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.CROSS_REFERENCED_EVENT;
    case r'DEMILESTONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DEMILESTONED_EVENT;
    case r'DEPLOYED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DEPLOYED_EVENT;
    case r'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT;
    case r'DISCONNECTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.DISCONNECTED_EVENT;
    case r'HEAD_REF_DELETED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_DELETED_EVENT;
    case r'HEAD_REF_FORCE_PUSHED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_FORCE_PUSHED_EVENT;
    case r'HEAD_REF_RESTORED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.HEAD_REF_RESTORED_EVENT;
    case r'ISSUE_COMMENT':
      return Enum$PullRequestTimelineItemsItemType.ISSUE_COMMENT;
    case r'LABELED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.LABELED_EVENT;
    case r'LOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.LOCKED_EVENT;
    case r'MARKED_AS_DUPLICATE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MARKED_AS_DUPLICATE_EVENT;
    case r'MENTIONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MENTIONED_EVENT;
    case r'MERGED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MERGED_EVENT;
    case r'MILESTONED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.MILESTONED_EVENT;
    case r'MOVED_COLUMNS_IN_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .MOVED_COLUMNS_IN_PROJECT_EVENT;
    case r'PINNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.PINNED_EVENT;
    case r'PULL_REQUEST_COMMIT':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_COMMIT;
    case r'PULL_REQUEST_COMMIT_COMMENT_THREAD':
      return Enum$PullRequestTimelineItemsItemType
          .PULL_REQUEST_COMMIT_COMMENT_THREAD;
    case r'PULL_REQUEST_REVIEW':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW;
    case r'PULL_REQUEST_REVIEW_THREAD':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVIEW_THREAD;
    case r'PULL_REQUEST_REVISION_MARKER':
      return Enum$PullRequestTimelineItemsItemType.PULL_REQUEST_REVISION_MARKER;
    case r'READY_FOR_REVIEW_EVENT':
      return Enum$PullRequestTimelineItemsItemType.READY_FOR_REVIEW_EVENT;
    case r'REFERENCED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REFERENCED_EVENT;
    case r'REMOVED_FROM_MERGE_QUEUE_EVENT':
      return Enum$PullRequestTimelineItemsItemType
          .REMOVED_FROM_MERGE_QUEUE_EVENT;
    case r'REMOVED_FROM_PROJECT_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REMOVED_FROM_PROJECT_EVENT;
    case r'RENAMED_TITLE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.RENAMED_TITLE_EVENT;
    case r'REOPENED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REOPENED_EVENT;
    case r'REVIEW_DISMISSED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_DISMISSED_EVENT;
    case r'REVIEW_REQUESTED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_REQUESTED_EVENT;
    case r'REVIEW_REQUEST_REMOVED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.REVIEW_REQUEST_REMOVED_EVENT;
    case r'SUBSCRIBED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.SUBSCRIBED_EVENT;
    case r'TRANSFERRED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.TRANSFERRED_EVENT;
    case r'UNASSIGNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNASSIGNED_EVENT;
    case r'UNLABELED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNLABELED_EVENT;
    case r'UNLOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNLOCKED_EVENT;
    case r'UNMARKED_AS_DUPLICATE_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNMARKED_AS_DUPLICATE_EVENT;
    case r'UNPINNED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNPINNED_EVENT;
    case r'UNSUBSCRIBED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.UNSUBSCRIBED_EVENT;
    case r'USER_BLOCKED_EVENT':
      return Enum$PullRequestTimelineItemsItemType.USER_BLOCKED_EVENT;
    default:
      return Enum$PullRequestTimelineItemsItemType.$unknown;
  }
}

enum Enum$PullRequestUpdateState { CLOSED, OPEN, $unknown }

String toJson$Enum$PullRequestUpdateState(Enum$PullRequestUpdateState e) {
  switch (e) {
    case Enum$PullRequestUpdateState.CLOSED:
      return r'CLOSED';
    case Enum$PullRequestUpdateState.OPEN:
      return r'OPEN';
    case Enum$PullRequestUpdateState.$unknown:
      return r'$unknown';
  }
}

Enum$PullRequestUpdateState fromJson$Enum$PullRequestUpdateState(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$PullRequestUpdateState.CLOSED;
    case r'OPEN':
      return Enum$PullRequestUpdateState.OPEN;
    default:
      return Enum$PullRequestUpdateState.$unknown;
  }
}

enum Enum$ReactionContent {
  CONFUSED,
  EYES,
  HEART,
  HOORAY,
  LAUGH,
  ROCKET,
  THUMBS_DOWN,
  THUMBS_UP,
  $unknown
}

String toJson$Enum$ReactionContent(Enum$ReactionContent e) {
  switch (e) {
    case Enum$ReactionContent.CONFUSED:
      return r'CONFUSED';
    case Enum$ReactionContent.EYES:
      return r'EYES';
    case Enum$ReactionContent.HEART:
      return r'HEART';
    case Enum$ReactionContent.HOORAY:
      return r'HOORAY';
    case Enum$ReactionContent.LAUGH:
      return r'LAUGH';
    case Enum$ReactionContent.ROCKET:
      return r'ROCKET';
    case Enum$ReactionContent.THUMBS_DOWN:
      return r'THUMBS_DOWN';
    case Enum$ReactionContent.THUMBS_UP:
      return r'THUMBS_UP';
    case Enum$ReactionContent.$unknown:
      return r'$unknown';
  }
}

Enum$ReactionContent fromJson$Enum$ReactionContent(String value) {
  switch (value) {
    case r'CONFUSED':
      return Enum$ReactionContent.CONFUSED;
    case r'EYES':
      return Enum$ReactionContent.EYES;
    case r'HEART':
      return Enum$ReactionContent.HEART;
    case r'HOORAY':
      return Enum$ReactionContent.HOORAY;
    case r'LAUGH':
      return Enum$ReactionContent.LAUGH;
    case r'ROCKET':
      return Enum$ReactionContent.ROCKET;
    case r'THUMBS_DOWN':
      return Enum$ReactionContent.THUMBS_DOWN;
    case r'THUMBS_UP':
      return Enum$ReactionContent.THUMBS_UP;
    default:
      return Enum$ReactionContent.$unknown;
  }
}

enum Enum$ReactionOrderField { CREATED_AT, $unknown }

String toJson$Enum$ReactionOrderField(Enum$ReactionOrderField e) {
  switch (e) {
    case Enum$ReactionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ReactionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ReactionOrderField fromJson$Enum$ReactionOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ReactionOrderField.CREATED_AT;
    default:
      return Enum$ReactionOrderField.$unknown;
  }
}

enum Enum$RefOrderField { ALPHABETICAL, TAG_COMMIT_DATE, $unknown }

String toJson$Enum$RefOrderField(Enum$RefOrderField e) {
  switch (e) {
    case Enum$RefOrderField.ALPHABETICAL:
      return r'ALPHABETICAL';
    case Enum$RefOrderField.TAG_COMMIT_DATE:
      return r'TAG_COMMIT_DATE';
    case Enum$RefOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RefOrderField fromJson$Enum$RefOrderField(String value) {
  switch (value) {
    case r'ALPHABETICAL':
      return Enum$RefOrderField.ALPHABETICAL;
    case r'TAG_COMMIT_DATE':
      return Enum$RefOrderField.TAG_COMMIT_DATE;
    default:
      return Enum$RefOrderField.$unknown;
  }
}

enum Enum$ReleaseOrderField { CREATED_AT, NAME, $unknown }

String toJson$Enum$ReleaseOrderField(Enum$ReleaseOrderField e) {
  switch (e) {
    case Enum$ReleaseOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$ReleaseOrderField.NAME:
      return r'NAME';
    case Enum$ReleaseOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$ReleaseOrderField fromJson$Enum$ReleaseOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$ReleaseOrderField.CREATED_AT;
    case r'NAME':
      return Enum$ReleaseOrderField.NAME;
    default:
      return Enum$ReleaseOrderField.$unknown;
  }
}

enum Enum$RepoAccessAuditEntryVisibility { INTERNAL, PRIVATE, PUBLIC, $unknown }

String toJson$Enum$RepoAccessAuditEntryVisibility(
    Enum$RepoAccessAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoAccessAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoAccessAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoAccessAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoAccessAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoAccessAuditEntryVisibility
    fromJson$Enum$RepoAccessAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoAccessAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoAccessAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoAccessAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoAccessAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoAddMemberAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoAddMemberAuditEntryVisibility(
    Enum$RepoAddMemberAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoAddMemberAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoAddMemberAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoAddMemberAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoAddMemberAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoAddMemberAuditEntryVisibility
    fromJson$Enum$RepoAddMemberAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoAddMemberAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoAddMemberAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoAddMemberAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoAddMemberAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoArchivedAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoArchivedAuditEntryVisibility(
    Enum$RepoArchivedAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoArchivedAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoArchivedAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoArchivedAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoArchivedAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoArchivedAuditEntryVisibility
    fromJson$Enum$RepoArchivedAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoArchivedAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoArchivedAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoArchivedAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoArchivedAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoChangeMergeSettingAuditEntryMergeType {
  MERGE,
  REBASE,
  SQUASH,
  $unknown
}

String toJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(
    Enum$RepoChangeMergeSettingAuditEntryMergeType e) {
  switch (e) {
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.MERGE:
      return r'MERGE';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.REBASE:
      return r'REBASE';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.SQUASH:
      return r'SQUASH';
    case Enum$RepoChangeMergeSettingAuditEntryMergeType.$unknown:
      return r'$unknown';
  }
}

Enum$RepoChangeMergeSettingAuditEntryMergeType
    fromJson$Enum$RepoChangeMergeSettingAuditEntryMergeType(String value) {
  switch (value) {
    case r'MERGE':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.MERGE;
    case r'REBASE':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.REBASE;
    case r'SQUASH':
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.SQUASH;
    default:
      return Enum$RepoChangeMergeSettingAuditEntryMergeType.$unknown;
  }
}

enum Enum$RepoCreateAuditEntryVisibility { INTERNAL, PRIVATE, PUBLIC, $unknown }

String toJson$Enum$RepoCreateAuditEntryVisibility(
    Enum$RepoCreateAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoCreateAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoCreateAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoCreateAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoCreateAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoCreateAuditEntryVisibility
    fromJson$Enum$RepoCreateAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoCreateAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoCreateAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoCreateAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoCreateAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoDestroyAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoDestroyAuditEntryVisibility(
    Enum$RepoDestroyAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoDestroyAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoDestroyAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoDestroyAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoDestroyAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoDestroyAuditEntryVisibility
    fromJson$Enum$RepoDestroyAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoDestroyAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoDestroyAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoDestroyAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoDestroyAuditEntryVisibility.$unknown;
  }
}

enum Enum$RepoRemoveMemberAuditEntryVisibility {
  INTERNAL,
  PRIVATE,
  PUBLIC,
  $unknown
}

String toJson$Enum$RepoRemoveMemberAuditEntryVisibility(
    Enum$RepoRemoveMemberAuditEntryVisibility e) {
  switch (e) {
    case Enum$RepoRemoveMemberAuditEntryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepoRemoveMemberAuditEntryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepoRemoveMemberAuditEntryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepoRemoveMemberAuditEntryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepoRemoveMemberAuditEntryVisibility
    fromJson$Enum$RepoRemoveMemberAuditEntryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepoRemoveMemberAuditEntryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepoRemoveMemberAuditEntryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepoRemoveMemberAuditEntryVisibility.PUBLIC;
    default:
      return Enum$RepoRemoveMemberAuditEntryVisibility.$unknown;
  }
}

enum Enum$ReportedContentClassifiers {
  ABUSE,
  DUPLICATE,
  OFF_TOPIC,
  OUTDATED,
  RESOLVED,
  SPAM,
  $unknown
}

String toJson$Enum$ReportedContentClassifiers(
    Enum$ReportedContentClassifiers e) {
  switch (e) {
    case Enum$ReportedContentClassifiers.ABUSE:
      return r'ABUSE';
    case Enum$ReportedContentClassifiers.DUPLICATE:
      return r'DUPLICATE';
    case Enum$ReportedContentClassifiers.OFF_TOPIC:
      return r'OFF_TOPIC';
    case Enum$ReportedContentClassifiers.OUTDATED:
      return r'OUTDATED';
    case Enum$ReportedContentClassifiers.RESOLVED:
      return r'RESOLVED';
    case Enum$ReportedContentClassifiers.SPAM:
      return r'SPAM';
    case Enum$ReportedContentClassifiers.$unknown:
      return r'$unknown';
  }
}

Enum$ReportedContentClassifiers fromJson$Enum$ReportedContentClassifiers(
    String value) {
  switch (value) {
    case r'ABUSE':
      return Enum$ReportedContentClassifiers.ABUSE;
    case r'DUPLICATE':
      return Enum$ReportedContentClassifiers.DUPLICATE;
    case r'OFF_TOPIC':
      return Enum$ReportedContentClassifiers.OFF_TOPIC;
    case r'OUTDATED':
      return Enum$ReportedContentClassifiers.OUTDATED;
    case r'RESOLVED':
      return Enum$ReportedContentClassifiers.RESOLVED;
    case r'SPAM':
      return Enum$ReportedContentClassifiers.SPAM;
    default:
      return Enum$ReportedContentClassifiers.$unknown;
  }
}

enum Enum$RepositoryAffiliation {
  COLLABORATOR,
  ORGANIZATION_MEMBER,
  OWNER,
  $unknown
}

String toJson$Enum$RepositoryAffiliation(Enum$RepositoryAffiliation e) {
  switch (e) {
    case Enum$RepositoryAffiliation.COLLABORATOR:
      return r'COLLABORATOR';
    case Enum$RepositoryAffiliation.ORGANIZATION_MEMBER:
      return r'ORGANIZATION_MEMBER';
    case Enum$RepositoryAffiliation.OWNER:
      return r'OWNER';
    case Enum$RepositoryAffiliation.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryAffiliation fromJson$Enum$RepositoryAffiliation(String value) {
  switch (value) {
    case r'COLLABORATOR':
      return Enum$RepositoryAffiliation.COLLABORATOR;
    case r'ORGANIZATION_MEMBER':
      return Enum$RepositoryAffiliation.ORGANIZATION_MEMBER;
    case r'OWNER':
      return Enum$RepositoryAffiliation.OWNER;
    default:
      return Enum$RepositoryAffiliation.$unknown;
  }
}

enum Enum$RepositoryContributionType {
  COMMIT,
  ISSUE,
  PULL_REQUEST,
  PULL_REQUEST_REVIEW,
  REPOSITORY,
  $unknown
}

String toJson$Enum$RepositoryContributionType(
    Enum$RepositoryContributionType e) {
  switch (e) {
    case Enum$RepositoryContributionType.COMMIT:
      return r'COMMIT';
    case Enum$RepositoryContributionType.ISSUE:
      return r'ISSUE';
    case Enum$RepositoryContributionType.PULL_REQUEST:
      return r'PULL_REQUEST';
    case Enum$RepositoryContributionType.PULL_REQUEST_REVIEW:
      return r'PULL_REQUEST_REVIEW';
    case Enum$RepositoryContributionType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$RepositoryContributionType.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryContributionType fromJson$Enum$RepositoryContributionType(
    String value) {
  switch (value) {
    case r'COMMIT':
      return Enum$RepositoryContributionType.COMMIT;
    case r'ISSUE':
      return Enum$RepositoryContributionType.ISSUE;
    case r'PULL_REQUEST':
      return Enum$RepositoryContributionType.PULL_REQUEST;
    case r'PULL_REQUEST_REVIEW':
      return Enum$RepositoryContributionType.PULL_REQUEST_REVIEW;
    case r'REPOSITORY':
      return Enum$RepositoryContributionType.REPOSITORY;
    default:
      return Enum$RepositoryContributionType.$unknown;
  }
}

enum Enum$RepositoryInteractionLimit {
  COLLABORATORS_ONLY,
  CONTRIBUTORS_ONLY,
  EXISTING_USERS,
  NO_LIMIT,
  $unknown
}

String toJson$Enum$RepositoryInteractionLimit(
    Enum$RepositoryInteractionLimit e) {
  switch (e) {
    case Enum$RepositoryInteractionLimit.COLLABORATORS_ONLY:
      return r'COLLABORATORS_ONLY';
    case Enum$RepositoryInteractionLimit.CONTRIBUTORS_ONLY:
      return r'CONTRIBUTORS_ONLY';
    case Enum$RepositoryInteractionLimit.EXISTING_USERS:
      return r'EXISTING_USERS';
    case Enum$RepositoryInteractionLimit.NO_LIMIT:
      return r'NO_LIMIT';
    case Enum$RepositoryInteractionLimit.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimit fromJson$Enum$RepositoryInteractionLimit(
    String value) {
  switch (value) {
    case r'COLLABORATORS_ONLY':
      return Enum$RepositoryInteractionLimit.COLLABORATORS_ONLY;
    case r'CONTRIBUTORS_ONLY':
      return Enum$RepositoryInteractionLimit.CONTRIBUTORS_ONLY;
    case r'EXISTING_USERS':
      return Enum$RepositoryInteractionLimit.EXISTING_USERS;
    case r'NO_LIMIT':
      return Enum$RepositoryInteractionLimit.NO_LIMIT;
    default:
      return Enum$RepositoryInteractionLimit.$unknown;
  }
}

enum Enum$RepositoryInteractionLimitExpiry {
  ONE_DAY,
  ONE_MONTH,
  ONE_WEEK,
  SIX_MONTHS,
  THREE_DAYS,
  $unknown
}

String toJson$Enum$RepositoryInteractionLimitExpiry(
    Enum$RepositoryInteractionLimitExpiry e) {
  switch (e) {
    case Enum$RepositoryInteractionLimitExpiry.ONE_DAY:
      return r'ONE_DAY';
    case Enum$RepositoryInteractionLimitExpiry.ONE_MONTH:
      return r'ONE_MONTH';
    case Enum$RepositoryInteractionLimitExpiry.ONE_WEEK:
      return r'ONE_WEEK';
    case Enum$RepositoryInteractionLimitExpiry.SIX_MONTHS:
      return r'SIX_MONTHS';
    case Enum$RepositoryInteractionLimitExpiry.THREE_DAYS:
      return r'THREE_DAYS';
    case Enum$RepositoryInteractionLimitExpiry.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimitExpiry
    fromJson$Enum$RepositoryInteractionLimitExpiry(String value) {
  switch (value) {
    case r'ONE_DAY':
      return Enum$RepositoryInteractionLimitExpiry.ONE_DAY;
    case r'ONE_MONTH':
      return Enum$RepositoryInteractionLimitExpiry.ONE_MONTH;
    case r'ONE_WEEK':
      return Enum$RepositoryInteractionLimitExpiry.ONE_WEEK;
    case r'SIX_MONTHS':
      return Enum$RepositoryInteractionLimitExpiry.SIX_MONTHS;
    case r'THREE_DAYS':
      return Enum$RepositoryInteractionLimitExpiry.THREE_DAYS;
    default:
      return Enum$RepositoryInteractionLimitExpiry.$unknown;
  }
}

enum Enum$RepositoryInteractionLimitOrigin {
  ORGANIZATION,
  REPOSITORY,
  USER,
  $unknown
}

String toJson$Enum$RepositoryInteractionLimitOrigin(
    Enum$RepositoryInteractionLimitOrigin e) {
  switch (e) {
    case Enum$RepositoryInteractionLimitOrigin.ORGANIZATION:
      return r'ORGANIZATION';
    case Enum$RepositoryInteractionLimitOrigin.REPOSITORY:
      return r'REPOSITORY';
    case Enum$RepositoryInteractionLimitOrigin.USER:
      return r'USER';
    case Enum$RepositoryInteractionLimitOrigin.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInteractionLimitOrigin
    fromJson$Enum$RepositoryInteractionLimitOrigin(String value) {
  switch (value) {
    case r'ORGANIZATION':
      return Enum$RepositoryInteractionLimitOrigin.ORGANIZATION;
    case r'REPOSITORY':
      return Enum$RepositoryInteractionLimitOrigin.REPOSITORY;
    case r'USER':
      return Enum$RepositoryInteractionLimitOrigin.USER;
    default:
      return Enum$RepositoryInteractionLimitOrigin.$unknown;
  }
}

enum Enum$RepositoryInvitationOrderField { CREATED_AT, $unknown }

String toJson$Enum$RepositoryInvitationOrderField(
    Enum$RepositoryInvitationOrderField e) {
  switch (e) {
    case Enum$RepositoryInvitationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryInvitationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryInvitationOrderField
    fromJson$Enum$RepositoryInvitationOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryInvitationOrderField.CREATED_AT;
    default:
      return Enum$RepositoryInvitationOrderField.$unknown;
  }
}

enum Enum$RepositoryLockReason {
  BILLING,
  MIGRATING,
  MOVING,
  RENAME,
  TRADE_RESTRICTION,
  $unknown
}

String toJson$Enum$RepositoryLockReason(Enum$RepositoryLockReason e) {
  switch (e) {
    case Enum$RepositoryLockReason.BILLING:
      return r'BILLING';
    case Enum$RepositoryLockReason.MIGRATING:
      return r'MIGRATING';
    case Enum$RepositoryLockReason.MOVING:
      return r'MOVING';
    case Enum$RepositoryLockReason.RENAME:
      return r'RENAME';
    case Enum$RepositoryLockReason.TRADE_RESTRICTION:
      return r'TRADE_RESTRICTION';
    case Enum$RepositoryLockReason.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryLockReason fromJson$Enum$RepositoryLockReason(String value) {
  switch (value) {
    case r'BILLING':
      return Enum$RepositoryLockReason.BILLING;
    case r'MIGRATING':
      return Enum$RepositoryLockReason.MIGRATING;
    case r'MOVING':
      return Enum$RepositoryLockReason.MOVING;
    case r'RENAME':
      return Enum$RepositoryLockReason.RENAME;
    case r'TRADE_RESTRICTION':
      return Enum$RepositoryLockReason.TRADE_RESTRICTION;
    default:
      return Enum$RepositoryLockReason.$unknown;
  }
}

enum Enum$RepositoryMigrationOrderDirection { ASC, DESC, $unknown }

String toJson$Enum$RepositoryMigrationOrderDirection(
    Enum$RepositoryMigrationOrderDirection e) {
  switch (e) {
    case Enum$RepositoryMigrationOrderDirection.ASC:
      return r'ASC';
    case Enum$RepositoryMigrationOrderDirection.DESC:
      return r'DESC';
    case Enum$RepositoryMigrationOrderDirection.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryMigrationOrderDirection
    fromJson$Enum$RepositoryMigrationOrderDirection(String value) {
  switch (value) {
    case r'ASC':
      return Enum$RepositoryMigrationOrderDirection.ASC;
    case r'DESC':
      return Enum$RepositoryMigrationOrderDirection.DESC;
    default:
      return Enum$RepositoryMigrationOrderDirection.$unknown;
  }
}

enum Enum$RepositoryMigrationOrderField { CREATED_AT, $unknown }

String toJson$Enum$RepositoryMigrationOrderField(
    Enum$RepositoryMigrationOrderField e) {
  switch (e) {
    case Enum$RepositoryMigrationOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryMigrationOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryMigrationOrderField fromJson$Enum$RepositoryMigrationOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryMigrationOrderField.CREATED_AT;
    default:
      return Enum$RepositoryMigrationOrderField.$unknown;
  }
}

enum Enum$RepositoryOrderField {
  CREATED_AT,
  NAME,
  PUSHED_AT,
  STARGAZERS,
  UPDATED_AT,
  $unknown
}

String toJson$Enum$RepositoryOrderField(Enum$RepositoryOrderField e) {
  switch (e) {
    case Enum$RepositoryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$RepositoryOrderField.NAME:
      return r'NAME';
    case Enum$RepositoryOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$RepositoryOrderField.STARGAZERS:
      return r'STARGAZERS';
    case Enum$RepositoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$RepositoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryOrderField fromJson$Enum$RepositoryOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$RepositoryOrderField.CREATED_AT;
    case r'NAME':
      return Enum$RepositoryOrderField.NAME;
    case r'PUSHED_AT':
      return Enum$RepositoryOrderField.PUSHED_AT;
    case r'STARGAZERS':
      return Enum$RepositoryOrderField.STARGAZERS;
    case r'UPDATED_AT':
      return Enum$RepositoryOrderField.UPDATED_AT;
    default:
      return Enum$RepositoryOrderField.$unknown;
  }
}

enum Enum$RepositoryPermission {
  ADMIN,
  MAINTAIN,
  READ,
  TRIAGE,
  WRITE,
  $unknown
}

String toJson$Enum$RepositoryPermission(Enum$RepositoryPermission e) {
  switch (e) {
    case Enum$RepositoryPermission.ADMIN:
      return r'ADMIN';
    case Enum$RepositoryPermission.MAINTAIN:
      return r'MAINTAIN';
    case Enum$RepositoryPermission.READ:
      return r'READ';
    case Enum$RepositoryPermission.TRIAGE:
      return r'TRIAGE';
    case Enum$RepositoryPermission.WRITE:
      return r'WRITE';
    case Enum$RepositoryPermission.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryPermission fromJson$Enum$RepositoryPermission(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$RepositoryPermission.ADMIN;
    case r'MAINTAIN':
      return Enum$RepositoryPermission.MAINTAIN;
    case r'READ':
      return Enum$RepositoryPermission.READ;
    case r'TRIAGE':
      return Enum$RepositoryPermission.TRIAGE;
    case r'WRITE':
      return Enum$RepositoryPermission.WRITE;
    default:
      return Enum$RepositoryPermission.$unknown;
  }
}

enum Enum$RepositoryPrivacy { PRIVATE, PUBLIC, $unknown }

String toJson$Enum$RepositoryPrivacy(Enum$RepositoryPrivacy e) {
  switch (e) {
    case Enum$RepositoryPrivacy.PRIVATE:
      return r'PRIVATE';
    case Enum$RepositoryPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$RepositoryPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryPrivacy fromJson$Enum$RepositoryPrivacy(String value) {
  switch (value) {
    case r'PRIVATE':
      return Enum$RepositoryPrivacy.PRIVATE;
    case r'PUBLIC':
      return Enum$RepositoryPrivacy.PUBLIC;
    default:
      return Enum$RepositoryPrivacy.$unknown;
  }
}

enum Enum$RepositoryVisibility { INTERNAL, PRIVATE, PUBLIC, $unknown }

String toJson$Enum$RepositoryVisibility(Enum$RepositoryVisibility e) {
  switch (e) {
    case Enum$RepositoryVisibility.INTERNAL:
      return r'INTERNAL';
    case Enum$RepositoryVisibility.PRIVATE:
      return r'PRIVATE';
    case Enum$RepositoryVisibility.PUBLIC:
      return r'PUBLIC';
    case Enum$RepositoryVisibility.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVisibility fromJson$Enum$RepositoryVisibility(String value) {
  switch (value) {
    case r'INTERNAL':
      return Enum$RepositoryVisibility.INTERNAL;
    case r'PRIVATE':
      return Enum$RepositoryVisibility.PRIVATE;
    case r'PUBLIC':
      return Enum$RepositoryVisibility.PUBLIC;
    default:
      return Enum$RepositoryVisibility.$unknown;
  }
}

enum Enum$RepositoryVulnerabilityAlertDependencyScope {
  DEVELOPMENT,
  RUNTIME,
  $unknown
}

String toJson$Enum$RepositoryVulnerabilityAlertDependencyScope(
    Enum$RepositoryVulnerabilityAlertDependencyScope e) {
  switch (e) {
    case Enum$RepositoryVulnerabilityAlertDependencyScope.DEVELOPMENT:
      return r'DEVELOPMENT';
    case Enum$RepositoryVulnerabilityAlertDependencyScope.RUNTIME:
      return r'RUNTIME';
    case Enum$RepositoryVulnerabilityAlertDependencyScope.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVulnerabilityAlertDependencyScope
    fromJson$Enum$RepositoryVulnerabilityAlertDependencyScope(String value) {
  switch (value) {
    case r'DEVELOPMENT':
      return Enum$RepositoryVulnerabilityAlertDependencyScope.DEVELOPMENT;
    case r'RUNTIME':
      return Enum$RepositoryVulnerabilityAlertDependencyScope.RUNTIME;
    default:
      return Enum$RepositoryVulnerabilityAlertDependencyScope.$unknown;
  }
}

enum Enum$RepositoryVulnerabilityAlertState { DISMISSED, FIXED, OPEN, $unknown }

String toJson$Enum$RepositoryVulnerabilityAlertState(
    Enum$RepositoryVulnerabilityAlertState e) {
  switch (e) {
    case Enum$RepositoryVulnerabilityAlertState.DISMISSED:
      return r'DISMISSED';
    case Enum$RepositoryVulnerabilityAlertState.FIXED:
      return r'FIXED';
    case Enum$RepositoryVulnerabilityAlertState.OPEN:
      return r'OPEN';
    case Enum$RepositoryVulnerabilityAlertState.$unknown:
      return r'$unknown';
  }
}

Enum$RepositoryVulnerabilityAlertState
    fromJson$Enum$RepositoryVulnerabilityAlertState(String value) {
  switch (value) {
    case r'DISMISSED':
      return Enum$RepositoryVulnerabilityAlertState.DISMISSED;
    case r'FIXED':
      return Enum$RepositoryVulnerabilityAlertState.FIXED;
    case r'OPEN':
      return Enum$RepositoryVulnerabilityAlertState.OPEN;
    default:
      return Enum$RepositoryVulnerabilityAlertState.$unknown;
  }
}

enum Enum$RequestableCheckStatusState {
  COMPLETED,
  IN_PROGRESS,
  PENDING,
  QUEUED,
  WAITING,
  $unknown
}

String toJson$Enum$RequestableCheckStatusState(
    Enum$RequestableCheckStatusState e) {
  switch (e) {
    case Enum$RequestableCheckStatusState.COMPLETED:
      return r'COMPLETED';
    case Enum$RequestableCheckStatusState.IN_PROGRESS:
      return r'IN_PROGRESS';
    case Enum$RequestableCheckStatusState.PENDING:
      return r'PENDING';
    case Enum$RequestableCheckStatusState.QUEUED:
      return r'QUEUED';
    case Enum$RequestableCheckStatusState.WAITING:
      return r'WAITING';
    case Enum$RequestableCheckStatusState.$unknown:
      return r'$unknown';
  }
}

Enum$RequestableCheckStatusState fromJson$Enum$RequestableCheckStatusState(
    String value) {
  switch (value) {
    case r'COMPLETED':
      return Enum$RequestableCheckStatusState.COMPLETED;
    case r'IN_PROGRESS':
      return Enum$RequestableCheckStatusState.IN_PROGRESS;
    case r'PENDING':
      return Enum$RequestableCheckStatusState.PENDING;
    case r'QUEUED':
      return Enum$RequestableCheckStatusState.QUEUED;
    case r'WAITING':
      return Enum$RequestableCheckStatusState.WAITING;
    default:
      return Enum$RequestableCheckStatusState.$unknown;
  }
}

enum Enum$RoleInOrganization { DIRECT_MEMBER, OWNER, UNAFFILIATED, $unknown }

String toJson$Enum$RoleInOrganization(Enum$RoleInOrganization e) {
  switch (e) {
    case Enum$RoleInOrganization.DIRECT_MEMBER:
      return r'DIRECT_MEMBER';
    case Enum$RoleInOrganization.OWNER:
      return r'OWNER';
    case Enum$RoleInOrganization.UNAFFILIATED:
      return r'UNAFFILIATED';
    case Enum$RoleInOrganization.$unknown:
      return r'$unknown';
  }
}

Enum$RoleInOrganization fromJson$Enum$RoleInOrganization(String value) {
  switch (value) {
    case r'DIRECT_MEMBER':
      return Enum$RoleInOrganization.DIRECT_MEMBER;
    case r'OWNER':
      return Enum$RoleInOrganization.OWNER;
    case r'UNAFFILIATED':
      return Enum$RoleInOrganization.UNAFFILIATED;
    default:
      return Enum$RoleInOrganization.$unknown;
  }
}

enum Enum$SamlDigestAlgorithm { SHA1, SHA256, SHA384, SHA512, $unknown }

String toJson$Enum$SamlDigestAlgorithm(Enum$SamlDigestAlgorithm e) {
  switch (e) {
    case Enum$SamlDigestAlgorithm.SHA1:
      return r'SHA1';
    case Enum$SamlDigestAlgorithm.SHA256:
      return r'SHA256';
    case Enum$SamlDigestAlgorithm.SHA384:
      return r'SHA384';
    case Enum$SamlDigestAlgorithm.SHA512:
      return r'SHA512';
    case Enum$SamlDigestAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$SamlDigestAlgorithm fromJson$Enum$SamlDigestAlgorithm(String value) {
  switch (value) {
    case r'SHA1':
      return Enum$SamlDigestAlgorithm.SHA1;
    case r'SHA256':
      return Enum$SamlDigestAlgorithm.SHA256;
    case r'SHA384':
      return Enum$SamlDigestAlgorithm.SHA384;
    case r'SHA512':
      return Enum$SamlDigestAlgorithm.SHA512;
    default:
      return Enum$SamlDigestAlgorithm.$unknown;
  }
}

enum Enum$SamlSignatureAlgorithm {
  RSA_SHA1,
  RSA_SHA256,
  RSA_SHA384,
  RSA_SHA512,
  $unknown
}

String toJson$Enum$SamlSignatureAlgorithm(Enum$SamlSignatureAlgorithm e) {
  switch (e) {
    case Enum$SamlSignatureAlgorithm.RSA_SHA1:
      return r'RSA_SHA1';
    case Enum$SamlSignatureAlgorithm.RSA_SHA256:
      return r'RSA_SHA256';
    case Enum$SamlSignatureAlgorithm.RSA_SHA384:
      return r'RSA_SHA384';
    case Enum$SamlSignatureAlgorithm.RSA_SHA512:
      return r'RSA_SHA512';
    case Enum$SamlSignatureAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$SamlSignatureAlgorithm fromJson$Enum$SamlSignatureAlgorithm(String value) {
  switch (value) {
    case r'RSA_SHA1':
      return Enum$SamlSignatureAlgorithm.RSA_SHA1;
    case r'RSA_SHA256':
      return Enum$SamlSignatureAlgorithm.RSA_SHA256;
    case r'RSA_SHA384':
      return Enum$SamlSignatureAlgorithm.RSA_SHA384;
    case r'RSA_SHA512':
      return Enum$SamlSignatureAlgorithm.RSA_SHA512;
    default:
      return Enum$SamlSignatureAlgorithm.$unknown;
  }
}

enum Enum$SavedReplyOrderField { UPDATED_AT, $unknown }

String toJson$Enum$SavedReplyOrderField(Enum$SavedReplyOrderField e) {
  switch (e) {
    case Enum$SavedReplyOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SavedReplyOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SavedReplyOrderField fromJson$Enum$SavedReplyOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$SavedReplyOrderField.UPDATED_AT;
    default:
      return Enum$SavedReplyOrderField.$unknown;
  }
}

enum Enum$SearchType { DISCUSSION, ISSUE, REPOSITORY, USER, $unknown }

String toJson$Enum$SearchType(Enum$SearchType e) {
  switch (e) {
    case Enum$SearchType.DISCUSSION:
      return r'DISCUSSION';
    case Enum$SearchType.ISSUE:
      return r'ISSUE';
    case Enum$SearchType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$SearchType.USER:
      return r'USER';
    case Enum$SearchType.$unknown:
      return r'$unknown';
  }
}

Enum$SearchType fromJson$Enum$SearchType(String value) {
  switch (value) {
    case r'DISCUSSION':
      return Enum$SearchType.DISCUSSION;
    case r'ISSUE':
      return Enum$SearchType.ISSUE;
    case r'REPOSITORY':
      return Enum$SearchType.REPOSITORY;
    case r'USER':
      return Enum$SearchType.USER;
    default:
      return Enum$SearchType.$unknown;
  }
}

enum Enum$SecurityAdvisoryClassification { GENERAL, MALWARE, $unknown }

String toJson$Enum$SecurityAdvisoryClassification(
    Enum$SecurityAdvisoryClassification e) {
  switch (e) {
    case Enum$SecurityAdvisoryClassification.GENERAL:
      return r'GENERAL';
    case Enum$SecurityAdvisoryClassification.MALWARE:
      return r'MALWARE';
    case Enum$SecurityAdvisoryClassification.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryClassification
    fromJson$Enum$SecurityAdvisoryClassification(String value) {
  switch (value) {
    case r'GENERAL':
      return Enum$SecurityAdvisoryClassification.GENERAL;
    case r'MALWARE':
      return Enum$SecurityAdvisoryClassification.MALWARE;
    default:
      return Enum$SecurityAdvisoryClassification.$unknown;
  }
}

enum Enum$SecurityAdvisoryEcosystem {
  ACTIONS,
  COMPOSER,
  ERLANG,
  GO,
  MAVEN,
  NPM,
  NUGET,
  PIP,
  PUB,
  RUBYGEMS,
  RUST,
  $unknown
}

String toJson$Enum$SecurityAdvisoryEcosystem(Enum$SecurityAdvisoryEcosystem e) {
  switch (e) {
    case Enum$SecurityAdvisoryEcosystem.ACTIONS:
      return r'ACTIONS';
    case Enum$SecurityAdvisoryEcosystem.COMPOSER:
      return r'COMPOSER';
    case Enum$SecurityAdvisoryEcosystem.ERLANG:
      return r'ERLANG';
    case Enum$SecurityAdvisoryEcosystem.GO:
      return r'GO';
    case Enum$SecurityAdvisoryEcosystem.MAVEN:
      return r'MAVEN';
    case Enum$SecurityAdvisoryEcosystem.NPM:
      return r'NPM';
    case Enum$SecurityAdvisoryEcosystem.NUGET:
      return r'NUGET';
    case Enum$SecurityAdvisoryEcosystem.PIP:
      return r'PIP';
    case Enum$SecurityAdvisoryEcosystem.PUB:
      return r'PUB';
    case Enum$SecurityAdvisoryEcosystem.RUBYGEMS:
      return r'RUBYGEMS';
    case Enum$SecurityAdvisoryEcosystem.RUST:
      return r'RUST';
    case Enum$SecurityAdvisoryEcosystem.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryEcosystem fromJson$Enum$SecurityAdvisoryEcosystem(
    String value) {
  switch (value) {
    case r'ACTIONS':
      return Enum$SecurityAdvisoryEcosystem.ACTIONS;
    case r'COMPOSER':
      return Enum$SecurityAdvisoryEcosystem.COMPOSER;
    case r'ERLANG':
      return Enum$SecurityAdvisoryEcosystem.ERLANG;
    case r'GO':
      return Enum$SecurityAdvisoryEcosystem.GO;
    case r'MAVEN':
      return Enum$SecurityAdvisoryEcosystem.MAVEN;
    case r'NPM':
      return Enum$SecurityAdvisoryEcosystem.NPM;
    case r'NUGET':
      return Enum$SecurityAdvisoryEcosystem.NUGET;
    case r'PIP':
      return Enum$SecurityAdvisoryEcosystem.PIP;
    case r'PUB':
      return Enum$SecurityAdvisoryEcosystem.PUB;
    case r'RUBYGEMS':
      return Enum$SecurityAdvisoryEcosystem.RUBYGEMS;
    case r'RUST':
      return Enum$SecurityAdvisoryEcosystem.RUST;
    default:
      return Enum$SecurityAdvisoryEcosystem.$unknown;
  }
}

enum Enum$SecurityAdvisoryIdentifierType { CVE, GHSA, $unknown }

String toJson$Enum$SecurityAdvisoryIdentifierType(
    Enum$SecurityAdvisoryIdentifierType e) {
  switch (e) {
    case Enum$SecurityAdvisoryIdentifierType.CVE:
      return r'CVE';
    case Enum$SecurityAdvisoryIdentifierType.GHSA:
      return r'GHSA';
    case Enum$SecurityAdvisoryIdentifierType.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryIdentifierType
    fromJson$Enum$SecurityAdvisoryIdentifierType(String value) {
  switch (value) {
    case r'CVE':
      return Enum$SecurityAdvisoryIdentifierType.CVE;
    case r'GHSA':
      return Enum$SecurityAdvisoryIdentifierType.GHSA;
    default:
      return Enum$SecurityAdvisoryIdentifierType.$unknown;
  }
}

enum Enum$SecurityAdvisoryOrderField { PUBLISHED_AT, UPDATED_AT, $unknown }

String toJson$Enum$SecurityAdvisoryOrderField(
    Enum$SecurityAdvisoryOrderField e) {
  switch (e) {
    case Enum$SecurityAdvisoryOrderField.PUBLISHED_AT:
      return r'PUBLISHED_AT';
    case Enum$SecurityAdvisoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SecurityAdvisoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisoryOrderField fromJson$Enum$SecurityAdvisoryOrderField(
    String value) {
  switch (value) {
    case r'PUBLISHED_AT':
      return Enum$SecurityAdvisoryOrderField.PUBLISHED_AT;
    case r'UPDATED_AT':
      return Enum$SecurityAdvisoryOrderField.UPDATED_AT;
    default:
      return Enum$SecurityAdvisoryOrderField.$unknown;
  }
}

enum Enum$SecurityAdvisorySeverity { CRITICAL, HIGH, LOW, MODERATE, $unknown }

String toJson$Enum$SecurityAdvisorySeverity(Enum$SecurityAdvisorySeverity e) {
  switch (e) {
    case Enum$SecurityAdvisorySeverity.CRITICAL:
      return r'CRITICAL';
    case Enum$SecurityAdvisorySeverity.HIGH:
      return r'HIGH';
    case Enum$SecurityAdvisorySeverity.LOW:
      return r'LOW';
    case Enum$SecurityAdvisorySeverity.MODERATE:
      return r'MODERATE';
    case Enum$SecurityAdvisorySeverity.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityAdvisorySeverity fromJson$Enum$SecurityAdvisorySeverity(
    String value) {
  switch (value) {
    case r'CRITICAL':
      return Enum$SecurityAdvisorySeverity.CRITICAL;
    case r'HIGH':
      return Enum$SecurityAdvisorySeverity.HIGH;
    case r'LOW':
      return Enum$SecurityAdvisorySeverity.LOW;
    case r'MODERATE':
      return Enum$SecurityAdvisorySeverity.MODERATE;
    default:
      return Enum$SecurityAdvisorySeverity.$unknown;
  }
}

enum Enum$SecurityVulnerabilityOrderField { UPDATED_AT, $unknown }

String toJson$Enum$SecurityVulnerabilityOrderField(
    Enum$SecurityVulnerabilityOrderField e) {
  switch (e) {
    case Enum$SecurityVulnerabilityOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$SecurityVulnerabilityOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SecurityVulnerabilityOrderField
    fromJson$Enum$SecurityVulnerabilityOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$SecurityVulnerabilityOrderField.UPDATED_AT;
    default:
      return Enum$SecurityVulnerabilityOrderField.$unknown;
  }
}

enum Enum$SocialAccountProvider {
  FACEBOOK,
  GENERIC,
  HOMETOWN,
  INSTAGRAM,
  LINKEDIN,
  MASTODON,
  REDDIT,
  TWITCH,
  TWITTER,
  YOUTUBE,
  $unknown
}

String toJson$Enum$SocialAccountProvider(Enum$SocialAccountProvider e) {
  switch (e) {
    case Enum$SocialAccountProvider.FACEBOOK:
      return r'FACEBOOK';
    case Enum$SocialAccountProvider.GENERIC:
      return r'GENERIC';
    case Enum$SocialAccountProvider.HOMETOWN:
      return r'HOMETOWN';
    case Enum$SocialAccountProvider.INSTAGRAM:
      return r'INSTAGRAM';
    case Enum$SocialAccountProvider.LINKEDIN:
      return r'LINKEDIN';
    case Enum$SocialAccountProvider.MASTODON:
      return r'MASTODON';
    case Enum$SocialAccountProvider.REDDIT:
      return r'REDDIT';
    case Enum$SocialAccountProvider.TWITCH:
      return r'TWITCH';
    case Enum$SocialAccountProvider.TWITTER:
      return r'TWITTER';
    case Enum$SocialAccountProvider.YOUTUBE:
      return r'YOUTUBE';
    case Enum$SocialAccountProvider.$unknown:
      return r'$unknown';
  }
}

Enum$SocialAccountProvider fromJson$Enum$SocialAccountProvider(String value) {
  switch (value) {
    case r'FACEBOOK':
      return Enum$SocialAccountProvider.FACEBOOK;
    case r'GENERIC':
      return Enum$SocialAccountProvider.GENERIC;
    case r'HOMETOWN':
      return Enum$SocialAccountProvider.HOMETOWN;
    case r'INSTAGRAM':
      return Enum$SocialAccountProvider.INSTAGRAM;
    case r'LINKEDIN':
      return Enum$SocialAccountProvider.LINKEDIN;
    case r'MASTODON':
      return Enum$SocialAccountProvider.MASTODON;
    case r'REDDIT':
      return Enum$SocialAccountProvider.REDDIT;
    case r'TWITCH':
      return Enum$SocialAccountProvider.TWITCH;
    case r'TWITTER':
      return Enum$SocialAccountProvider.TWITTER;
    case r'YOUTUBE':
      return Enum$SocialAccountProvider.YOUTUBE;
    default:
      return Enum$SocialAccountProvider.$unknown;
  }
}

enum Enum$SponsorOrderField { LOGIN, RELEVANCE, $unknown }

String toJson$Enum$SponsorOrderField(Enum$SponsorOrderField e) {
  switch (e) {
    case Enum$SponsorOrderField.LOGIN:
      return r'LOGIN';
    case Enum$SponsorOrderField.RELEVANCE:
      return r'RELEVANCE';
    case Enum$SponsorOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorOrderField fromJson$Enum$SponsorOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$SponsorOrderField.LOGIN;
    case r'RELEVANCE':
      return Enum$SponsorOrderField.RELEVANCE;
    default:
      return Enum$SponsorOrderField.$unknown;
  }
}

enum Enum$SponsorableOrderField { LOGIN, $unknown }

String toJson$Enum$SponsorableOrderField(Enum$SponsorableOrderField e) {
  switch (e) {
    case Enum$SponsorableOrderField.LOGIN:
      return r'LOGIN';
    case Enum$SponsorableOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorableOrderField fromJson$Enum$SponsorableOrderField(String value) {
  switch (value) {
    case r'LOGIN':
      return Enum$SponsorableOrderField.LOGIN;
    default:
      return Enum$SponsorableOrderField.$unknown;
  }
}

enum Enum$SponsorsActivityAction {
  CANCELLED_SPONSORSHIP,
  NEW_SPONSORSHIP,
  PENDING_CHANGE,
  REFUND,
  SPONSOR_MATCH_DISABLED,
  TIER_CHANGE,
  $unknown
}

String toJson$Enum$SponsorsActivityAction(Enum$SponsorsActivityAction e) {
  switch (e) {
    case Enum$SponsorsActivityAction.CANCELLED_SPONSORSHIP:
      return r'CANCELLED_SPONSORSHIP';
    case Enum$SponsorsActivityAction.NEW_SPONSORSHIP:
      return r'NEW_SPONSORSHIP';
    case Enum$SponsorsActivityAction.PENDING_CHANGE:
      return r'PENDING_CHANGE';
    case Enum$SponsorsActivityAction.REFUND:
      return r'REFUND';
    case Enum$SponsorsActivityAction.SPONSOR_MATCH_DISABLED:
      return r'SPONSOR_MATCH_DISABLED';
    case Enum$SponsorsActivityAction.TIER_CHANGE:
      return r'TIER_CHANGE';
    case Enum$SponsorsActivityAction.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityAction fromJson$Enum$SponsorsActivityAction(String value) {
  switch (value) {
    case r'CANCELLED_SPONSORSHIP':
      return Enum$SponsorsActivityAction.CANCELLED_SPONSORSHIP;
    case r'NEW_SPONSORSHIP':
      return Enum$SponsorsActivityAction.NEW_SPONSORSHIP;
    case r'PENDING_CHANGE':
      return Enum$SponsorsActivityAction.PENDING_CHANGE;
    case r'REFUND':
      return Enum$SponsorsActivityAction.REFUND;
    case r'SPONSOR_MATCH_DISABLED':
      return Enum$SponsorsActivityAction.SPONSOR_MATCH_DISABLED;
    case r'TIER_CHANGE':
      return Enum$SponsorsActivityAction.TIER_CHANGE;
    default:
      return Enum$SponsorsActivityAction.$unknown;
  }
}

enum Enum$SponsorsActivityOrderField { TIMESTAMP, $unknown }

String toJson$Enum$SponsorsActivityOrderField(
    Enum$SponsorsActivityOrderField e) {
  switch (e) {
    case Enum$SponsorsActivityOrderField.TIMESTAMP:
      return r'TIMESTAMP';
    case Enum$SponsorsActivityOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityOrderField fromJson$Enum$SponsorsActivityOrderField(
    String value) {
  switch (value) {
    case r'TIMESTAMP':
      return Enum$SponsorsActivityOrderField.TIMESTAMP;
    default:
      return Enum$SponsorsActivityOrderField.$unknown;
  }
}

enum Enum$SponsorsActivityPeriod { ALL, DAY, MONTH, WEEK, $unknown }

String toJson$Enum$SponsorsActivityPeriod(Enum$SponsorsActivityPeriod e) {
  switch (e) {
    case Enum$SponsorsActivityPeriod.ALL:
      return r'ALL';
    case Enum$SponsorsActivityPeriod.DAY:
      return r'DAY';
    case Enum$SponsorsActivityPeriod.MONTH:
      return r'MONTH';
    case Enum$SponsorsActivityPeriod.WEEK:
      return r'WEEK';
    case Enum$SponsorsActivityPeriod.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsActivityPeriod fromJson$Enum$SponsorsActivityPeriod(String value) {
  switch (value) {
    case r'ALL':
      return Enum$SponsorsActivityPeriod.ALL;
    case r'DAY':
      return Enum$SponsorsActivityPeriod.DAY;
    case r'MONTH':
      return Enum$SponsorsActivityPeriod.MONTH;
    case r'WEEK':
      return Enum$SponsorsActivityPeriod.WEEK;
    default:
      return Enum$SponsorsActivityPeriod.$unknown;
  }
}

enum Enum$SponsorsCountryOrRegionCode {
  AD,
  AE,
  AF,
  AG,
  AI,
  AL,
  AM,
  AO,
  AQ,
  AR,
  AS,
  AT,
  AU,
  AW,
  AX,
  AZ,
  BA,
  BB,
  BD,
  BE,
  BF,
  BG,
  BH,
  BI,
  BJ,
  BL,
  BM,
  BN,
  BO,
  BQ,
  BR,
  BS,
  BT,
  BV,
  BW,
  BY,
  BZ,
  CA,
  CC,
  CD,
  CF,
  CG,
  CH,
  CI,
  CK,
  CL,
  CM,
  CN,
  CO,
  CR,
  CV,
  CW,
  CX,
  CY,
  CZ,
  DE,
  DJ,
  DK,
  DM,
  DO,
  DZ,
  EC,
  EE,
  EG,
  EH,
  ER,
  ES,
  ET,
  FI,
  FJ,
  FK,
  FM,
  FO,
  FR,
  GA,
  GB,
  GD,
  GE,
  GF,
  GG,
  GH,
  GI,
  GL,
  GM,
  GN,
  GP,
  GQ,
  GR,
  GS,
  GT,
  GU,
  GW,
  GY,
  HK,
  HM,
  HN,
  HR,
  HT,
  HU,
  ID,
  IE,
  IL,
  IM,
  IN,
  IO,
  IQ,
  IR,
  IS,
  IT,
  JE,
  JM,
  JO,
  JP,
  KE,
  KG,
  KH,
  KI,
  KM,
  KN,
  KR,
  KW,
  KY,
  KZ,
  LA,
  LB,
  LC,
  LI,
  LK,
  LR,
  LS,
  LT,
  LU,
  LV,
  LY,
  MA,
  MC,
  MD,
  ME,
  MF,
  MG,
  MH,
  MK,
  ML,
  MM,
  MN,
  MO,
  MP,
  MQ,
  MR,
  MS,
  MT,
  MU,
  MV,
  MW,
  MX,
  MY,
  MZ,
  NA,
  NC,
  NE,
  NF,
  NG,
  NI,
  NL,
  NO,
  NP,
  NR,
  NU,
  NZ,
  OM,
  PA,
  PE,
  PF,
  PG,
  PH,
  PK,
  PL,
  PM,
  PN,
  PR,
  PS,
  PT,
  PW,
  PY,
  QA,
  RE,
  RO,
  RS,
  RU,
  RW,
  SA,
  SB,
  SC,
  SD,
  SE,
  SG,
  SH,
  SI,
  SJ,
  SK,
  SL,
  SM,
  SN,
  SO,
  SR,
  SS,
  ST,
  SV,
  SX,
  SZ,
  TC,
  TD,
  TF,
  TG,
  TH,
  TJ,
  TK,
  TL,
  TM,
  TN,
  TO,
  TR,
  TT,
  TV,
  TW,
  TZ,
  UA,
  UG,
  UM,
  US,
  UY,
  UZ,
  VA,
  VC,
  VE,
  VG,
  VI,
  VN,
  VU,
  WF,
  WS,
  YE,
  YT,
  ZA,
  ZM,
  ZW,
  $unknown
}

String toJson$Enum$SponsorsCountryOrRegionCode(
    Enum$SponsorsCountryOrRegionCode e) {
  switch (e) {
    case Enum$SponsorsCountryOrRegionCode.AD:
      return r'AD';
    case Enum$SponsorsCountryOrRegionCode.AE:
      return r'AE';
    case Enum$SponsorsCountryOrRegionCode.AF:
      return r'AF';
    case Enum$SponsorsCountryOrRegionCode.AG:
      return r'AG';
    case Enum$SponsorsCountryOrRegionCode.AI:
      return r'AI';
    case Enum$SponsorsCountryOrRegionCode.AL:
      return r'AL';
    case Enum$SponsorsCountryOrRegionCode.AM:
      return r'AM';
    case Enum$SponsorsCountryOrRegionCode.AO:
      return r'AO';
    case Enum$SponsorsCountryOrRegionCode.AQ:
      return r'AQ';
    case Enum$SponsorsCountryOrRegionCode.AR:
      return r'AR';
    case Enum$SponsorsCountryOrRegionCode.AS:
      return r'AS';
    case Enum$SponsorsCountryOrRegionCode.AT:
      return r'AT';
    case Enum$SponsorsCountryOrRegionCode.AU:
      return r'AU';
    case Enum$SponsorsCountryOrRegionCode.AW:
      return r'AW';
    case Enum$SponsorsCountryOrRegionCode.AX:
      return r'AX';
    case Enum$SponsorsCountryOrRegionCode.AZ:
      return r'AZ';
    case Enum$SponsorsCountryOrRegionCode.BA:
      return r'BA';
    case Enum$SponsorsCountryOrRegionCode.BB:
      return r'BB';
    case Enum$SponsorsCountryOrRegionCode.BD:
      return r'BD';
    case Enum$SponsorsCountryOrRegionCode.BE:
      return r'BE';
    case Enum$SponsorsCountryOrRegionCode.BF:
      return r'BF';
    case Enum$SponsorsCountryOrRegionCode.BG:
      return r'BG';
    case Enum$SponsorsCountryOrRegionCode.BH:
      return r'BH';
    case Enum$SponsorsCountryOrRegionCode.BI:
      return r'BI';
    case Enum$SponsorsCountryOrRegionCode.BJ:
      return r'BJ';
    case Enum$SponsorsCountryOrRegionCode.BL:
      return r'BL';
    case Enum$SponsorsCountryOrRegionCode.BM:
      return r'BM';
    case Enum$SponsorsCountryOrRegionCode.BN:
      return r'BN';
    case Enum$SponsorsCountryOrRegionCode.BO:
      return r'BO';
    case Enum$SponsorsCountryOrRegionCode.BQ:
      return r'BQ';
    case Enum$SponsorsCountryOrRegionCode.BR:
      return r'BR';
    case Enum$SponsorsCountryOrRegionCode.BS:
      return r'BS';
    case Enum$SponsorsCountryOrRegionCode.BT:
      return r'BT';
    case Enum$SponsorsCountryOrRegionCode.BV:
      return r'BV';
    case Enum$SponsorsCountryOrRegionCode.BW:
      return r'BW';
    case Enum$SponsorsCountryOrRegionCode.BY:
      return r'BY';
    case Enum$SponsorsCountryOrRegionCode.BZ:
      return r'BZ';
    case Enum$SponsorsCountryOrRegionCode.CA:
      return r'CA';
    case Enum$SponsorsCountryOrRegionCode.CC:
      return r'CC';
    case Enum$SponsorsCountryOrRegionCode.CD:
      return r'CD';
    case Enum$SponsorsCountryOrRegionCode.CF:
      return r'CF';
    case Enum$SponsorsCountryOrRegionCode.CG:
      return r'CG';
    case Enum$SponsorsCountryOrRegionCode.CH:
      return r'CH';
    case Enum$SponsorsCountryOrRegionCode.CI:
      return r'CI';
    case Enum$SponsorsCountryOrRegionCode.CK:
      return r'CK';
    case Enum$SponsorsCountryOrRegionCode.CL:
      return r'CL';
    case Enum$SponsorsCountryOrRegionCode.CM:
      return r'CM';
    case Enum$SponsorsCountryOrRegionCode.CN:
      return r'CN';
    case Enum$SponsorsCountryOrRegionCode.CO:
      return r'CO';
    case Enum$SponsorsCountryOrRegionCode.CR:
      return r'CR';
    case Enum$SponsorsCountryOrRegionCode.CV:
      return r'CV';
    case Enum$SponsorsCountryOrRegionCode.CW:
      return r'CW';
    case Enum$SponsorsCountryOrRegionCode.CX:
      return r'CX';
    case Enum$SponsorsCountryOrRegionCode.CY:
      return r'CY';
    case Enum$SponsorsCountryOrRegionCode.CZ:
      return r'CZ';
    case Enum$SponsorsCountryOrRegionCode.DE:
      return r'DE';
    case Enum$SponsorsCountryOrRegionCode.DJ:
      return r'DJ';
    case Enum$SponsorsCountryOrRegionCode.DK:
      return r'DK';
    case Enum$SponsorsCountryOrRegionCode.DM:
      return r'DM';
    case Enum$SponsorsCountryOrRegionCode.DO:
      return r'DO';
    case Enum$SponsorsCountryOrRegionCode.DZ:
      return r'DZ';
    case Enum$SponsorsCountryOrRegionCode.EC:
      return r'EC';
    case Enum$SponsorsCountryOrRegionCode.EE:
      return r'EE';
    case Enum$SponsorsCountryOrRegionCode.EG:
      return r'EG';
    case Enum$SponsorsCountryOrRegionCode.EH:
      return r'EH';
    case Enum$SponsorsCountryOrRegionCode.ER:
      return r'ER';
    case Enum$SponsorsCountryOrRegionCode.ES:
      return r'ES';
    case Enum$SponsorsCountryOrRegionCode.ET:
      return r'ET';
    case Enum$SponsorsCountryOrRegionCode.FI:
      return r'FI';
    case Enum$SponsorsCountryOrRegionCode.FJ:
      return r'FJ';
    case Enum$SponsorsCountryOrRegionCode.FK:
      return r'FK';
    case Enum$SponsorsCountryOrRegionCode.FM:
      return r'FM';
    case Enum$SponsorsCountryOrRegionCode.FO:
      return r'FO';
    case Enum$SponsorsCountryOrRegionCode.FR:
      return r'FR';
    case Enum$SponsorsCountryOrRegionCode.GA:
      return r'GA';
    case Enum$SponsorsCountryOrRegionCode.GB:
      return r'GB';
    case Enum$SponsorsCountryOrRegionCode.GD:
      return r'GD';
    case Enum$SponsorsCountryOrRegionCode.GE:
      return r'GE';
    case Enum$SponsorsCountryOrRegionCode.GF:
      return r'GF';
    case Enum$SponsorsCountryOrRegionCode.GG:
      return r'GG';
    case Enum$SponsorsCountryOrRegionCode.GH:
      return r'GH';
    case Enum$SponsorsCountryOrRegionCode.GI:
      return r'GI';
    case Enum$SponsorsCountryOrRegionCode.GL:
      return r'GL';
    case Enum$SponsorsCountryOrRegionCode.GM:
      return r'GM';
    case Enum$SponsorsCountryOrRegionCode.GN:
      return r'GN';
    case Enum$SponsorsCountryOrRegionCode.GP:
      return r'GP';
    case Enum$SponsorsCountryOrRegionCode.GQ:
      return r'GQ';
    case Enum$SponsorsCountryOrRegionCode.GR:
      return r'GR';
    case Enum$SponsorsCountryOrRegionCode.GS:
      return r'GS';
    case Enum$SponsorsCountryOrRegionCode.GT:
      return r'GT';
    case Enum$SponsorsCountryOrRegionCode.GU:
      return r'GU';
    case Enum$SponsorsCountryOrRegionCode.GW:
      return r'GW';
    case Enum$SponsorsCountryOrRegionCode.GY:
      return r'GY';
    case Enum$SponsorsCountryOrRegionCode.HK:
      return r'HK';
    case Enum$SponsorsCountryOrRegionCode.HM:
      return r'HM';
    case Enum$SponsorsCountryOrRegionCode.HN:
      return r'HN';
    case Enum$SponsorsCountryOrRegionCode.HR:
      return r'HR';
    case Enum$SponsorsCountryOrRegionCode.HT:
      return r'HT';
    case Enum$SponsorsCountryOrRegionCode.HU:
      return r'HU';
    case Enum$SponsorsCountryOrRegionCode.ID:
      return r'ID';
    case Enum$SponsorsCountryOrRegionCode.IE:
      return r'IE';
    case Enum$SponsorsCountryOrRegionCode.IL:
      return r'IL';
    case Enum$SponsorsCountryOrRegionCode.IM:
      return r'IM';
    case Enum$SponsorsCountryOrRegionCode.IN:
      return r'IN';
    case Enum$SponsorsCountryOrRegionCode.IO:
      return r'IO';
    case Enum$SponsorsCountryOrRegionCode.IQ:
      return r'IQ';
    case Enum$SponsorsCountryOrRegionCode.IR:
      return r'IR';
    case Enum$SponsorsCountryOrRegionCode.IS:
      return r'IS';
    case Enum$SponsorsCountryOrRegionCode.IT:
      return r'IT';
    case Enum$SponsorsCountryOrRegionCode.JE:
      return r'JE';
    case Enum$SponsorsCountryOrRegionCode.JM:
      return r'JM';
    case Enum$SponsorsCountryOrRegionCode.JO:
      return r'JO';
    case Enum$SponsorsCountryOrRegionCode.JP:
      return r'JP';
    case Enum$SponsorsCountryOrRegionCode.KE:
      return r'KE';
    case Enum$SponsorsCountryOrRegionCode.KG:
      return r'KG';
    case Enum$SponsorsCountryOrRegionCode.KH:
      return r'KH';
    case Enum$SponsorsCountryOrRegionCode.KI:
      return r'KI';
    case Enum$SponsorsCountryOrRegionCode.KM:
      return r'KM';
    case Enum$SponsorsCountryOrRegionCode.KN:
      return r'KN';
    case Enum$SponsorsCountryOrRegionCode.KR:
      return r'KR';
    case Enum$SponsorsCountryOrRegionCode.KW:
      return r'KW';
    case Enum$SponsorsCountryOrRegionCode.KY:
      return r'KY';
    case Enum$SponsorsCountryOrRegionCode.KZ:
      return r'KZ';
    case Enum$SponsorsCountryOrRegionCode.LA:
      return r'LA';
    case Enum$SponsorsCountryOrRegionCode.LB:
      return r'LB';
    case Enum$SponsorsCountryOrRegionCode.LC:
      return r'LC';
    case Enum$SponsorsCountryOrRegionCode.LI:
      return r'LI';
    case Enum$SponsorsCountryOrRegionCode.LK:
      return r'LK';
    case Enum$SponsorsCountryOrRegionCode.LR:
      return r'LR';
    case Enum$SponsorsCountryOrRegionCode.LS:
      return r'LS';
    case Enum$SponsorsCountryOrRegionCode.LT:
      return r'LT';
    case Enum$SponsorsCountryOrRegionCode.LU:
      return r'LU';
    case Enum$SponsorsCountryOrRegionCode.LV:
      return r'LV';
    case Enum$SponsorsCountryOrRegionCode.LY:
      return r'LY';
    case Enum$SponsorsCountryOrRegionCode.MA:
      return r'MA';
    case Enum$SponsorsCountryOrRegionCode.MC:
      return r'MC';
    case Enum$SponsorsCountryOrRegionCode.MD:
      return r'MD';
    case Enum$SponsorsCountryOrRegionCode.ME:
      return r'ME';
    case Enum$SponsorsCountryOrRegionCode.MF:
      return r'MF';
    case Enum$SponsorsCountryOrRegionCode.MG:
      return r'MG';
    case Enum$SponsorsCountryOrRegionCode.MH:
      return r'MH';
    case Enum$SponsorsCountryOrRegionCode.MK:
      return r'MK';
    case Enum$SponsorsCountryOrRegionCode.ML:
      return r'ML';
    case Enum$SponsorsCountryOrRegionCode.MM:
      return r'MM';
    case Enum$SponsorsCountryOrRegionCode.MN:
      return r'MN';
    case Enum$SponsorsCountryOrRegionCode.MO:
      return r'MO';
    case Enum$SponsorsCountryOrRegionCode.MP:
      return r'MP';
    case Enum$SponsorsCountryOrRegionCode.MQ:
      return r'MQ';
    case Enum$SponsorsCountryOrRegionCode.MR:
      return r'MR';
    case Enum$SponsorsCountryOrRegionCode.MS:
      return r'MS';
    case Enum$SponsorsCountryOrRegionCode.MT:
      return r'MT';
    case Enum$SponsorsCountryOrRegionCode.MU:
      return r'MU';
    case Enum$SponsorsCountryOrRegionCode.MV:
      return r'MV';
    case Enum$SponsorsCountryOrRegionCode.MW:
      return r'MW';
    case Enum$SponsorsCountryOrRegionCode.MX:
      return r'MX';
    case Enum$SponsorsCountryOrRegionCode.MY:
      return r'MY';
    case Enum$SponsorsCountryOrRegionCode.MZ:
      return r'MZ';
    case Enum$SponsorsCountryOrRegionCode.NA:
      return r'NA';
    case Enum$SponsorsCountryOrRegionCode.NC:
      return r'NC';
    case Enum$SponsorsCountryOrRegionCode.NE:
      return r'NE';
    case Enum$SponsorsCountryOrRegionCode.NF:
      return r'NF';
    case Enum$SponsorsCountryOrRegionCode.NG:
      return r'NG';
    case Enum$SponsorsCountryOrRegionCode.NI:
      return r'NI';
    case Enum$SponsorsCountryOrRegionCode.NL:
      return r'NL';
    case Enum$SponsorsCountryOrRegionCode.NO:
      return r'NO';
    case Enum$SponsorsCountryOrRegionCode.NP:
      return r'NP';
    case Enum$SponsorsCountryOrRegionCode.NR:
      return r'NR';
    case Enum$SponsorsCountryOrRegionCode.NU:
      return r'NU';
    case Enum$SponsorsCountryOrRegionCode.NZ:
      return r'NZ';
    case Enum$SponsorsCountryOrRegionCode.OM:
      return r'OM';
    case Enum$SponsorsCountryOrRegionCode.PA:
      return r'PA';
    case Enum$SponsorsCountryOrRegionCode.PE:
      return r'PE';
    case Enum$SponsorsCountryOrRegionCode.PF:
      return r'PF';
    case Enum$SponsorsCountryOrRegionCode.PG:
      return r'PG';
    case Enum$SponsorsCountryOrRegionCode.PH:
      return r'PH';
    case Enum$SponsorsCountryOrRegionCode.PK:
      return r'PK';
    case Enum$SponsorsCountryOrRegionCode.PL:
      return r'PL';
    case Enum$SponsorsCountryOrRegionCode.PM:
      return r'PM';
    case Enum$SponsorsCountryOrRegionCode.PN:
      return r'PN';
    case Enum$SponsorsCountryOrRegionCode.PR:
      return r'PR';
    case Enum$SponsorsCountryOrRegionCode.PS:
      return r'PS';
    case Enum$SponsorsCountryOrRegionCode.PT:
      return r'PT';
    case Enum$SponsorsCountryOrRegionCode.PW:
      return r'PW';
    case Enum$SponsorsCountryOrRegionCode.PY:
      return r'PY';
    case Enum$SponsorsCountryOrRegionCode.QA:
      return r'QA';
    case Enum$SponsorsCountryOrRegionCode.RE:
      return r'RE';
    case Enum$SponsorsCountryOrRegionCode.RO:
      return r'RO';
    case Enum$SponsorsCountryOrRegionCode.RS:
      return r'RS';
    case Enum$SponsorsCountryOrRegionCode.RU:
      return r'RU';
    case Enum$SponsorsCountryOrRegionCode.RW:
      return r'RW';
    case Enum$SponsorsCountryOrRegionCode.SA:
      return r'SA';
    case Enum$SponsorsCountryOrRegionCode.SB:
      return r'SB';
    case Enum$SponsorsCountryOrRegionCode.SC:
      return r'SC';
    case Enum$SponsorsCountryOrRegionCode.SD:
      return r'SD';
    case Enum$SponsorsCountryOrRegionCode.SE:
      return r'SE';
    case Enum$SponsorsCountryOrRegionCode.SG:
      return r'SG';
    case Enum$SponsorsCountryOrRegionCode.SH:
      return r'SH';
    case Enum$SponsorsCountryOrRegionCode.SI:
      return r'SI';
    case Enum$SponsorsCountryOrRegionCode.SJ:
      return r'SJ';
    case Enum$SponsorsCountryOrRegionCode.SK:
      return r'SK';
    case Enum$SponsorsCountryOrRegionCode.SL:
      return r'SL';
    case Enum$SponsorsCountryOrRegionCode.SM:
      return r'SM';
    case Enum$SponsorsCountryOrRegionCode.SN:
      return r'SN';
    case Enum$SponsorsCountryOrRegionCode.SO:
      return r'SO';
    case Enum$SponsorsCountryOrRegionCode.SR:
      return r'SR';
    case Enum$SponsorsCountryOrRegionCode.SS:
      return r'SS';
    case Enum$SponsorsCountryOrRegionCode.ST:
      return r'ST';
    case Enum$SponsorsCountryOrRegionCode.SV:
      return r'SV';
    case Enum$SponsorsCountryOrRegionCode.SX:
      return r'SX';
    case Enum$SponsorsCountryOrRegionCode.SZ:
      return r'SZ';
    case Enum$SponsorsCountryOrRegionCode.TC:
      return r'TC';
    case Enum$SponsorsCountryOrRegionCode.TD:
      return r'TD';
    case Enum$SponsorsCountryOrRegionCode.TF:
      return r'TF';
    case Enum$SponsorsCountryOrRegionCode.TG:
      return r'TG';
    case Enum$SponsorsCountryOrRegionCode.TH:
      return r'TH';
    case Enum$SponsorsCountryOrRegionCode.TJ:
      return r'TJ';
    case Enum$SponsorsCountryOrRegionCode.TK:
      return r'TK';
    case Enum$SponsorsCountryOrRegionCode.TL:
      return r'TL';
    case Enum$SponsorsCountryOrRegionCode.TM:
      return r'TM';
    case Enum$SponsorsCountryOrRegionCode.TN:
      return r'TN';
    case Enum$SponsorsCountryOrRegionCode.TO:
      return r'TO';
    case Enum$SponsorsCountryOrRegionCode.TR:
      return r'TR';
    case Enum$SponsorsCountryOrRegionCode.TT:
      return r'TT';
    case Enum$SponsorsCountryOrRegionCode.TV:
      return r'TV';
    case Enum$SponsorsCountryOrRegionCode.TW:
      return r'TW';
    case Enum$SponsorsCountryOrRegionCode.TZ:
      return r'TZ';
    case Enum$SponsorsCountryOrRegionCode.UA:
      return r'UA';
    case Enum$SponsorsCountryOrRegionCode.UG:
      return r'UG';
    case Enum$SponsorsCountryOrRegionCode.UM:
      return r'UM';
    case Enum$SponsorsCountryOrRegionCode.US:
      return r'US';
    case Enum$SponsorsCountryOrRegionCode.UY:
      return r'UY';
    case Enum$SponsorsCountryOrRegionCode.UZ:
      return r'UZ';
    case Enum$SponsorsCountryOrRegionCode.VA:
      return r'VA';
    case Enum$SponsorsCountryOrRegionCode.VC:
      return r'VC';
    case Enum$SponsorsCountryOrRegionCode.VE:
      return r'VE';
    case Enum$SponsorsCountryOrRegionCode.VG:
      return r'VG';
    case Enum$SponsorsCountryOrRegionCode.VI:
      return r'VI';
    case Enum$SponsorsCountryOrRegionCode.VN:
      return r'VN';
    case Enum$SponsorsCountryOrRegionCode.VU:
      return r'VU';
    case Enum$SponsorsCountryOrRegionCode.WF:
      return r'WF';
    case Enum$SponsorsCountryOrRegionCode.WS:
      return r'WS';
    case Enum$SponsorsCountryOrRegionCode.YE:
      return r'YE';
    case Enum$SponsorsCountryOrRegionCode.YT:
      return r'YT';
    case Enum$SponsorsCountryOrRegionCode.ZA:
      return r'ZA';
    case Enum$SponsorsCountryOrRegionCode.ZM:
      return r'ZM';
    case Enum$SponsorsCountryOrRegionCode.ZW:
      return r'ZW';
    case Enum$SponsorsCountryOrRegionCode.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsCountryOrRegionCode fromJson$Enum$SponsorsCountryOrRegionCode(
    String value) {
  switch (value) {
    case r'AD':
      return Enum$SponsorsCountryOrRegionCode.AD;
    case r'AE':
      return Enum$SponsorsCountryOrRegionCode.AE;
    case r'AF':
      return Enum$SponsorsCountryOrRegionCode.AF;
    case r'AG':
      return Enum$SponsorsCountryOrRegionCode.AG;
    case r'AI':
      return Enum$SponsorsCountryOrRegionCode.AI;
    case r'AL':
      return Enum$SponsorsCountryOrRegionCode.AL;
    case r'AM':
      return Enum$SponsorsCountryOrRegionCode.AM;
    case r'AO':
      return Enum$SponsorsCountryOrRegionCode.AO;
    case r'AQ':
      return Enum$SponsorsCountryOrRegionCode.AQ;
    case r'AR':
      return Enum$SponsorsCountryOrRegionCode.AR;
    case r'AS':
      return Enum$SponsorsCountryOrRegionCode.AS;
    case r'AT':
      return Enum$SponsorsCountryOrRegionCode.AT;
    case r'AU':
      return Enum$SponsorsCountryOrRegionCode.AU;
    case r'AW':
      return Enum$SponsorsCountryOrRegionCode.AW;
    case r'AX':
      return Enum$SponsorsCountryOrRegionCode.AX;
    case r'AZ':
      return Enum$SponsorsCountryOrRegionCode.AZ;
    case r'BA':
      return Enum$SponsorsCountryOrRegionCode.BA;
    case r'BB':
      return Enum$SponsorsCountryOrRegionCode.BB;
    case r'BD':
      return Enum$SponsorsCountryOrRegionCode.BD;
    case r'BE':
      return Enum$SponsorsCountryOrRegionCode.BE;
    case r'BF':
      return Enum$SponsorsCountryOrRegionCode.BF;
    case r'BG':
      return Enum$SponsorsCountryOrRegionCode.BG;
    case r'BH':
      return Enum$SponsorsCountryOrRegionCode.BH;
    case r'BI':
      return Enum$SponsorsCountryOrRegionCode.BI;
    case r'BJ':
      return Enum$SponsorsCountryOrRegionCode.BJ;
    case r'BL':
      return Enum$SponsorsCountryOrRegionCode.BL;
    case r'BM':
      return Enum$SponsorsCountryOrRegionCode.BM;
    case r'BN':
      return Enum$SponsorsCountryOrRegionCode.BN;
    case r'BO':
      return Enum$SponsorsCountryOrRegionCode.BO;
    case r'BQ':
      return Enum$SponsorsCountryOrRegionCode.BQ;
    case r'BR':
      return Enum$SponsorsCountryOrRegionCode.BR;
    case r'BS':
      return Enum$SponsorsCountryOrRegionCode.BS;
    case r'BT':
      return Enum$SponsorsCountryOrRegionCode.BT;
    case r'BV':
      return Enum$SponsorsCountryOrRegionCode.BV;
    case r'BW':
      return Enum$SponsorsCountryOrRegionCode.BW;
    case r'BY':
      return Enum$SponsorsCountryOrRegionCode.BY;
    case r'BZ':
      return Enum$SponsorsCountryOrRegionCode.BZ;
    case r'CA':
      return Enum$SponsorsCountryOrRegionCode.CA;
    case r'CC':
      return Enum$SponsorsCountryOrRegionCode.CC;
    case r'CD':
      return Enum$SponsorsCountryOrRegionCode.CD;
    case r'CF':
      return Enum$SponsorsCountryOrRegionCode.CF;
    case r'CG':
      return Enum$SponsorsCountryOrRegionCode.CG;
    case r'CH':
      return Enum$SponsorsCountryOrRegionCode.CH;
    case r'CI':
      return Enum$SponsorsCountryOrRegionCode.CI;
    case r'CK':
      return Enum$SponsorsCountryOrRegionCode.CK;
    case r'CL':
      return Enum$SponsorsCountryOrRegionCode.CL;
    case r'CM':
      return Enum$SponsorsCountryOrRegionCode.CM;
    case r'CN':
      return Enum$SponsorsCountryOrRegionCode.CN;
    case r'CO':
      return Enum$SponsorsCountryOrRegionCode.CO;
    case r'CR':
      return Enum$SponsorsCountryOrRegionCode.CR;
    case r'CV':
      return Enum$SponsorsCountryOrRegionCode.CV;
    case r'CW':
      return Enum$SponsorsCountryOrRegionCode.CW;
    case r'CX':
      return Enum$SponsorsCountryOrRegionCode.CX;
    case r'CY':
      return Enum$SponsorsCountryOrRegionCode.CY;
    case r'CZ':
      return Enum$SponsorsCountryOrRegionCode.CZ;
    case r'DE':
      return Enum$SponsorsCountryOrRegionCode.DE;
    case r'DJ':
      return Enum$SponsorsCountryOrRegionCode.DJ;
    case r'DK':
      return Enum$SponsorsCountryOrRegionCode.DK;
    case r'DM':
      return Enum$SponsorsCountryOrRegionCode.DM;
    case r'DO':
      return Enum$SponsorsCountryOrRegionCode.DO;
    case r'DZ':
      return Enum$SponsorsCountryOrRegionCode.DZ;
    case r'EC':
      return Enum$SponsorsCountryOrRegionCode.EC;
    case r'EE':
      return Enum$SponsorsCountryOrRegionCode.EE;
    case r'EG':
      return Enum$SponsorsCountryOrRegionCode.EG;
    case r'EH':
      return Enum$SponsorsCountryOrRegionCode.EH;
    case r'ER':
      return Enum$SponsorsCountryOrRegionCode.ER;
    case r'ES':
      return Enum$SponsorsCountryOrRegionCode.ES;
    case r'ET':
      return Enum$SponsorsCountryOrRegionCode.ET;
    case r'FI':
      return Enum$SponsorsCountryOrRegionCode.FI;
    case r'FJ':
      return Enum$SponsorsCountryOrRegionCode.FJ;
    case r'FK':
      return Enum$SponsorsCountryOrRegionCode.FK;
    case r'FM':
      return Enum$SponsorsCountryOrRegionCode.FM;
    case r'FO':
      return Enum$SponsorsCountryOrRegionCode.FO;
    case r'FR':
      return Enum$SponsorsCountryOrRegionCode.FR;
    case r'GA':
      return Enum$SponsorsCountryOrRegionCode.GA;
    case r'GB':
      return Enum$SponsorsCountryOrRegionCode.GB;
    case r'GD':
      return Enum$SponsorsCountryOrRegionCode.GD;
    case r'GE':
      return Enum$SponsorsCountryOrRegionCode.GE;
    case r'GF':
      return Enum$SponsorsCountryOrRegionCode.GF;
    case r'GG':
      return Enum$SponsorsCountryOrRegionCode.GG;
    case r'GH':
      return Enum$SponsorsCountryOrRegionCode.GH;
    case r'GI':
      return Enum$SponsorsCountryOrRegionCode.GI;
    case r'GL':
      return Enum$SponsorsCountryOrRegionCode.GL;
    case r'GM':
      return Enum$SponsorsCountryOrRegionCode.GM;
    case r'GN':
      return Enum$SponsorsCountryOrRegionCode.GN;
    case r'GP':
      return Enum$SponsorsCountryOrRegionCode.GP;
    case r'GQ':
      return Enum$SponsorsCountryOrRegionCode.GQ;
    case r'GR':
      return Enum$SponsorsCountryOrRegionCode.GR;
    case r'GS':
      return Enum$SponsorsCountryOrRegionCode.GS;
    case r'GT':
      return Enum$SponsorsCountryOrRegionCode.GT;
    case r'GU':
      return Enum$SponsorsCountryOrRegionCode.GU;
    case r'GW':
      return Enum$SponsorsCountryOrRegionCode.GW;
    case r'GY':
      return Enum$SponsorsCountryOrRegionCode.GY;
    case r'HK':
      return Enum$SponsorsCountryOrRegionCode.HK;
    case r'HM':
      return Enum$SponsorsCountryOrRegionCode.HM;
    case r'HN':
      return Enum$SponsorsCountryOrRegionCode.HN;
    case r'HR':
      return Enum$SponsorsCountryOrRegionCode.HR;
    case r'HT':
      return Enum$SponsorsCountryOrRegionCode.HT;
    case r'HU':
      return Enum$SponsorsCountryOrRegionCode.HU;
    case r'ID':
      return Enum$SponsorsCountryOrRegionCode.ID;
    case r'IE':
      return Enum$SponsorsCountryOrRegionCode.IE;
    case r'IL':
      return Enum$SponsorsCountryOrRegionCode.IL;
    case r'IM':
      return Enum$SponsorsCountryOrRegionCode.IM;
    case r'IN':
      return Enum$SponsorsCountryOrRegionCode.IN;
    case r'IO':
      return Enum$SponsorsCountryOrRegionCode.IO;
    case r'IQ':
      return Enum$SponsorsCountryOrRegionCode.IQ;
    case r'IR':
      return Enum$SponsorsCountryOrRegionCode.IR;
    case r'IS':
      return Enum$SponsorsCountryOrRegionCode.IS;
    case r'IT':
      return Enum$SponsorsCountryOrRegionCode.IT;
    case r'JE':
      return Enum$SponsorsCountryOrRegionCode.JE;
    case r'JM':
      return Enum$SponsorsCountryOrRegionCode.JM;
    case r'JO':
      return Enum$SponsorsCountryOrRegionCode.JO;
    case r'JP':
      return Enum$SponsorsCountryOrRegionCode.JP;
    case r'KE':
      return Enum$SponsorsCountryOrRegionCode.KE;
    case r'KG':
      return Enum$SponsorsCountryOrRegionCode.KG;
    case r'KH':
      return Enum$SponsorsCountryOrRegionCode.KH;
    case r'KI':
      return Enum$SponsorsCountryOrRegionCode.KI;
    case r'KM':
      return Enum$SponsorsCountryOrRegionCode.KM;
    case r'KN':
      return Enum$SponsorsCountryOrRegionCode.KN;
    case r'KR':
      return Enum$SponsorsCountryOrRegionCode.KR;
    case r'KW':
      return Enum$SponsorsCountryOrRegionCode.KW;
    case r'KY':
      return Enum$SponsorsCountryOrRegionCode.KY;
    case r'KZ':
      return Enum$SponsorsCountryOrRegionCode.KZ;
    case r'LA':
      return Enum$SponsorsCountryOrRegionCode.LA;
    case r'LB':
      return Enum$SponsorsCountryOrRegionCode.LB;
    case r'LC':
      return Enum$SponsorsCountryOrRegionCode.LC;
    case r'LI':
      return Enum$SponsorsCountryOrRegionCode.LI;
    case r'LK':
      return Enum$SponsorsCountryOrRegionCode.LK;
    case r'LR':
      return Enum$SponsorsCountryOrRegionCode.LR;
    case r'LS':
      return Enum$SponsorsCountryOrRegionCode.LS;
    case r'LT':
      return Enum$SponsorsCountryOrRegionCode.LT;
    case r'LU':
      return Enum$SponsorsCountryOrRegionCode.LU;
    case r'LV':
      return Enum$SponsorsCountryOrRegionCode.LV;
    case r'LY':
      return Enum$SponsorsCountryOrRegionCode.LY;
    case r'MA':
      return Enum$SponsorsCountryOrRegionCode.MA;
    case r'MC':
      return Enum$SponsorsCountryOrRegionCode.MC;
    case r'MD':
      return Enum$SponsorsCountryOrRegionCode.MD;
    case r'ME':
      return Enum$SponsorsCountryOrRegionCode.ME;
    case r'MF':
      return Enum$SponsorsCountryOrRegionCode.MF;
    case r'MG':
      return Enum$SponsorsCountryOrRegionCode.MG;
    case r'MH':
      return Enum$SponsorsCountryOrRegionCode.MH;
    case r'MK':
      return Enum$SponsorsCountryOrRegionCode.MK;
    case r'ML':
      return Enum$SponsorsCountryOrRegionCode.ML;
    case r'MM':
      return Enum$SponsorsCountryOrRegionCode.MM;
    case r'MN':
      return Enum$SponsorsCountryOrRegionCode.MN;
    case r'MO':
      return Enum$SponsorsCountryOrRegionCode.MO;
    case r'MP':
      return Enum$SponsorsCountryOrRegionCode.MP;
    case r'MQ':
      return Enum$SponsorsCountryOrRegionCode.MQ;
    case r'MR':
      return Enum$SponsorsCountryOrRegionCode.MR;
    case r'MS':
      return Enum$SponsorsCountryOrRegionCode.MS;
    case r'MT':
      return Enum$SponsorsCountryOrRegionCode.MT;
    case r'MU':
      return Enum$SponsorsCountryOrRegionCode.MU;
    case r'MV':
      return Enum$SponsorsCountryOrRegionCode.MV;
    case r'MW':
      return Enum$SponsorsCountryOrRegionCode.MW;
    case r'MX':
      return Enum$SponsorsCountryOrRegionCode.MX;
    case r'MY':
      return Enum$SponsorsCountryOrRegionCode.MY;
    case r'MZ':
      return Enum$SponsorsCountryOrRegionCode.MZ;
    case r'NA':
      return Enum$SponsorsCountryOrRegionCode.NA;
    case r'NC':
      return Enum$SponsorsCountryOrRegionCode.NC;
    case r'NE':
      return Enum$SponsorsCountryOrRegionCode.NE;
    case r'NF':
      return Enum$SponsorsCountryOrRegionCode.NF;
    case r'NG':
      return Enum$SponsorsCountryOrRegionCode.NG;
    case r'NI':
      return Enum$SponsorsCountryOrRegionCode.NI;
    case r'NL':
      return Enum$SponsorsCountryOrRegionCode.NL;
    case r'NO':
      return Enum$SponsorsCountryOrRegionCode.NO;
    case r'NP':
      return Enum$SponsorsCountryOrRegionCode.NP;
    case r'NR':
      return Enum$SponsorsCountryOrRegionCode.NR;
    case r'NU':
      return Enum$SponsorsCountryOrRegionCode.NU;
    case r'NZ':
      return Enum$SponsorsCountryOrRegionCode.NZ;
    case r'OM':
      return Enum$SponsorsCountryOrRegionCode.OM;
    case r'PA':
      return Enum$SponsorsCountryOrRegionCode.PA;
    case r'PE':
      return Enum$SponsorsCountryOrRegionCode.PE;
    case r'PF':
      return Enum$SponsorsCountryOrRegionCode.PF;
    case r'PG':
      return Enum$SponsorsCountryOrRegionCode.PG;
    case r'PH':
      return Enum$SponsorsCountryOrRegionCode.PH;
    case r'PK':
      return Enum$SponsorsCountryOrRegionCode.PK;
    case r'PL':
      return Enum$SponsorsCountryOrRegionCode.PL;
    case r'PM':
      return Enum$SponsorsCountryOrRegionCode.PM;
    case r'PN':
      return Enum$SponsorsCountryOrRegionCode.PN;
    case r'PR':
      return Enum$SponsorsCountryOrRegionCode.PR;
    case r'PS':
      return Enum$SponsorsCountryOrRegionCode.PS;
    case r'PT':
      return Enum$SponsorsCountryOrRegionCode.PT;
    case r'PW':
      return Enum$SponsorsCountryOrRegionCode.PW;
    case r'PY':
      return Enum$SponsorsCountryOrRegionCode.PY;
    case r'QA':
      return Enum$SponsorsCountryOrRegionCode.QA;
    case r'RE':
      return Enum$SponsorsCountryOrRegionCode.RE;
    case r'RO':
      return Enum$SponsorsCountryOrRegionCode.RO;
    case r'RS':
      return Enum$SponsorsCountryOrRegionCode.RS;
    case r'RU':
      return Enum$SponsorsCountryOrRegionCode.RU;
    case r'RW':
      return Enum$SponsorsCountryOrRegionCode.RW;
    case r'SA':
      return Enum$SponsorsCountryOrRegionCode.SA;
    case r'SB':
      return Enum$SponsorsCountryOrRegionCode.SB;
    case r'SC':
      return Enum$SponsorsCountryOrRegionCode.SC;
    case r'SD':
      return Enum$SponsorsCountryOrRegionCode.SD;
    case r'SE':
      return Enum$SponsorsCountryOrRegionCode.SE;
    case r'SG':
      return Enum$SponsorsCountryOrRegionCode.SG;
    case r'SH':
      return Enum$SponsorsCountryOrRegionCode.SH;
    case r'SI':
      return Enum$SponsorsCountryOrRegionCode.SI;
    case r'SJ':
      return Enum$SponsorsCountryOrRegionCode.SJ;
    case r'SK':
      return Enum$SponsorsCountryOrRegionCode.SK;
    case r'SL':
      return Enum$SponsorsCountryOrRegionCode.SL;
    case r'SM':
      return Enum$SponsorsCountryOrRegionCode.SM;
    case r'SN':
      return Enum$SponsorsCountryOrRegionCode.SN;
    case r'SO':
      return Enum$SponsorsCountryOrRegionCode.SO;
    case r'SR':
      return Enum$SponsorsCountryOrRegionCode.SR;
    case r'SS':
      return Enum$SponsorsCountryOrRegionCode.SS;
    case r'ST':
      return Enum$SponsorsCountryOrRegionCode.ST;
    case r'SV':
      return Enum$SponsorsCountryOrRegionCode.SV;
    case r'SX':
      return Enum$SponsorsCountryOrRegionCode.SX;
    case r'SZ':
      return Enum$SponsorsCountryOrRegionCode.SZ;
    case r'TC':
      return Enum$SponsorsCountryOrRegionCode.TC;
    case r'TD':
      return Enum$SponsorsCountryOrRegionCode.TD;
    case r'TF':
      return Enum$SponsorsCountryOrRegionCode.TF;
    case r'TG':
      return Enum$SponsorsCountryOrRegionCode.TG;
    case r'TH':
      return Enum$SponsorsCountryOrRegionCode.TH;
    case r'TJ':
      return Enum$SponsorsCountryOrRegionCode.TJ;
    case r'TK':
      return Enum$SponsorsCountryOrRegionCode.TK;
    case r'TL':
      return Enum$SponsorsCountryOrRegionCode.TL;
    case r'TM':
      return Enum$SponsorsCountryOrRegionCode.TM;
    case r'TN':
      return Enum$SponsorsCountryOrRegionCode.TN;
    case r'TO':
      return Enum$SponsorsCountryOrRegionCode.TO;
    case r'TR':
      return Enum$SponsorsCountryOrRegionCode.TR;
    case r'TT':
      return Enum$SponsorsCountryOrRegionCode.TT;
    case r'TV':
      return Enum$SponsorsCountryOrRegionCode.TV;
    case r'TW':
      return Enum$SponsorsCountryOrRegionCode.TW;
    case r'TZ':
      return Enum$SponsorsCountryOrRegionCode.TZ;
    case r'UA':
      return Enum$SponsorsCountryOrRegionCode.UA;
    case r'UG':
      return Enum$SponsorsCountryOrRegionCode.UG;
    case r'UM':
      return Enum$SponsorsCountryOrRegionCode.UM;
    case r'US':
      return Enum$SponsorsCountryOrRegionCode.US;
    case r'UY':
      return Enum$SponsorsCountryOrRegionCode.UY;
    case r'UZ':
      return Enum$SponsorsCountryOrRegionCode.UZ;
    case r'VA':
      return Enum$SponsorsCountryOrRegionCode.VA;
    case r'VC':
      return Enum$SponsorsCountryOrRegionCode.VC;
    case r'VE':
      return Enum$SponsorsCountryOrRegionCode.VE;
    case r'VG':
      return Enum$SponsorsCountryOrRegionCode.VG;
    case r'VI':
      return Enum$SponsorsCountryOrRegionCode.VI;
    case r'VN':
      return Enum$SponsorsCountryOrRegionCode.VN;
    case r'VU':
      return Enum$SponsorsCountryOrRegionCode.VU;
    case r'WF':
      return Enum$SponsorsCountryOrRegionCode.WF;
    case r'WS':
      return Enum$SponsorsCountryOrRegionCode.WS;
    case r'YE':
      return Enum$SponsorsCountryOrRegionCode.YE;
    case r'YT':
      return Enum$SponsorsCountryOrRegionCode.YT;
    case r'ZA':
      return Enum$SponsorsCountryOrRegionCode.ZA;
    case r'ZM':
      return Enum$SponsorsCountryOrRegionCode.ZM;
    case r'ZW':
      return Enum$SponsorsCountryOrRegionCode.ZW;
    default:
      return Enum$SponsorsCountryOrRegionCode.$unknown;
  }
}

enum Enum$SponsorsGoalKind {
  MONTHLY_SPONSORSHIP_AMOUNT,
  TOTAL_SPONSORS_COUNT,
  $unknown
}

String toJson$Enum$SponsorsGoalKind(Enum$SponsorsGoalKind e) {
  switch (e) {
    case Enum$SponsorsGoalKind.MONTHLY_SPONSORSHIP_AMOUNT:
      return r'MONTHLY_SPONSORSHIP_AMOUNT';
    case Enum$SponsorsGoalKind.TOTAL_SPONSORS_COUNT:
      return r'TOTAL_SPONSORS_COUNT';
    case Enum$SponsorsGoalKind.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsGoalKind fromJson$Enum$SponsorsGoalKind(String value) {
  switch (value) {
    case r'MONTHLY_SPONSORSHIP_AMOUNT':
      return Enum$SponsorsGoalKind.MONTHLY_SPONSORSHIP_AMOUNT;
    case r'TOTAL_SPONSORS_COUNT':
      return Enum$SponsorsGoalKind.TOTAL_SPONSORS_COUNT;
    default:
      return Enum$SponsorsGoalKind.$unknown;
  }
}

enum Enum$SponsorsListingFeaturedItemFeatureableType {
  REPOSITORY,
  USER,
  $unknown
}

String toJson$Enum$SponsorsListingFeaturedItemFeatureableType(
    Enum$SponsorsListingFeaturedItemFeatureableType e) {
  switch (e) {
    case Enum$SponsorsListingFeaturedItemFeatureableType.REPOSITORY:
      return r'REPOSITORY';
    case Enum$SponsorsListingFeaturedItemFeatureableType.USER:
      return r'USER';
    case Enum$SponsorsListingFeaturedItemFeatureableType.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsListingFeaturedItemFeatureableType
    fromJson$Enum$SponsorsListingFeaturedItemFeatureableType(String value) {
  switch (value) {
    case r'REPOSITORY':
      return Enum$SponsorsListingFeaturedItemFeatureableType.REPOSITORY;
    case r'USER':
      return Enum$SponsorsListingFeaturedItemFeatureableType.USER;
    default:
      return Enum$SponsorsListingFeaturedItemFeatureableType.$unknown;
  }
}

enum Enum$SponsorsTierOrderField {
  CREATED_AT,
  MONTHLY_PRICE_IN_CENTS,
  $unknown
}

String toJson$Enum$SponsorsTierOrderField(Enum$SponsorsTierOrderField e) {
  switch (e) {
    case Enum$SponsorsTierOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorsTierOrderField.MONTHLY_PRICE_IN_CENTS:
      return r'MONTHLY_PRICE_IN_CENTS';
    case Enum$SponsorsTierOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorsTierOrderField fromJson$Enum$SponsorsTierOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorsTierOrderField.CREATED_AT;
    case r'MONTHLY_PRICE_IN_CENTS':
      return Enum$SponsorsTierOrderField.MONTHLY_PRICE_IN_CENTS;
    default:
      return Enum$SponsorsTierOrderField.$unknown;
  }
}

enum Enum$SponsorshipNewsletterOrderField { CREATED_AT, $unknown }

String toJson$Enum$SponsorshipNewsletterOrderField(
    Enum$SponsorshipNewsletterOrderField e) {
  switch (e) {
    case Enum$SponsorshipNewsletterOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorshipNewsletterOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipNewsletterOrderField
    fromJson$Enum$SponsorshipNewsletterOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorshipNewsletterOrderField.CREATED_AT;
    default:
      return Enum$SponsorshipNewsletterOrderField.$unknown;
  }
}

enum Enum$SponsorshipOrderField { CREATED_AT, $unknown }

String toJson$Enum$SponsorshipOrderField(Enum$SponsorshipOrderField e) {
  switch (e) {
    case Enum$SponsorshipOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$SponsorshipOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipOrderField fromJson$Enum$SponsorshipOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$SponsorshipOrderField.CREATED_AT;
    default:
      return Enum$SponsorshipOrderField.$unknown;
  }
}

enum Enum$SponsorshipPrivacy { PRIVATE, PUBLIC, $unknown }

String toJson$Enum$SponsorshipPrivacy(Enum$SponsorshipPrivacy e) {
  switch (e) {
    case Enum$SponsorshipPrivacy.PRIVATE:
      return r'PRIVATE';
    case Enum$SponsorshipPrivacy.PUBLIC:
      return r'PUBLIC';
    case Enum$SponsorshipPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$SponsorshipPrivacy fromJson$Enum$SponsorshipPrivacy(String value) {
  switch (value) {
    case r'PRIVATE':
      return Enum$SponsorshipPrivacy.PRIVATE;
    case r'PUBLIC':
      return Enum$SponsorshipPrivacy.PUBLIC;
    default:
      return Enum$SponsorshipPrivacy.$unknown;
  }
}

enum Enum$SquashMergeCommitMessage { BLANK, COMMIT_MESSAGES, PR_BODY, $unknown }

String toJson$Enum$SquashMergeCommitMessage(Enum$SquashMergeCommitMessage e) {
  switch (e) {
    case Enum$SquashMergeCommitMessage.BLANK:
      return r'BLANK';
    case Enum$SquashMergeCommitMessage.COMMIT_MESSAGES:
      return r'COMMIT_MESSAGES';
    case Enum$SquashMergeCommitMessage.PR_BODY:
      return r'PR_BODY';
    case Enum$SquashMergeCommitMessage.$unknown:
      return r'$unknown';
  }
}

Enum$SquashMergeCommitMessage fromJson$Enum$SquashMergeCommitMessage(
    String value) {
  switch (value) {
    case r'BLANK':
      return Enum$SquashMergeCommitMessage.BLANK;
    case r'COMMIT_MESSAGES':
      return Enum$SquashMergeCommitMessage.COMMIT_MESSAGES;
    case r'PR_BODY':
      return Enum$SquashMergeCommitMessage.PR_BODY;
    default:
      return Enum$SquashMergeCommitMessage.$unknown;
  }
}

enum Enum$SquashMergeCommitTitle { COMMIT_OR_PR_TITLE, PR_TITLE, $unknown }

String toJson$Enum$SquashMergeCommitTitle(Enum$SquashMergeCommitTitle e) {
  switch (e) {
    case Enum$SquashMergeCommitTitle.COMMIT_OR_PR_TITLE:
      return r'COMMIT_OR_PR_TITLE';
    case Enum$SquashMergeCommitTitle.PR_TITLE:
      return r'PR_TITLE';
    case Enum$SquashMergeCommitTitle.$unknown:
      return r'$unknown';
  }
}

Enum$SquashMergeCommitTitle fromJson$Enum$SquashMergeCommitTitle(String value) {
  switch (value) {
    case r'COMMIT_OR_PR_TITLE':
      return Enum$SquashMergeCommitTitle.COMMIT_OR_PR_TITLE;
    case r'PR_TITLE':
      return Enum$SquashMergeCommitTitle.PR_TITLE;
    default:
      return Enum$SquashMergeCommitTitle.$unknown;
  }
}

enum Enum$StarOrderField { STARRED_AT, $unknown }

String toJson$Enum$StarOrderField(Enum$StarOrderField e) {
  switch (e) {
    case Enum$StarOrderField.STARRED_AT:
      return r'STARRED_AT';
    case Enum$StarOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$StarOrderField fromJson$Enum$StarOrderField(String value) {
  switch (value) {
    case r'STARRED_AT':
      return Enum$StarOrderField.STARRED_AT;
    default:
      return Enum$StarOrderField.$unknown;
  }
}

enum Enum$StatusState { ERROR, EXPECTED, FAILURE, PENDING, SUCCESS, $unknown }

String toJson$Enum$StatusState(Enum$StatusState e) {
  switch (e) {
    case Enum$StatusState.ERROR:
      return r'ERROR';
    case Enum$StatusState.EXPECTED:
      return r'EXPECTED';
    case Enum$StatusState.FAILURE:
      return r'FAILURE';
    case Enum$StatusState.PENDING:
      return r'PENDING';
    case Enum$StatusState.SUCCESS:
      return r'SUCCESS';
    case Enum$StatusState.$unknown:
      return r'$unknown';
  }
}

Enum$StatusState fromJson$Enum$StatusState(String value) {
  switch (value) {
    case r'ERROR':
      return Enum$StatusState.ERROR;
    case r'EXPECTED':
      return Enum$StatusState.EXPECTED;
    case r'FAILURE':
      return Enum$StatusState.FAILURE;
    case r'PENDING':
      return Enum$StatusState.PENDING;
    case r'SUCCESS':
      return Enum$StatusState.SUCCESS;
    default:
      return Enum$StatusState.$unknown;
  }
}

enum Enum$SubscriptionState { IGNORED, SUBSCRIBED, UNSUBSCRIBED, $unknown }

String toJson$Enum$SubscriptionState(Enum$SubscriptionState e) {
  switch (e) {
    case Enum$SubscriptionState.IGNORED:
      return r'IGNORED';
    case Enum$SubscriptionState.SUBSCRIBED:
      return r'SUBSCRIBED';
    case Enum$SubscriptionState.UNSUBSCRIBED:
      return r'UNSUBSCRIBED';
    case Enum$SubscriptionState.$unknown:
      return r'$unknown';
  }
}

Enum$SubscriptionState fromJson$Enum$SubscriptionState(String value) {
  switch (value) {
    case r'IGNORED':
      return Enum$SubscriptionState.IGNORED;
    case r'SUBSCRIBED':
      return Enum$SubscriptionState.SUBSCRIBED;
    case r'UNSUBSCRIBED':
      return Enum$SubscriptionState.UNSUBSCRIBED;
    default:
      return Enum$SubscriptionState.$unknown;
  }
}

enum Enum$TeamDiscussionCommentOrderField { NUMBER, $unknown }

String toJson$Enum$TeamDiscussionCommentOrderField(
    Enum$TeamDiscussionCommentOrderField e) {
  switch (e) {
    case Enum$TeamDiscussionCommentOrderField.NUMBER:
      return r'NUMBER';
    case Enum$TeamDiscussionCommentOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamDiscussionCommentOrderField
    fromJson$Enum$TeamDiscussionCommentOrderField(String value) {
  switch (value) {
    case r'NUMBER':
      return Enum$TeamDiscussionCommentOrderField.NUMBER;
    default:
      return Enum$TeamDiscussionCommentOrderField.$unknown;
  }
}

enum Enum$TeamDiscussionOrderField { CREATED_AT, $unknown }

String toJson$Enum$TeamDiscussionOrderField(Enum$TeamDiscussionOrderField e) {
  switch (e) {
    case Enum$TeamDiscussionOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamDiscussionOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamDiscussionOrderField fromJson$Enum$TeamDiscussionOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$TeamDiscussionOrderField.CREATED_AT;
    default:
      return Enum$TeamDiscussionOrderField.$unknown;
  }
}

enum Enum$TeamMemberOrderField { CREATED_AT, LOGIN, $unknown }

String toJson$Enum$TeamMemberOrderField(Enum$TeamMemberOrderField e) {
  switch (e) {
    case Enum$TeamMemberOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamMemberOrderField.LOGIN:
      return r'LOGIN';
    case Enum$TeamMemberOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMemberOrderField fromJson$Enum$TeamMemberOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$TeamMemberOrderField.CREATED_AT;
    case r'LOGIN':
      return Enum$TeamMemberOrderField.LOGIN;
    default:
      return Enum$TeamMemberOrderField.$unknown;
  }
}

enum Enum$TeamMemberRole { MAINTAINER, MEMBER, $unknown }

String toJson$Enum$TeamMemberRole(Enum$TeamMemberRole e) {
  switch (e) {
    case Enum$TeamMemberRole.MAINTAINER:
      return r'MAINTAINER';
    case Enum$TeamMemberRole.MEMBER:
      return r'MEMBER';
    case Enum$TeamMemberRole.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMemberRole fromJson$Enum$TeamMemberRole(String value) {
  switch (value) {
    case r'MAINTAINER':
      return Enum$TeamMemberRole.MAINTAINER;
    case r'MEMBER':
      return Enum$TeamMemberRole.MEMBER;
    default:
      return Enum$TeamMemberRole.$unknown;
  }
}

enum Enum$TeamMembershipType { ALL, CHILD_TEAM, IMMEDIATE, $unknown }

String toJson$Enum$TeamMembershipType(Enum$TeamMembershipType e) {
  switch (e) {
    case Enum$TeamMembershipType.ALL:
      return r'ALL';
    case Enum$TeamMembershipType.CHILD_TEAM:
      return r'CHILD_TEAM';
    case Enum$TeamMembershipType.IMMEDIATE:
      return r'IMMEDIATE';
    case Enum$TeamMembershipType.$unknown:
      return r'$unknown';
  }
}

Enum$TeamMembershipType fromJson$Enum$TeamMembershipType(String value) {
  switch (value) {
    case r'ALL':
      return Enum$TeamMembershipType.ALL;
    case r'CHILD_TEAM':
      return Enum$TeamMembershipType.CHILD_TEAM;
    case r'IMMEDIATE':
      return Enum$TeamMembershipType.IMMEDIATE;
    default:
      return Enum$TeamMembershipType.$unknown;
  }
}

enum Enum$TeamOrderField { NAME, $unknown }

String toJson$Enum$TeamOrderField(Enum$TeamOrderField e) {
  switch (e) {
    case Enum$TeamOrderField.NAME:
      return r'NAME';
    case Enum$TeamOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamOrderField fromJson$Enum$TeamOrderField(String value) {
  switch (value) {
    case r'NAME':
      return Enum$TeamOrderField.NAME;
    default:
      return Enum$TeamOrderField.$unknown;
  }
}

enum Enum$TeamPrivacy { SECRET, VISIBLE, $unknown }

String toJson$Enum$TeamPrivacy(Enum$TeamPrivacy e) {
  switch (e) {
    case Enum$TeamPrivacy.SECRET:
      return r'SECRET';
    case Enum$TeamPrivacy.VISIBLE:
      return r'VISIBLE';
    case Enum$TeamPrivacy.$unknown:
      return r'$unknown';
  }
}

Enum$TeamPrivacy fromJson$Enum$TeamPrivacy(String value) {
  switch (value) {
    case r'SECRET':
      return Enum$TeamPrivacy.SECRET;
    case r'VISIBLE':
      return Enum$TeamPrivacy.VISIBLE;
    default:
      return Enum$TeamPrivacy.$unknown;
  }
}

enum Enum$TeamRepositoryOrderField {
  CREATED_AT,
  NAME,
  PERMISSION,
  PUSHED_AT,
  STARGAZERS,
  UPDATED_AT,
  $unknown
}

String toJson$Enum$TeamRepositoryOrderField(Enum$TeamRepositoryOrderField e) {
  switch (e) {
    case Enum$TeamRepositoryOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$TeamRepositoryOrderField.NAME:
      return r'NAME';
    case Enum$TeamRepositoryOrderField.PERMISSION:
      return r'PERMISSION';
    case Enum$TeamRepositoryOrderField.PUSHED_AT:
      return r'PUSHED_AT';
    case Enum$TeamRepositoryOrderField.STARGAZERS:
      return r'STARGAZERS';
    case Enum$TeamRepositoryOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$TeamRepositoryOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$TeamRepositoryOrderField fromJson$Enum$TeamRepositoryOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$TeamRepositoryOrderField.CREATED_AT;
    case r'NAME':
      return Enum$TeamRepositoryOrderField.NAME;
    case r'PERMISSION':
      return Enum$TeamRepositoryOrderField.PERMISSION;
    case r'PUSHED_AT':
      return Enum$TeamRepositoryOrderField.PUSHED_AT;
    case r'STARGAZERS':
      return Enum$TeamRepositoryOrderField.STARGAZERS;
    case r'UPDATED_AT':
      return Enum$TeamRepositoryOrderField.UPDATED_AT;
    default:
      return Enum$TeamRepositoryOrderField.$unknown;
  }
}

enum Enum$TeamReviewAssignmentAlgorithm { LOAD_BALANCE, ROUND_ROBIN, $unknown }

String toJson$Enum$TeamReviewAssignmentAlgorithm(
    Enum$TeamReviewAssignmentAlgorithm e) {
  switch (e) {
    case Enum$TeamReviewAssignmentAlgorithm.LOAD_BALANCE:
      return r'LOAD_BALANCE';
    case Enum$TeamReviewAssignmentAlgorithm.ROUND_ROBIN:
      return r'ROUND_ROBIN';
    case Enum$TeamReviewAssignmentAlgorithm.$unknown:
      return r'$unknown';
  }
}

Enum$TeamReviewAssignmentAlgorithm fromJson$Enum$TeamReviewAssignmentAlgorithm(
    String value) {
  switch (value) {
    case r'LOAD_BALANCE':
      return Enum$TeamReviewAssignmentAlgorithm.LOAD_BALANCE;
    case r'ROUND_ROBIN':
      return Enum$TeamReviewAssignmentAlgorithm.ROUND_ROBIN;
    default:
      return Enum$TeamReviewAssignmentAlgorithm.$unknown;
  }
}

enum Enum$TeamRole { ADMIN, MEMBER, $unknown }

String toJson$Enum$TeamRole(Enum$TeamRole e) {
  switch (e) {
    case Enum$TeamRole.ADMIN:
      return r'ADMIN';
    case Enum$TeamRole.MEMBER:
      return r'MEMBER';
    case Enum$TeamRole.$unknown:
      return r'$unknown';
  }
}

Enum$TeamRole fromJson$Enum$TeamRole(String value) {
  switch (value) {
    case r'ADMIN':
      return Enum$TeamRole.ADMIN;
    case r'MEMBER':
      return Enum$TeamRole.MEMBER;
    default:
      return Enum$TeamRole.$unknown;
  }
}

enum Enum$TopicSuggestionDeclineReason {
  NOT_RELEVANT,
  PERSONAL_PREFERENCE,
  TOO_GENERAL,
  TOO_SPECIFIC,
  $unknown
}

String toJson$Enum$TopicSuggestionDeclineReason(
    Enum$TopicSuggestionDeclineReason e) {
  switch (e) {
    case Enum$TopicSuggestionDeclineReason.NOT_RELEVANT:
      return r'NOT_RELEVANT';
    case Enum$TopicSuggestionDeclineReason.PERSONAL_PREFERENCE:
      return r'PERSONAL_PREFERENCE';
    case Enum$TopicSuggestionDeclineReason.TOO_GENERAL:
      return r'TOO_GENERAL';
    case Enum$TopicSuggestionDeclineReason.TOO_SPECIFIC:
      return r'TOO_SPECIFIC';
    case Enum$TopicSuggestionDeclineReason.$unknown:
      return r'$unknown';
  }
}

Enum$TopicSuggestionDeclineReason fromJson$Enum$TopicSuggestionDeclineReason(
    String value) {
  switch (value) {
    case r'NOT_RELEVANT':
      return Enum$TopicSuggestionDeclineReason.NOT_RELEVANT;
    case r'PERSONAL_PREFERENCE':
      return Enum$TopicSuggestionDeclineReason.PERSONAL_PREFERENCE;
    case r'TOO_GENERAL':
      return Enum$TopicSuggestionDeclineReason.TOO_GENERAL;
    case r'TOO_SPECIFIC':
      return Enum$TopicSuggestionDeclineReason.TOO_SPECIFIC;
    default:
      return Enum$TopicSuggestionDeclineReason.$unknown;
  }
}

enum Enum$TrackedIssueStates { CLOSED, OPEN, $unknown }

String toJson$Enum$TrackedIssueStates(Enum$TrackedIssueStates e) {
  switch (e) {
    case Enum$TrackedIssueStates.CLOSED:
      return r'CLOSED';
    case Enum$TrackedIssueStates.OPEN:
      return r'OPEN';
    case Enum$TrackedIssueStates.$unknown:
      return r'$unknown';
  }
}

Enum$TrackedIssueStates fromJson$Enum$TrackedIssueStates(String value) {
  switch (value) {
    case r'CLOSED':
      return Enum$TrackedIssueStates.CLOSED;
    case r'OPEN':
      return Enum$TrackedIssueStates.OPEN;
    default:
      return Enum$TrackedIssueStates.$unknown;
  }
}

enum Enum$UserBlockDuration {
  ONE_DAY,
  ONE_MONTH,
  ONE_WEEK,
  PERMANENT,
  THREE_DAYS,
  $unknown
}

String toJson$Enum$UserBlockDuration(Enum$UserBlockDuration e) {
  switch (e) {
    case Enum$UserBlockDuration.ONE_DAY:
      return r'ONE_DAY';
    case Enum$UserBlockDuration.ONE_MONTH:
      return r'ONE_MONTH';
    case Enum$UserBlockDuration.ONE_WEEK:
      return r'ONE_WEEK';
    case Enum$UserBlockDuration.PERMANENT:
      return r'PERMANENT';
    case Enum$UserBlockDuration.THREE_DAYS:
      return r'THREE_DAYS';
    case Enum$UserBlockDuration.$unknown:
      return r'$unknown';
  }
}

Enum$UserBlockDuration fromJson$Enum$UserBlockDuration(String value) {
  switch (value) {
    case r'ONE_DAY':
      return Enum$UserBlockDuration.ONE_DAY;
    case r'ONE_MONTH':
      return Enum$UserBlockDuration.ONE_MONTH;
    case r'ONE_WEEK':
      return Enum$UserBlockDuration.ONE_WEEK;
    case r'PERMANENT':
      return Enum$UserBlockDuration.PERMANENT;
    case r'THREE_DAYS':
      return Enum$UserBlockDuration.THREE_DAYS;
    default:
      return Enum$UserBlockDuration.$unknown;
  }
}

enum Enum$UserStatusOrderField { UPDATED_AT, $unknown }

String toJson$Enum$UserStatusOrderField(Enum$UserStatusOrderField e) {
  switch (e) {
    case Enum$UserStatusOrderField.UPDATED_AT:
      return r'UPDATED_AT';
    case Enum$UserStatusOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$UserStatusOrderField fromJson$Enum$UserStatusOrderField(String value) {
  switch (value) {
    case r'UPDATED_AT':
      return Enum$UserStatusOrderField.UPDATED_AT;
    default:
      return Enum$UserStatusOrderField.$unknown;
  }
}

enum Enum$VerifiableDomainOrderField { CREATED_AT, DOMAIN, $unknown }

String toJson$Enum$VerifiableDomainOrderField(
    Enum$VerifiableDomainOrderField e) {
  switch (e) {
    case Enum$VerifiableDomainOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$VerifiableDomainOrderField.DOMAIN:
      return r'DOMAIN';
    case Enum$VerifiableDomainOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$VerifiableDomainOrderField fromJson$Enum$VerifiableDomainOrderField(
    String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$VerifiableDomainOrderField.CREATED_AT;
    case r'DOMAIN':
      return Enum$VerifiableDomainOrderField.DOMAIN;
    default:
      return Enum$VerifiableDomainOrderField.$unknown;
  }
}

enum Enum$WorkflowRunOrderField { CREATED_AT, $unknown }

String toJson$Enum$WorkflowRunOrderField(Enum$WorkflowRunOrderField e) {
  switch (e) {
    case Enum$WorkflowRunOrderField.CREATED_AT:
      return r'CREATED_AT';
    case Enum$WorkflowRunOrderField.$unknown:
      return r'$unknown';
  }
}

Enum$WorkflowRunOrderField fromJson$Enum$WorkflowRunOrderField(String value) {
  switch (value) {
    case r'CREATED_AT':
      return Enum$WorkflowRunOrderField.CREATED_AT;
    default:
      return Enum$WorkflowRunOrderField.$unknown;
  }
}

enum Enum$WorkflowState {
  ACTIVE,
  DELETED,
  DISABLED_FORK,
  DISABLED_INACTIVITY,
  DISABLED_MANUALLY,
  $unknown
}

String toJson$Enum$WorkflowState(Enum$WorkflowState e) {
  switch (e) {
    case Enum$WorkflowState.ACTIVE:
      return r'ACTIVE';
    case Enum$WorkflowState.DELETED:
      return r'DELETED';
    case Enum$WorkflowState.DISABLED_FORK:
      return r'DISABLED_FORK';
    case Enum$WorkflowState.DISABLED_INACTIVITY:
      return r'DISABLED_INACTIVITY';
    case Enum$WorkflowState.DISABLED_MANUALLY:
      return r'DISABLED_MANUALLY';
    case Enum$WorkflowState.$unknown:
      return r'$unknown';
  }
}

Enum$WorkflowState fromJson$Enum$WorkflowState(String value) {
  switch (value) {
    case r'ACTIVE':
      return Enum$WorkflowState.ACTIVE;
    case r'DELETED':
      return Enum$WorkflowState.DELETED;
    case r'DISABLED_FORK':
      return Enum$WorkflowState.DISABLED_FORK;
    case r'DISABLED_INACTIVITY':
      return Enum$WorkflowState.DISABLED_INACTIVITY;
    case r'DISABLED_MANUALLY':
      return Enum$WorkflowState.DISABLED_MANUALLY;
    default:
      return Enum$WorkflowState.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{
  'Node': {
    'AddedToProjectEvent',
    'App',
    'AssignedEvent',
    'AutoMergeDisabledEvent',
    'AutoMergeEnabledEvent',
    'AutoRebaseEnabledEvent',
    'AutoSquashEnabledEvent',
    'AutomaticBaseChangeFailedEvent',
    'AutomaticBaseChangeSucceededEvent',
    'BaseRefChangedEvent',
    'BaseRefDeletedEvent',
    'BaseRefForcePushedEvent',
    'Blob',
    'Bot',
    'BranchProtectionRule',
    'BypassForcePushAllowance',
    'BypassPullRequestAllowance',
    'CWE',
    'CheckRun',
    'CheckSuite',
    'ClosedEvent',
    'CodeOfConduct',
    'CommentDeletedEvent',
    'Commit',
    'CommitComment',
    'CommitCommentThread',
    'Comparison',
    'ConnectedEvent',
    'ConvertToDraftEvent',
    'ConvertedNoteToIssueEvent',
    'ConvertedToDiscussionEvent',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'DependencyGraphManifest',
    'DeployKey',
    'DeployedEvent',
    'Deployment',
    'DeploymentEnvironmentChangedEvent',
    'DeploymentReview',
    'DeploymentStatus',
    'DisconnectedEvent',
    'Discussion',
    'DiscussionCategory',
    'DiscussionComment',
    'DiscussionPoll',
    'DiscussionPollOption',
    'DraftIssue',
    'Enterprise',
    'EnterpriseAdministratorInvitation',
    'EnterpriseIdentityProvider',
    'EnterpriseRepositoryInfo',
    'EnterpriseServerInstallation',
    'EnterpriseServerUserAccount',
    'EnterpriseServerUserAccountEmail',
    'EnterpriseServerUserAccountsUpload',
    'EnterpriseUserAccount',
    'Environment',
    'ExternalIdentity',
    'Gist',
    'GistComment',
    'HeadRefDeletedEvent',
    'HeadRefForcePushedEvent',
    'HeadRefRestoredEvent',
    'IpAllowListEntry',
    'Issue',
    'IssueComment',
    'Label',
    'LabeledEvent',
    'Language',
    'License',
    'LinkedBranch',
    'LockedEvent',
    'Mannequin',
    'MarkedAsDuplicateEvent',
    'MarketplaceCategory',
    'MarketplaceListing',
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'MentionedEvent',
    'MergedEvent',
    'MigrationSource',
    'Milestone',
    'MilestonedEvent',
    'MovedColumnsInProjectEvent',
    'OIDCProvider',
    'OauthApplicationCreateAuditEntry',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'Organization',
    'OrganizationIdentityProvider',
    'OrganizationInvitation',
    'OrganizationMigration',
    'Package',
    'PackageFile',
    'PackageTag',
    'PackageVersion',
    'PinnedDiscussion',
    'PinnedEvent',
    'PinnedIssue',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'Project',
    'ProjectCard',
    'ProjectColumn',
    'ProjectV2',
    'ProjectV2Field',
    'ProjectV2Item',
    'ProjectV2ItemFieldDateValue',
    'ProjectV2ItemFieldIterationValue',
    'ProjectV2ItemFieldNumberValue',
    'ProjectV2ItemFieldSingleSelectValue',
    'ProjectV2ItemFieldTextValue',
    'ProjectV2IterationField',
    'ProjectV2SingleSelectField',
    'ProjectV2View',
    'ProjectV2Workflow',
    'PublicKey',
    'PullRequest',
    'PullRequestCommit',
    'PullRequestCommitCommentThread',
    'PullRequestReview',
    'PullRequestReviewComment',
    'PullRequestReviewThread',
    'PullRequestThread',
    'Push',
    'PushAllowance',
    'Reaction',
    'ReadyForReviewEvent',
    'Ref',
    'ReferencedEvent',
    'Release',
    'ReleaseAsset',
    'RemovedFromProjectEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'Repository',
    'RepositoryInvitation',
    'RepositoryMigration',
    'RepositoryTopic',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'RepositoryVulnerabilityAlert',
    'ReviewDismissalAllowance',
    'ReviewDismissedEvent',
    'ReviewRequest',
    'ReviewRequestRemovedEvent',
    'ReviewRequestedEvent',
    'SavedReply',
    'SecurityAdvisory',
    'SponsorsActivity',
    'SponsorsListing',
    'SponsorsListingFeaturedItem',
    'SponsorsTier',
    'Sponsorship',
    'SponsorshipNewsletter',
    'Status',
    'StatusCheckRollup',
    'StatusContext',
    'SubscribedEvent',
    'Tag',
    'Team',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamDiscussion',
    'TeamDiscussionComment',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
    'Topic',
    'TransferredEvent',
    'Tree',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnmarkedAsDuplicateEvent',
    'UnpinnedEvent',
    'UnsubscribedEvent',
    'User',
    'UserBlockedEvent',
    'UserContentEdit',
    'UserStatus',
    'VerifiableDomain',
    'Workflow',
    'WorkflowRun',
  },
  'Assignee': {
    'Bot',
    'Mannequin',
    'Organization',
    'User',
  },
  'AuditEntryActor': {
    'Bot',
    'Organization',
    'User',
  },
  'GitObject': {
    'Blob',
    'Commit',
    'Tag',
    'Tree',
  },
  'Actor': {
    'Bot',
    'EnterpriseUserAccount',
    'Mannequin',
    'Organization',
    'User',
  },
  'UniformResourceLocatable': {
    'Bot',
    'CheckRun',
    'ClosedEvent',
    'Commit',
    'ConvertToDraftEvent',
    'CrossReferencedEvent',
    'Gist',
    'Issue',
    'Mannequin',
    'MergedEvent',
    'Milestone',
    'Organization',
    'PullRequest',
    'PullRequestCommit',
    'ReadyForReviewEvent',
    'Release',
    'Repository',
    'RepositoryTopic',
    'ReviewDismissedEvent',
    'TeamDiscussion',
    'TeamDiscussionComment',
    'User',
    'WorkflowRun',
  },
  'BranchActorAllowanceActor': {
    'App',
    'Team',
    'User',
  },
  'RequirableByPullRequest': {
    'CheckRun',
    'StatusContext',
  },
  'Claimable': {
    'Mannequin',
    'User',
  },
  'Closer': {
    'Commit',
    'PullRequest',
  },
  'Subscribable': {
    'Commit',
    'Discussion',
    'Issue',
    'PullRequest',
    'Repository',
    'Team',
    'TeamDiscussion',
  },
  'Comment': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'GistComment',
    'Issue',
    'IssueComment',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'Deletable': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'GistComment',
    'IssueComment',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'Minimizable': {
    'CommitComment',
    'DiscussionComment',
    'GistComment',
    'IssueComment',
    'PullRequestReviewComment',
  },
  'Reactable': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'Issue',
    'IssueComment',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'Release',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'RepositoryNode': {
    'CommitComment',
    'CommitCommentThread',
    'DependabotUpdate',
    'Discussion',
    'DiscussionCategory',
    'Issue',
    'IssueComment',
    'PinnedDiscussion',
    'PullRequest',
    'PullRequestCommitCommentThread',
    'PullRequestReview',
    'PullRequestReviewComment',
    'RepositoryVulnerabilityAlert',
  },
  'Updatable': {
    'CommitComment',
    'Discussion',
    'DiscussionComment',
    'GistComment',
    'Issue',
    'IssueComment',
    'Project',
    'ProjectV2',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'UpdatableComment': {
    'CommitComment',
    'DiscussionComment',
    'GistComment',
    'Issue',
    'IssueComment',
    'PullRequest',
    'PullRequestReview',
    'PullRequestReviewComment',
    'TeamDiscussion',
    'TeamDiscussionComment',
  },
  'Contribution': {
    'CreatedCommitContribution',
    'CreatedIssueContribution',
    'CreatedPullRequestContribution',
    'CreatedPullRequestReviewContribution',
    'CreatedRepositoryContribution',
    'JoinedGitHubContribution',
    'RestrictedContribution',
  },
  'CreatedIssueOrRestrictedContribution': {
    'CreatedIssueContribution',
    'RestrictedContribution',
  },
  'CreatedPullRequestOrRestrictedContribution': {
    'CreatedPullRequestContribution',
    'RestrictedContribution',
  },
  'CreatedRepositoryOrRestrictedContribution': {
    'CreatedRepositoryContribution',
    'RestrictedContribution',
  },
  'DeploymentReviewer': {
    'Team',
    'User',
  },
  'Closable': {
    'Discussion',
    'Issue',
    'Milestone',
    'Project',
    'ProjectV2',
    'PullRequest',
  },
  'Labelable': {
    'Discussion',
    'Issue',
    'PullRequest',
  },
  'Lockable': {
    'Discussion',
    'Issue',
    'PullRequest',
  },
  'Votable': {
    'Discussion',
    'DiscussionComment',
  },
  'AnnouncementBanner': {
    'Enterprise',
    'Organization',
  },
  'EnterpriseMember': {
    'EnterpriseUserAccount',
    'User',
  },
  'HovercardContext': {
    'GenericHovercardContext',
    'OrganizationTeamsHovercardContext',
    'OrganizationsHovercardContext',
    'ReviewStatusHovercardContext',
    'ViewerHovercardContext',
  },
  'Starrable': {
    'Gist',
    'Repository',
    'Topic',
  },
  'GitSignature': {
    'GpgSignature',
    'SmimeSignature',
    'SshSignature',
    'UnknownSignature',
  },
  'IpAllowListOwner': {
    'App',
    'Enterprise',
    'Organization',
  },
  'Assignable': {
    'Issue',
    'PullRequest',
  },
  'ProjectV2Owner': {
    'Issue',
    'Organization',
    'PullRequest',
    'User',
  },
  'IssueOrPullRequest': {
    'Issue',
    'PullRequest',
  },
  'IssueTimelineItem': {
    'AssignedEvent',
    'ClosedEvent',
    'Commit',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MilestonedEvent',
    'ReferencedEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'SubscribedEvent',
    'TransferredEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'IssueTimelineItems': {
    'AddedToProjectEvent',
    'AssignedEvent',
    'ClosedEvent',
    'CommentDeletedEvent',
    'ConnectedEvent',
    'ConvertedNoteToIssueEvent',
    'ConvertedToDiscussionEvent',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'DisconnectedEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MarkedAsDuplicateEvent',
    'MentionedEvent',
    'MilestonedEvent',
    'MovedColumnsInProjectEvent',
    'PinnedEvent',
    'ReferencedEvent',
    'RemovedFromProjectEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'SubscribedEvent',
    'TransferredEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnmarkedAsDuplicateEvent',
    'UnpinnedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'AuditEntry': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OauthApplicationCreateAuditEntry',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'EnterpriseAuditEntryData': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
  },
  'OrganizationAuditEntryData': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OauthApplicationCreateAuditEntry',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgRestoreMemberMembershipOrganizationAuditEntryData',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'MilestoneItem': {
    'Issue',
    'PullRequest',
  },
  'OauthApplicationAuditEntryData': {
    'OauthApplicationCreateAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
  },
  'OrgRestoreMemberAuditEntryMembership': {
    'OrgRestoreMemberMembershipOrganizationAuditEntryData',
    'OrgRestoreMemberMembershipRepositoryAuditEntryData',
    'OrgRestoreMemberMembershipTeamAuditEntryData',
  },
  'RepositoryAuditEntryData': {
    'OrgRestoreMemberMembershipRepositoryAuditEntryData',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'TeamAuditEntryData': {
    'OrgRestoreMemberMembershipTeamAuditEntryData',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'MemberStatusable': {
    'Organization',
    'Team',
  },
  'PackageOwner': {
    'Organization',
    'Repository',
    'User',
  },
  'ProfileOwner': {
    'Organization',
    'User',
  },
  'ProjectOwner': {
    'Organization',
    'Repository',
    'User',
  },
  'ProjectV2Recent': {
    'Organization',
    'Repository',
    'User',
  },
  'RepositoryDiscussionAuthor': {
    'Organization',
    'User',
  },
  'RepositoryDiscussionCommentAuthor': {
    'Organization',
    'User',
  },
  'RepositoryOwner': {
    'Organization',
    'User',
  },
  'Sponsorable': {
    'Organization',
    'User',
  },
  'OrganizationAuditEntry': {
    'MembersCanDeleteReposClearAuditEntry',
    'MembersCanDeleteReposDisableAuditEntry',
    'MembersCanDeleteReposEnableAuditEntry',
    'OauthApplicationCreateAuditEntry',
    'OrgAddBillingManagerAuditEntry',
    'OrgAddMemberAuditEntry',
    'OrgBlockUserAuditEntry',
    'OrgConfigDisableCollaboratorsOnlyAuditEntry',
    'OrgConfigEnableCollaboratorsOnlyAuditEntry',
    'OrgCreateAuditEntry',
    'OrgDisableOauthAppRestrictionsAuditEntry',
    'OrgDisableSamlAuditEntry',
    'OrgDisableTwoFactorRequirementAuditEntry',
    'OrgEnableOauthAppRestrictionsAuditEntry',
    'OrgEnableSamlAuditEntry',
    'OrgEnableTwoFactorRequirementAuditEntry',
    'OrgInviteMemberAuditEntry',
    'OrgInviteToBusinessAuditEntry',
    'OrgOauthAppAccessApprovedAuditEntry',
    'OrgOauthAppAccessDeniedAuditEntry',
    'OrgOauthAppAccessRequestedAuditEntry',
    'OrgRemoveBillingManagerAuditEntry',
    'OrgRemoveMemberAuditEntry',
    'OrgRemoveOutsideCollaboratorAuditEntry',
    'OrgRestoreMemberAuditEntry',
    'OrgUnblockUserAuditEntry',
    'OrgUpdateDefaultRepositoryPermissionAuditEntry',
    'OrgUpdateMemberAuditEntry',
    'OrgUpdateMemberRepositoryCreationPermissionAuditEntry',
    'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry',
    'PrivateRepositoryForkingDisableAuditEntry',
    'PrivateRepositoryForkingEnableAuditEntry',
    'RepoAccessAuditEntry',
    'RepoAddMemberAuditEntry',
    'RepoAddTopicAuditEntry',
    'RepoArchivedAuditEntry',
    'RepoChangeMergeSettingAuditEntry',
    'RepoConfigDisableAnonymousGitAccessAuditEntry',
    'RepoConfigDisableCollaboratorsOnlyAuditEntry',
    'RepoConfigDisableContributorsOnlyAuditEntry',
    'RepoConfigDisableSockpuppetDisallowedAuditEntry',
    'RepoConfigEnableAnonymousGitAccessAuditEntry',
    'RepoConfigEnableCollaboratorsOnlyAuditEntry',
    'RepoConfigEnableContributorsOnlyAuditEntry',
    'RepoConfigEnableSockpuppetDisallowedAuditEntry',
    'RepoConfigLockAnonymousGitAccessAuditEntry',
    'RepoConfigUnlockAnonymousGitAccessAuditEntry',
    'RepoCreateAuditEntry',
    'RepoDestroyAuditEntry',
    'RepoRemoveMemberAuditEntry',
    'RepoRemoveTopicAuditEntry',
    'RepositoryVisibilityChangeDisableAuditEntry',
    'RepositoryVisibilityChangeEnableAuditEntry',
    'TeamAddMemberAuditEntry',
    'TeamAddRepositoryAuditEntry',
    'TeamChangeParentTeamAuditEntry',
    'TeamRemoveMemberAuditEntry',
    'TeamRemoveRepositoryAuditEntry',
  },
  'OrganizationOrUser': {
    'Organization',
    'User',
  },
  'PermissionGranter': {
    'Organization',
    'Repository',
    'Team',
  },
  'PinnableItem': {
    'Gist',
    'Repository',
  },
  'ProjectCardItem': {
    'Issue',
    'PullRequest',
  },
  'ProjectV2FieldCommon': {
    'ProjectV2Field',
    'ProjectV2IterationField',
    'ProjectV2SingleSelectField',
  },
  'ProjectV2FieldConfiguration': {
    'ProjectV2Field',
    'ProjectV2IterationField',
    'ProjectV2SingleSelectField',
  },
  'ProjectV2ItemContent': {
    'DraftIssue',
    'Issue',
    'PullRequest',
  },
  'ProjectV2ItemFieldValueCommon': {
    'ProjectV2ItemFieldDateValue',
    'ProjectV2ItemFieldIterationValue',
    'ProjectV2ItemFieldNumberValue',
    'ProjectV2ItemFieldSingleSelectValue',
    'ProjectV2ItemFieldTextValue',
  },
  'ProjectV2ItemFieldValue': {
    'ProjectV2ItemFieldDateValue',
    'ProjectV2ItemFieldIterationValue',
    'ProjectV2ItemFieldLabelValue',
    'ProjectV2ItemFieldMilestoneValue',
    'ProjectV2ItemFieldNumberValue',
    'ProjectV2ItemFieldPullRequestValue',
    'ProjectV2ItemFieldRepositoryValue',
    'ProjectV2ItemFieldReviewerValue',
    'ProjectV2ItemFieldSingleSelectValue',
    'ProjectV2ItemFieldTextValue',
    'ProjectV2ItemFieldUserValue',
  },
  'PullRequestTimelineItem': {
    'AssignedEvent',
    'BaseRefDeletedEvent',
    'BaseRefForcePushedEvent',
    'ClosedEvent',
    'Commit',
    'CommitCommentThread',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'DeployedEvent',
    'DeploymentEnvironmentChangedEvent',
    'HeadRefDeletedEvent',
    'HeadRefForcePushedEvent',
    'HeadRefRestoredEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MergedEvent',
    'MilestonedEvent',
    'PullRequestReview',
    'PullRequestReviewComment',
    'PullRequestReviewThread',
    'ReferencedEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'ReviewDismissedEvent',
    'ReviewRequestRemovedEvent',
    'ReviewRequestedEvent',
    'SubscribedEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'PullRequestTimelineItems': {
    'AddedToProjectEvent',
    'AssignedEvent',
    'AutoMergeDisabledEvent',
    'AutoMergeEnabledEvent',
    'AutoRebaseEnabledEvent',
    'AutoSquashEnabledEvent',
    'AutomaticBaseChangeFailedEvent',
    'AutomaticBaseChangeSucceededEvent',
    'BaseRefChangedEvent',
    'BaseRefDeletedEvent',
    'BaseRefForcePushedEvent',
    'ClosedEvent',
    'CommentDeletedEvent',
    'ConnectedEvent',
    'ConvertToDraftEvent',
    'ConvertedNoteToIssueEvent',
    'ConvertedToDiscussionEvent',
    'CrossReferencedEvent',
    'DemilestonedEvent',
    'DeployedEvent',
    'DeploymentEnvironmentChangedEvent',
    'DisconnectedEvent',
    'HeadRefDeletedEvent',
    'HeadRefForcePushedEvent',
    'HeadRefRestoredEvent',
    'IssueComment',
    'LabeledEvent',
    'LockedEvent',
    'MarkedAsDuplicateEvent',
    'MentionedEvent',
    'MergedEvent',
    'MilestonedEvent',
    'MovedColumnsInProjectEvent',
    'PinnedEvent',
    'PullRequestCommit',
    'PullRequestCommitCommentThread',
    'PullRequestReview',
    'PullRequestReviewThread',
    'PullRequestRevisionMarker',
    'ReadyForReviewEvent',
    'ReferencedEvent',
    'RemovedFromProjectEvent',
    'RenamedTitleEvent',
    'ReopenedEvent',
    'ReviewDismissedEvent',
    'ReviewRequestRemovedEvent',
    'ReviewRequestedEvent',
    'SubscribedEvent',
    'TransferredEvent',
    'UnassignedEvent',
    'UnlabeledEvent',
    'UnlockedEvent',
    'UnmarkedAsDuplicateEvent',
    'UnpinnedEvent',
    'UnsubscribedEvent',
    'UserBlockedEvent',
  },
  'PushAllowanceActor': {
    'App',
    'Team',
    'User',
  },
  'Reactor': {
    'Bot',
    'Mannequin',
    'Organization',
    'User',
  },
  'ReferencedSubject': {
    'Issue',
    'PullRequest',
  },
  'RenamedTitleSubject': {
    'Issue',
    'PullRequest',
  },
  'TopicAuditEntryData': {
    'RepoAddTopicAuditEntry',
    'RepoRemoveTopicAuditEntry',
  },
  'RepositoryInfo': {'Repository'},
  'Migration': {'RepositoryMigration'},
  'RequestedReviewer': {
    'Mannequin',
    'Team',
    'User',
  },
  'ReviewDismissalAllowanceActor': {
    'App',
    'Team',
    'User',
  },
  'SearchResultItem': {
    'App',
    'Discussion',
    'Issue',
    'MarketplaceListing',
    'Organization',
    'PullRequest',
    'Repository',
    'User',
  },
  'Sponsor': {
    'Organization',
    'User',
  },
  'SponsorableItem': {
    'Organization',
    'User',
  },
  'SponsorsListingFeatureableItem': {
    'Repository',
    'User',
  },
  'StatusCheckRollupContext': {
    'CheckRun',
    'StatusContext',
  },
  'VerifiableDomainOwner': {
    'Enterprise',
    'Organization',
  },
};
